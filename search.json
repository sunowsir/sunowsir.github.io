[{"title":"八大排序算法总结","url":"%2F2019%2F09%2F27%2F%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F","content":"\n\n\n```javascript\n<script type=\"text/javascript\"\n   src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\">\n</script>\n```\n\n\n\n## 直接插入排序算法\n\n* 概述\n\n  直接插入排序算法在逻辑上将整体数据分为两部分，一部分是已排序部分，另一部分是待排序部分 。\n\n  排序的过程是：在待排序部分逐步的拿出一个元素，将其插入到已排序部分中合理的位置 。\n\n* 适用场景\n\n  插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率，\n\n  但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 。\n\n* 数据结构\n\n  直接插入排序使用的数据结构是数组 。\n\n* 优化\n\n  在给当前待排序元素在已排序部分找到一个合适的位置并且待排序数据相对较多的时候，由于已排序部分元素是有序的，因此这个过程可以使用二分法，以优化排序的时间复杂度。\n\n* 归类\n\n  in-place（原地算法：基本上不需要额外的空间）、稳定排序算法。\n\n* 空间复杂度\n\n  直接插入排序是in-place，因此其空间复杂度是 O(1) 。\n\n* 时间复杂度\n\n  * 最优\n\n    最优的情况是待排序数据为已排序好的期望顺序，此时每次从待排序部分拿出一个元素只需要与待排序部分中最后一个元素相比较一次，需要比较 $n - 1$ 次，因此其复杂度为 $O(n)$ 。\n\n  * 最坏\n\n      最坏的情况是待排序数据为已排序好的，但是其顺序正好与期望顺序相反，此时每次从待排序部分拿出一个元素，该元素需要与其前面的已排序部分中的每一个元素进行比较和交换，其比较或交换的次数为 $0 + 1 + 2 + ... + (n - 2) + (n - 1)$ 也就是　$ \\frac{n * (n - 1)}{2}$ ，因此其复杂度为 $O(n^{2})$ .\n\n  * 平均\n\n    $O(n^{2})$\n\n* 代码示例\n\n  ```c++\n  void insertion_sort(int arr[], int len){\n          int i,j,key;\n          for (i=1;i<len;i++){\n                  key = arr[i];\n                  j=i-1;\n                  while((j>=0) && (arr[j]>key)) {\n                          arr[j+1] = arr[j];\n                          j--;\n                  }\n                  arr[j+1] = key;\n          }\n  }\n  ```\n\n  \n\n\n\n\n\n## 希尔排序\n\n> 待更新\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---\n\n资源引用声明：\n\n[维基百科](https://zh.wikipedia.org/wiki/) : https://zh.wikipedia.org/wiki/","tags":["alogrithm"]},{"title":"hexo低成本搭建静态网页博客","url":"%2F2019%2F09%2F16%2Fhexo%E4%BD%8E%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%8D%9A%E5%AE%A2%2F","content":"\n\n\n\n\n## 引言\n好多同学有写博客的习惯，也有各大例如csd*、简*等博客平台。\n但是这些平台毕竟是盈利平台，无法做到对自己的博客完全掌控，有一丝丝的不爽快。想要DIY一下几乎不可能。在这里推荐同学们自己动手丰衣足食。\n\n## 准备知识\n1. github最基本的使用（拥有账号，会建立仓库，与本地电脑进行远程代码推送）。\n2. git最基本的使用（推送代码到远程例如github这种托管平台）。\n3. linux最基本的常用的命令（推荐linux平台）。\n\n## 原理解析\n* 托管与访问\n  github为每一个用户提供了免费的500M（貌似是）的空间，建立名称为`username.github.io`的仓库，可以把我们做好的博客静态网页放到该仓库中，然后使用`username.github.io`就可以访问我们的博客了。\n* 博客代码生成\n  使用hexo可以一行命令轻松生成可以高度定制的现成的博客代码，hexo官网还提供了大量的插件和主题供使用者DIY。\n\n## 搭建步骤\n> 此处忽略本地git与github绑定相关知识以及代码推送相关知识。\n> 这里本机环境使用linux（debian系）\n1. 在github平台上登录账号，新建名称为`username.github.io`的仓库备用。例如`sunowsir.github.io`（username是github用户名）\n2. 安装nodejs与npm环境（自行百度），确保`npm -v`正常显示。\n3. 安装hexo：`sudo npm install -g hexo-cli。\n  `\n4. 新建一个hexo项目：`hexo init 项目名称`。例如`hexo init MYclub`。\n5. 进入项目目录：`cd MYclub`。\n6. 创建新文章：`hexo new 文章标题`，生成一个markdown文件，在`source/_posts/`下。\n7. 配置文件：_config.yml\n8. 生成博客代码：`hexo g`，生成的博客代码在项目目录下的public目录中。\n9. 将public中所有的内容都push到之前创建的仓库中。\n10. 打开浏览器访问`username.github.io`看看。\n\n\n\n---\n[更多hexo相关参考](https://hexo.io/zh-cn/docs/)：https://hexo.io/zh-cn/docs/","tags":["note"]},{"title":"HDU-1276","url":"%2F2019%2F09%2F02%2FHDU-1276%2F","content":"\n* 题目描述\n\n  某部队进行新兵队列训练，将新兵从一开始按顺序依次编号，并排成一行横队，训练的规则如下：从头开始一至二报数，凡报到二的出列，剩下的向小序号方向靠拢，再从头开始进行一至三报数，凡报到三的出列，剩下的向小序号方向靠拢，继续从头开始进行一至二报数。。。，以后从头开始轮流进行一至二报数、一至三报数直到剩下的人数不超过三人为止。\n\n  Input\n\n  本题有多个测试数据组，第一行为组数N，接着为N行新兵人数，新兵人数不超过5000。\n\n  Output\n\n  共有N行，分别对应输入的新兵人数，每行输出剩下的新兵最初的编号，编号之间有一个空格。\n\n* Sample Input\n\n```\n2 20 40\n```\n\n* Sample Output\n\n```\n1 7 19 1 19 37\n```\n\n\n\n* 代码如下：\n\n\n\n```c++\n************************/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\n    int N,n,sol_num,cnt;\n\n    int sol[5005];\n\n    //输入数据的组数；\n\n    cin>>n;\n\n    while(n--){\n\n        //每次都需要把数组清零；\n\n        memset(sol,0,sizeof(sol));\n\n        //输入新兵的人数；\n\n        cin>>sol_num;\n\n        //把初始编号存入数组；\n\n        for(int i=1;i<=sol_num;i++)  sol[i]=i;\n\n        //把变量sol_num用作每次筛选剩下的人数；\n\n        N=sol_num;\n\n        //剩下的人数不超过3个；\n\n        while(sol_num>3){\n\n            cnt=0;\n\n            //当人数不超过3个的时候跳出\n\n            if(sol_num>3){\n\n                //每次都循环到N；\n\n                for(int i=1;i<=N;i++){\n\n                    //跳过被赋值为另的位置；\n\n                    if(sol[i])  cnt++;\n\n                    //把报数为2的赋值为0，当前长度减1；\n\n                    if(cnt==2){\n\n                        sol[i]=0;\n\n                        sol_num--;\n\n                        cnt=0;\n\n                    }\n\n                }\n\n            }\n\n            cnt=0;\n\n            //当人数不超过三个的时候跳出；\n\n            if(sol_num>3){\n\n                for(int i=1;i<=N;i++){\n\n                    if(sol[i])  cnt++;\n\n                    if(cnt==3){\n\n                        sol[i]=0;\n\n                        sol_num--;\n\n                        cnt=0;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        //输出的时候注意控制空格，为零的位置要直接跳过；\n\n        int tmp=0;\n\n        for(int i=1;i<=N;i++){\n\n            if(sol[i]!=0){\n\n                if(tmp==1)  cout<<\" \";\n\n                tmp=1;\n\n                cout<<sol[i];\n\n            }\n\n        }\n\n        cout<<endl;\n\n    }\n\n    return 0;\n\n}\n\n\n\n```\n\n\n\n\n\n---\n\n该题思想来自网络；\n","tags":["HDU"]},{"title":"CPU信息获取","url":"%2F2019%2F09%2F02%2FCPU%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%2F","content":"\n* 准备知识\n\n  1. `/proc`文件系统是一个伪文件系统，该文件系统中存储着内核控制相关信息，通俗点说就是这个目录是虚拟的，它受内核直接控制，存储与内核控制相关的数据，与其他目录不同的是`/proc`目录不是真实存储在硬盘中的，它的数据存储在内存中，但是由于它和其他目录一样把自己注册到虚拟文件系统层了，所以我们还是能看到这个目录相关信息，然而只有虚拟文件系统层调用它的时候，他才会建立相关文件和目录并与内核沟通获取相关信息。\n\n  2. 上面我们说道`/proc` 文件系统存储着内核控制相关信息的目录，该目录下的`/proc/stat`文件存储的是`CPU`相关信息，我们想要获取`CPU`相关信息最直接和最快速的方式就是读取该文件，其实`Linux下`很多的工具都是读取的这个文件。在这个文件中包含了所有的`CPU`活动信息，并且该文件中所有值都是从系统启动算起直到访问文件的这一刻的数据。如下就是某一刻`/proc/stat`文件中的数据：\n\n     ```bash \n     cpu  499312 1086 227835 10498412 3803 0 10904 0 0 0\n     cpu0 125361 278 56675 2626355 450 0 2242 0 0 0\n     cpu1 124704 288 57768 2627741 350 0 2168 0 0 0\n     cpu2 130284 261 55543 2620559 2442 0 1762 0 0 0\n     cpu3 118961 258 57848 2623755 560 0 4731 0 0 0\n     intr 46393945 9 924 0 0 0 0 0 0 1 14751 0 0 215 0 0 0 139800 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4476 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 408029 0 283839 7963609 40 945 1535489 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n     ctxt 124171702\n     btime 1539737966\n     processes 626819\n     procs_running 4\n     procs_blocked 0\n     softirq 27922585 9163685 6158929 26 485 278010 0 160301 6495615 0 5665534\n     ```\n\n     > 数据单位：jiffies\n\n     * 如上数据中从cpu到cpu3五行（从左到右按顺序）每一列的含义如下：\n\n       1. `user`：如上**499312**、**125361**、**124704**等，用户态时间。\n       2. `nice`：如上**1086**等第二列数据，`nice`值为负数的进程所占时间。\n       3. `system`：如上第三列数据，核心时间。\n       4. `idle`：如上第四列数据，除硬盘IO等待时间之外的时间。\n       5. `iowait`：如上第五列数据，硬盘IO等待时间。\n       6. `irq`：如上第六列数据，硬中断时间。\n       7. `softirq`如上第七列数据，软中断时间。\n\n       $$\n       CPU_{time}=user_{line:1} +nice_{line:2} + system_{line:3} + idle_{line:4} + iowait_{line:5} + irq_{line:6} + sortirq_{line:7}\n       $$\n\n     * 剩下的几行：\n\n       1. `initr`：中断次数\n       2. `ctxt`：交换次数\n       3. `btime`:从系统启动到访问文件为止的时间。\n       4. `processes`：任务数。\n       5. `procs_runing`：当前运行队列的任务数。\n       6. `procs_blocked`：当前被阻塞的任务数。\n\n     * `CPU`利用率计算可以采用两点采样取差值的方式：\n\n       $$\n       CPU_{usage} = (idle_{第二次采样} - idle_{第一次采样}) / (CPU_{time第二次采样} - CPU_{time第一次采样}) * 100\n       $$\n\n  3. CPU温度的获取：\n\n     cpu温度存储在`/sys/class/thermal/thermal_zone0/temp`中，读取出的数值需要除以1000。\n\n  4. bash 工具：\n\n     1. `cat`：工具用来强制读取一个文件。\n     2. `gerp`：工具用来筛选数据。\n     3. `awk`：用来处理数据。\n     4. `uptime`：获取cpu负载信息\n\n  5. bash 数值计算：\n\n     bash中的数值计算比较方便的方式是双小括号：\n\n     ```bash\n     num=0\n     ((num++)) # 在双小括号中可以正常使用C语言的数值计算语法\n     echo ${num}\n     \n     # 结果输出---------------\n     1\n     ```\n\n* 代码\n```bash\n#!/bin/bash\n\ntime_and_load=`date +\"%Y-%m-%d__%H:%M:%S \"``uptime | tr -s \" \" \"\\n\" | tr -s \",\" \" \" | awk NF | tail -3 | tr -s \"\\n\" \" \"`\n\n# 0.5s 前\n# 开机后总时间\ncpu_local1=`cat /proc/stat | grep  -w \"cpu\" | awk '{printf(\"%d\", $2 + $3 + $4 + $5 + $6 + $7 + 8);}'`\n# 开机后累计空闲\ncpu_idle1=`cat /proc/stat | grep  -w \"cpu\" | awk '{printf(\"%d\", $5);}'`\n\nsleep 0.5s\n\n# 0.5s 后\n# 开机后总时间\ncpu_local2=`cat /proc/stat | grep  -w \"cpu\" | awk '{printf(\"%d\", $2 + $3 + $4 + $5 + $6 + $7 + 8);}'`\n# 开机后累计空闲\ncpu_idle2=`cat /proc/stat | grep  -w \"cpu\" | awk '{printf(\"%d\", $5);}'`\n\n# 0.5s 内\n((cpu_local = $cpu_local2 - $cpu_local1))\n((cpu_idle = $cpu_idle2 - $cpu_idle1))\n\n# 计算cpu占用率\ncpu_occu=`echo \"$cpu_local $cpu_idle\" | awk '{printf(\"%.2f%%\", (1 - $2 / $1) * 100);}'`\n\n# CPU温度\ncpu_temp_info=`cat /sys/class/thermal/thermal_zone0/temp | awk '{\n        if ($1 >= 1000 && $1 < 50000) {\n            printf(\"%.2f normal\", $1 / 1000);\n        }\n        else if ($1 >= 50000 && $1 <= 70000) {\n            printf(\"%.2f note\", $1 / 1000);\n        }\n        else {\n            printf(\"%.2f warning\", $1 / 1000);\n        }\n    }'`\n\n\necho \"${time_and_load}${cpu_occu} ${cpu_temp_info}\"\n```\n","tags":["linux"]},{"title":"POJ-1979","url":"%2F2019%2F09%2F02%2FPOJ-1979%2F","content":"\n* 原题目：\n  Description\n  There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can't move on red tiles, he can move only on black tiles. \n  Write a program to count the number of black tiles which he can reach by repeating the moves described above.\n  Input\n  The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. \n  There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. \n  '.' - a black tile \n  '#' - a red tile \n  '@' - a man on a black tile(appears exactly once in a data set) \n  The end of the input is indicated by a line consisting of two zeros.\n  Output\n  > For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).\n\n  Sample Input\n  ```txt\n  6 9\n  ....#.\n  .....#\n  ......\n  ......\n  ......\n  ......\n  ......\n  #@...#\n  .#..#.\n  11 9\n  .#.........\n  .#.#######.\n  .#.#.....#.\n  .#.#.###.#.\n  .#.#..@#.#.\n  .#.#####.#.\n  .#.......#.\n  .#########.\n  ...........\n  11 6\n  ..#..#..#..\n  ..#..#..#..\n  ..#..#..###\n  ..#..#..#@.\n  ..#..#..#..\n  ..#..#..#..\n  7 7\n  ..#.#..\n  ..#.#..\n  ###.###\n  ...@...\n  ###.###\n  ..#.#..\n  ..#.#..\n  0 0\n  ```\n  Sample Output\n  ```txt\n  45\n  59\n  6\n  13\n  ```\n\n* 题目大意：\n  给出一个w列和h行的方阵，方阵中有'.','#'和'@'。其中'.'是可以移动的地方，'#'是红色的砖，是不可以移动的地\t\t方，'@'是最初人的地点就（图的入口），人可以上下左右移动，以0 0 为结束。\n  要求输出人可以移动的砖的个数。该题利用搜索。\n>注意：\n>先输入w，然后输入h，但是w是列数，h是行数。\n\n* 代码：\n```c++\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nvoid dfs(int x,int y);\nint w,h,tmp=0;\n\nchar ma[100][100];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nint main(){\n\twhile(cin>>h>>w){\n\t\tif(w==0&&h==0)  break;\n\t\tmemset(ma,'0',sizeof(ma));\n\t\tint ax,ay;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tcin>>ma[i][j];\n\t\t\t\tif(ma[i][j]=='@'){\n\t\t\t\t\tax=i;\n\t\t\t\t\tay=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp=0;\n\t\tdfs(ax,ay);\n\t\tcout<<tmp<<endl;\n\t}\n\treturn 0;\n}\n\nvoid dfs(int x,int y){\n\tma[x][y]='#';\n\ttmp++;\n\tfor(int i=0;i<4;i++){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(ma[nx][ny]=='.'&&nx>=0&&nx<w&&ny>=0&&ny<h&&ma[nx][ny]=='.'){\n\t\t\tdfs(nx,ny);\n\t\t}\n\t}\n}\nSelect Code\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nvoid dfs(int x,int y);\nint w,h,tmp=0;\n\nchar ma[100][100];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nint main(){\n\twhile(cin>>h>>w){\n\t\tif(w==0&&h==0)  break;\n\t\tmemset(ma,'0',sizeof(ma));\n\t\tint ax,ay;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tcin>>ma[i][j];\n\t\t\t\tif(ma[i][j]=='@'){\n\t\t\t\t\tax=i;\n\t\t\t\t\tay=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp=0;\n\t\tdfs(ax,ay);\n\t\tcout<<tmp<<endl;\n\t}\n\treturn 0;\n}\n\nvoid dfs(int x,int y){\n\tma[x][y]='#';\n\ttmp++;\n\tfor(int i=0;i<4;i++){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(ma[nx][ny]=='.'&&nx>=0&&nx<w&&ny>=0&&ny<h&&ma[nx][ny]=='.'){\n\t\t\tdfs(nx,ny);\n\t\t}\n\t}\n}\n```\n> POJ上不支持`bits/stdc++`的头文件，很尴尬。\n","tags":["POJ"]},{"title":"Codeforces-787a","url":"%2F2019%2F09%2F02%2FCodeforces-787a%2F","content":"\n> [题目传送](https://vjudge.net/problem/709847/origin)\n* 题目思路：\n  拓展欧几里德：\n\n  $$\n  a*x+b=c*y+d; <=> a*x+c*y=d-b;\n  $$\n\n\n\n\n代码：\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nll exgcd(ll a,ll b,ll &x,ll &y){\n    if(b==0){\n        x=1;\n        y=0;\n        return a;\n    }\n    ll d=exgcd(b,a%b,x,y);\n    ll tmp=x;\n    x=y;\n    y=tmp-a/b*y;\n    return d;\n}\n\nint main(){\n    ll a,b,C,D,x,y;\n    while(cin>>a>>b>>C>>D){\n        if(b<D){//若b<D,那么y<0，\n            //原方程式等价于y=(a*x+b-d)/c,\n            //下面的处理可保证x不小于0,但是不能保证y，\n            //所以需要保证(a*x+b-d)%c==0,即：保证：b>D；若不成立需交换；\n            swap(a,C);\n            swap(b,D);\n        }\n        ll d = exgcd(a,C,x,y);\n        ll c = D-b;\n        if(c%d)  cout<<\"-1\"<<endl;\n        else{\n            x=x*(c/d);\n            x=(x%(C/d)+(C/d))%(C/d);\n            cout<<b+a*x<<endl;\n        }\n    }\n    return 0;\n}\n```\n","tags":["codeforces"]},{"title":"HDU-1072","url":"%2F2019%2F09%2F02%2FHDU-1072%2F","content":"\n* 题目描述：\n  首先输入一个N；代表测试数据的个数;\n  然后每个测试数据的开头第一行输入一个n和一个命令（FIFO或FILO<就是先进先出或先进后出>）\n  然后是该测试数据的n行，每行包括“IN”加一个数字（代表入栈或入队）或者一个“OUT”（代表出队或出栈）\n  若已经是空的了遇到“OUT”命令时输出“None”；\n\n* 题目思路：\n  其实就是c++STL的队列和栈的简单应用；\n\n* 代码如下：\n\n  ```c++\n  \n  #include<bits/stdc++.h>\n  using namespace std;\n  int main(){\n    \tint n;\n    \tcin>>n;\n    \twhile(n--){\n        \tint com_num,typ_num;\n        \tcin>>com_num;\n        \tstring com;\n        \tcin>>com;\n        \tif(com==\"FIFO\"){\n            \tqueue<int> q;\n            \tfor(int i=0;i<com_num;i++){\n                \tcin>>com;\n                \tif(com==\"IN\"){\n                    \tcin>>typ_num;\n                    \tq.push(typ_num);\n                \t}\n                \tif(com==\"OUT\"){\n                    \tif(q.empty()){\n                        \tcout<<\"None\"<<endl;\n                    \t}\n                    \telse{\n                        \tcout<<q.front()<<endl;\n                        \tq.pop();\n                    \t}\n                \t}\n            \t}\n        \t}\n        \tif(com==\"FILO\"){\n            stack<int> st;\n            for(int i=0;i<com_num;i++){\n                cin>>com;\n                if(com==\"IN\"){\n                    cin>>typ_num;\n                    st.push(typ_num);\n                \t}\n                \tif(com==\"OUT\"){\n                    \tif(st.empty()){\n                        \tcout<<\"None\"<<endl;\n                    \t}\n                    \telse{\n                        \tcout<<st.top()<<endl;\n                        \tst.pop();\n                    \t}\n                \t}\n            \t}\n        \t}\n    \t}\n    \treturn 0;\n  }\n  ```\n","tags":["HDU"]},{"title":"BASH脚本实现素数线性筛","url":"%2F2019%2F09%2F02%2FBASH%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E7%B4%A0%E6%95%B0%E7%BA%BF%E6%80%A7%E7%AD%9B%2F","content":"\n\n\n* 知识准备\n\n  1. `for`循环\n\n     ```bash\n     for i in `seq 1 10`;\n     do\n     \techo ${i}\n     done\n     #执行结果\n     ---------\n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     --------\n     for ((i = 0; i < 10; i++));\n     do\n     \techo ${i}\n     done\n     # 执行结果与上面代码相同\n     # 双小括号中可以使用C语言一样的语法进行数学计算\n     # echo 是回显\n     # 美元符号用来取值：取变量值和数组值（用大括号括把变量或数组起来）、取命令的值（用小括号或<Tab>键上面的``符号括起来，如果用`符号扩起来就不用美元符号取值了）\n     ```\n\n  2. `if`分支语句\n\n     ```bash\n     num=0\n     if [[ ${num} -eq 0 ]];then\n     \techo \"YES\"\n     elif [[ ${num} -eq 1 ]];then\n     \techo \"NO\"\n     else\n     \techo \"???\"\n     fi\n     # 执行结果\n     # 数值判断用-eq(==)、-ne（!=）、-gt(>)、-ge(>=)、-lt(<)、-le(<=)\n     # 字符串判断用逻辑等和不等（==、!=）\n     ---------\n     YES\n     ---------\n     ```\n\n  3. expr 语句 该语句后面加上数学表达式，可以求数学表达式的值，但是`*`号前需要加上转义符号`\\`\n\n* 代码\n\n  ```bash\n  #!/bin/bash\n  \n  if [[ \"x${1}\" == x ]];then \n      MAX=10\n      else\n          MAX=${1}\n  fi\n  \n  num=0\n  \n  for((i = 0; i < ${MAX}; i++));\n  do\n  \n      prime[${i}]=0\n  \n  done\n  \n  for((i = 2; i < ${MAX}; i++));\n  do\n      \n      if [[ ${prime[$i]} -eq 0 ]];then\n          prime[$num]=$i\n          ((num++))\n      fi\n      for((j = 0; j < ${num}; j++));\n      do\n          pj=${prime[$j]}\n          if [[ `expr ${i}\\*$pj` -gt ${MAX} ]];then\n              break;\n          fi\n          prime[`expr ${i}\\*${pj}`]=1\n          if [[ `expr ${i}%${pj}` == 0 ]];then\n              break;\n          fi\n      done\n  \n  done\n  \n  for((i=0;i<$num;i++));\n  do\n  \n      echo ${prime[$i]}\n  \n  done\n  \n  ```\n\n  \n","tags":["algorithm"]},{"title":"磁盘信息获取","url":"%2F2019%2F09%2F02%2F%E7%A3%81%E7%9B%98%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%2F","content":"\n\n\n* 知识准备：\n\n  1. `df`:该工具用来获取文件系统挂载信息。\n\n  2. `awk`：该工具用来处理 `df`的数据。\n\n* 代码：\n\n     ```bash\n     #!/bin/bash\n     \n     df -m | grep \"^/dev/\" | awk -v ntime=$(date +\"%Y-%m-%d__%H:%M:%S\") '\n     BEGIN{\n         num = 0; \n         unum = 0; \n         hnum = 0;\n     } \n     {\n         num += $2; \n         unum += $3; \n         hnum += $4;\n         printf(\"%s 1 %s %sM %sM %s\\n\", ntime, $6, $2, $4, $5);\n     } \n     END{\n         printf(\"%s 0 disk %dM %dM %.2f%%\\n\", ntime, num, hnum, unum / num * 100);\n     }'\n     \n     ```\n\n     \n","tags":["linux"]},{"title":"进程信息获取","url":"%2F2019%2F09%2F02%2F%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%2F","content":"\n\n\n* 知识准备：\n\n  1. `ps` 该工具用来获取进程信息\n  2. `awk`该工具用来处理数据\n\n* 代码\n\n  ```bash\n  #!/bin/bash\n  \n  ps -aux | awk -v last_all=$(ps -aux | awk '\n  BEGIN{\n      num = 0;\n  } \n  { \n      if ($3 > 50 || $4 > 50) { \n          if (num > 0) {\n              printf(\"|\");\n          } \n          printf(\"%s\", $2); \n          num++;\n      } \n  }' && sleep 5) -v nowtime=$(date +\"%Y-%m-%d__%H:%M:%S\") '\n  { \n      if ($2 ~ last_all && ($3 > 50 || $4 > 50)) {\n          printf(\"%s %s %s %s %s %s\\n\", nowtime, $11, $2, $1, $3, $4);\n      } \n  }'\n  \n  ```\n\n  \n","tags":["linux"]},{"title":"内存信息获取","url":"%2F2019%2F09%2F02%2F%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%2F","content":"\n* `free`：该工具用来获取内存信息\n\n* `grep`：该工具用来筛选数据\n\n* `awk'`：该工具用来处理数据\n\n* 代码：\n\n  ```bash\n  #!/bin/bash\n  \n  free -m | grep \"^Mem\" | awk -v last_per=$1 -v nowdate=$(date +\"%Y-%m-%d_%H:%M:%S\") '\n  {\n      printf(\"%s %sM %sM %.1f%% %.1f%%\\n\", nowdate, $2, $7, $3 / $2 * 100, 0.3 * last_per + 0.7 * ($3 / $2 * 100));\n  }'\n  \n  ```\n\n  \n","tags":["linux"]},{"title":"系统信息获取","url":"%2F2019%2F09%2F02%2F%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%2F","content":"\n> 欢迎大家转载，转载请注明出处，谢谢！\n* 知识准备\n\n  1. `date`：获取当前时间\n  2. `/etc/issue`：系统版本信息\n  3. `/proc/loadavg`：负载信息\n  4. `df`：获取磁盘信息\n  5. `free`：内存信息\n  6. `/sys/class/thermal/thermal_zone0/temp`：cpu温度\n  7. `hostname`：主机名\n\n* 代码\n\n  ```bash\n  #!/bin/bash\n  \n  # 现在时间\n  nowdate=`date +\"%Y-%m-%d__%H:%M:%S\"`\n  # 系统版本\n  os_v=`cat /etc/issue | awk '{printf(\"%s_%s\", $1, $2);}'`\n  # 内核版本\n  ker_v=`uname -r`\n  # 运行时间和负载信息\n  run_and_load=`uptime -p | tr -s \" \" \"\\n\" | awk '{printf(\"_%s\", $1)}'``cat /proc/loadavg | awk '{ printf(\" %s %s %s\", $1, $2, $3); }'`\n  \n  # 负载信息\n  #load_info=`uptime | awk '{printf (\"%s %s %s\", $(NF - 2), $(NF - 1), $NF)}' | tr -s \",\" \" \"`\n  \n  disk_total=`df -m | grep \"^/dev/\" | awk 'BEGIN{t_num=0; u_num = 0}{if (NR > 1) {t_num = t_num + $2; u_num += $3 }}END{printf (\"%d:%d\", t_num, u_num)}'`\n  disk_used=`echo $disk_total | cut -d \":\" -f2`\n  disk_total=`echo $disk_total | cut -d \":\" -f1`\n  \n  #内存大小\n  mem_total=`free -m | sed -n \"2p\" | awk '{printf(\"%s\", $2)}'`\n  \n  # 磁盘占用百分比\n  per_disk_used=`echo \"$disk_total $disk_used\" | awk '{printf(\"%d\", $2/$1 * 100);}'`\n  # 内存占用百分比\n  per_memo=`free -m | sed -n \"2p\" | awk '{printf(\"%d\", $3/$2 * 100);}'`\n  # CPU温度\n  cpu_temp=`cat /sys/class/thermal/thermal_zone0/temp | awk '{printf(\"%d\", $1 / 1000);}'`\n  \n  # 磁盘报警级别\n  \n  if [[ $per_disk_used -ge 0 && $per_disk_used -le 80  ]];then\n      disk_warn=\"normal\"\n  \n  elif [[ $per_disk_used -ge 81 && $per_disk_used -le 90 ]];then\n      disk_warn=\"note\"\n  \n  else\n      disk_warn=\"warning\"\n  \n  fi\n  \n  # 内存报警级别\n  \n  if [[ $per_memo -ge 0 && $per_memo -le 70  ]];then\n      memo_warn=\"normal\"\n  \n  elif [[ $per_memo -ge 71 && $per_memo -le 80 ]];then\n      memo_warn=\"note\"\n  \n  else\n      memo_warn=\"warning\"\n  \n  fi\n  \n  # CPU温度报警级别\n  \n  if [[ $cpu_temp -ge 0 && $cpu_temp -le 50  ]];then\n      cpu_warn=\"normal\"\n  \n  elif [[ $cpu_temp -ge 51 && $cpu_temp -le 70 ]];then\n      cpu_warn=\"note\"\n  \n  else\n      cpu_warn=\"warning\"\n  \n  fi\n  \n  #主机名\n  hname=`hostname`\n  \n  echo \"$nowdate $hname $os_v $ker_v ${run_and_load} ${disk_total}M ${per_disk_used}% ${mem_total}M ${per_memo}% ${cpu_temp} ${disk_warn} ${memo_warn} ${cpu_warn}\"\n  \n  ```\n\n  \n","tags":["linux"]},{"title":"用户信息获取","url":"%2F2019%2F09%2F02%2F%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%2F","content":"\n> 欢迎大家转载，转载请注明出处，谢谢！\n* 知识准备\n\n  1. `w`：获取当前登录信息\n  2. `grep`：对数据进行筛选\n  3. `cut`：对字符串进行剪切\n  4. `sort`：排序\n  5. `uniq`：统计每个字符串个数\n  6. `head`：显示开头几行\n  7. `awk`：文本处理工具\n\n* 代码\n\n  ```bash\n  #!/bin/bash\n  \n  nowtime=`date +\"%Y-%m-%d_%H:%M:%S\"`\n  usernum=`awk -F \":\" 'BEGIN {num = 0;}{if ($3 >= 1000) {num++;}}END {printf(\"%d\\n\", num);}' /etc/passwd`\n  \n  active_user=`last | awk NF | grep  -v \"system\" | grep -v \"wtmp\" | cut -d \" \" -f1 | sort | uniq -c | sort -n -r | head -3 | awk 'BEGIN{num = 0}{if(num > 0) {printf(\",\")};printf(\"%s\", $2);num++}'`\n  \n  all_have_root=`cat /etc/group | grep \"^sudo\" | cut -d \":\" -f4`\n  \n  now_login=`w | awk 'BEGIN{num=0} {if (NR > 2){if(num > 0) {printf(\",\");} printf(\"%s_%s_%s\", $1, $3, $2);num++}}'`\n  \n  echo \"$nowtime $usernum [$active_user] [$all_have_root] [$now_login]\"\n  \n  ```\n\n  \n","tags":["linux"]},{"title":"进程、线程及共享内存学习笔记","url":"%2F2019%2F09%2F02%2F%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%8F%8A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F","content":"\n## 进程、线程及共享内存学习笔记\n> 系统环境：deepin Linux，语言环境：Linux C\n> 欢迎大家转载，转载请注明出处，谢谢！\n\n1. 理论基础：\n\n   * 进程：计算机上每个执行的活动，运行一个可执行程序是一个进程，打开一个软件是一个进程，打开一个终端是一个进程等等。\n   * 多进程：为了充分利用计算机资源产生了多进程的执行方式。通俗来讲就是在同一时间做多个事情，从而可以充分利用计算机资源还可以提高程序的执行效率。在创建一个新的子进程后，子进程会会获得计算机分配的资源，并拷贝父进程的数据。\n   * 子进程与父进程：我们编写的一段程序运行时就是一个进程，当我们在这段代码中调用特定函数新创建一个进程时，新创建的进程就是当前进程的子进程，而对于新创建的进程来说，当前进程就是它的父进程，子进程通过拷贝等手段继承父进程在创建子进程之前的数据、属性等。\n   * 多线程：上面说到进程是计算机上执行的每个活动。在实际编程中，一个进程中会有很多任务需要做。从而引发思考：一个进程中的多个任务是否也可以并发的执行？因为有些任务之间是没有联系的，也就是说有些任务完全可以同时进行而没有依赖问题。答案就是线程。与多进程相同的是，多线程也是为了让计算机资源得到充分利用并且程序的执行效率也会得到提高，与多进程不同的是，多线程并没有拷贝这种需求，它实际上是把一个进程分成多个片段。\n   * 重入性：尽管多线程系统开销少，但是也难免有缺陷，那就是重入性问题，使用多线程编程需要保证被多线程多次执行的函数的可重入性，所谓重入性就是函数被多个线程多次调用皆能正常执行。见附录2，有几个保证函数可重入性的条件。\n   * 线程安全：使用多线程编程除了需要保证函数的可重入性还需要保证线程安全，另外，可重入的函数一定是 线程安全的，但是反之不成立。\n   * 共享内存：根据字面意思就很好理解，通过把不同的进程中的逻辑内存映射到同一块物理内存中，进而允许两个进程共享同一块逻辑内存空间。它是进程间通信的一种方式。共享内存本身并没有提供同步机制。\n\n2. 相关函数：\n\n   * 多进程相关：\n\n     1. `fork()`：\n\n        * 原型：\n\n          ```c\n          #include <sys/types.h>\n          #include <unistd.h>\n          \n          pid_t fork(void);\n          ```\n\n        * 说明：\n\n          通过复制调用者来创建新进程。这个新的进程简称为子进程。调用该函数的进程称为父进程。\n\n          子进程和父进程运行在不同的内存空间中。在调用该函数的时候，两个进程内存空间都拥有相同的内容。其中一个进程执行的内存写入，文件映射和解除映射操作不会影响到另一个进程。该函数的返回值在父子进程中不同，在父进程中返回子进程PID，在子进程中返回0。\n\n     2. `wait()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <sys/types.h>\n          #include <sys/wait.h>\n          \n          pid_t wait(int *stat_loc);\n          ```\n\n        * 函数说明：\n\n          当调用这个函数的时候，当前进程会阻塞等待，该进程的某个子进程运行结束为止。\n          该结束的子进程的返回状态被存储在wait()函数的参数stat_loc变量中。\n\n     3. `system();`\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <stdlib.h>\n          #include <stdio.h>\n          int system(char *command);\n          ```\n\n        * 函数说明：\n\n          创建新的进程，执行制定命令。\n\n     4. exec函数族：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <unistd.h>\n          int execl(cONst char *path, const char *arg, ...);\n          int execlp(const char *file, const char *arg, ...);\n          int execle(const char *path, const char *arg, ..., char *const envp[]);\n          int execv(const char *path, char *const argv[]);\n          int execvp(const char *file, char *const argv[]);\n          int execve(const char *filename, char *const argv[], char *const envp[]);\n          ```\n\n        * 函数说明：\n\n          exec 函数族\n          execve 函数是该族的基础函数，其他函数是由该函数封装而来\n          exec 族被用启动新的指定路径下的程序来替换当前的程序。\n          函数名称后面的后缀不同参数不尽相同见下面附录1。\n\n     5. `exit()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <stdlib.h>\n          void exit(int status);\n          ```\n\n        * 函数说明：\n\n          终止进程并返回状态码。\n\n   * 多线程相关：\n\n     1. `pthread_create()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);\n          ```\n\n        * 函数说明：\n\n          * 作用：创建线程\n          * 该函数开始一个新的线程在调用该函数的进程中。新开始的线程通过调用`start_routine()`函数指针指向的函数来执行，arg参数是该函数指针指向的函数唯一的参数。\n          * 该线程可以通过一下方式中的一个终止：\n            * 调用`pthread_exit()`函数，并确定退出状态值，该值可用于该进程中的调用`phread_join()`的其他线程。\n            * 该线程执行的函数退出，这相当于调用`phread_exit()`并带有返回值。\n            * 被取消（见`pthread_cancel()`）\n            * 调用`exit()`函数，或者在主函数中执行`return`。这会导致该进程中所有线程终止。\n          * attr参数指向一个pthread_attr_t类型的结构体，这个参数被用来在线程创建之初确定该线程的属性。\n          * 如果调用该函数成功创建了一个线程，那么该线程的ID会存储在thread参数中。这个标志会在其他的函数中用到。\n\n     2. `pthread_join()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          int pthread_join(pthread_t thread, void **retval);\n          ```\n\n        * 函数说明：\n\n          * 该函数会等待由thread参数标志的线程终止。如果这个线程已经终止了，那么该函数立即返回。由thread参数标志的线程必须是可连接的。\n          * 如果retval参数不为空，那么该函数会拷贝目标线程的目标线程的退出状态（目标线程提供返回状态值给pthread_exit();）到该参数中。如果目标线程已经被取消了，那么该参数会存储PTHREAD_CANCELED。\n\n     3. `pthread_detach()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          int pthread_detach(pthread_t thread);\n          ```\n\n        * 函数说明：\n\n          该函数会把由thread参数指向的线程标记为分离。一个被标记分离的线程终止后，该线程的资源会被系统自动收回，不需要其他线程进程其他的操作。尝试标记已经分离的线程是不明操作，会导致未知错误。\n\n     4. `pthread_self()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          pthread_t pthread_self(void);\n          ```\n\n        * 函数说明：\n\n          * 该函数会返回调用者的PID，该值与调用`thread_create()`函数返回的thread值相同。\n\n     5. `pthread_equal`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          int pthread_equal(pthread_t t1, pthread_t t2);\n          ```\n\n        * 函数说明：\n\n          * 该函数比较两个线程的标记t1和t2是否指向同一个线程。\n          * 如果两个标记指向同一个线程会返回一个非零数，反之返回０。\n\n     6. `pthread_exit()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          void pthread_exit(void *retval);\n          ```\n\n        * 函数说明：\n\n        * 该函数会终止调用该函数的线程，并通过参数retval返回一个值，该值可用于同一进程中的其他线程调用`pthread_join()`。\n\n     7. 线程同步机制：\n\n        1. 互斥：\n\n           1. `pthread_mutex_init()`、`pthread_mutex_destroy()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);\n                int pthread_mutex_destroy(pthread_mutex_t *mutex);\n                ```\n\n              * 函数说明：\n\n                * `pthread_mutex_destroy()`:\n                  * 该函数销毁参数mutex引用的的互斥对象，实际上，该互斥对象会变成未初始化的状态。\n                  * 一个被销毁的互斥锁可以使用`pthread_mutex_init()`重新初始化。在互斥锁被销毁后引用该互斥锁会导致未定的引用的错误。\n                  * 销毁一个未上锁的初始化互斥对象是安全的。当尝试销毁一个通过其他线程使用的锁定的互斥锁或一个已经被禁用的互斥锁会导致未定义行为的错误。\n                * `pthread_mutex_init()`：\n                  * 该函数会初始化一个被参数mutex引用的互斥锁，该互斥锁的属性在参数attr中规定。\n\n           2. `pthread_mutex_lock()`、`pthread_mutex_trylock()`和`pthread_mutex_unlock`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_mutex_lock(pthread_mutex_t *mutex);\n                int pthread_mutex_trylock(pthread_mutex_t *mutex);\n                int pthread_mutex_unlock(pthread_mutex_t *mutex);\n                ```\n\n              * 函数说明：\n\n                * `pthread_mutex_lock()`\n                  * 该函数会把参数mutex引用的互斥锁上锁返回０或者EOWNERDEAD，如果该互斥锁已经被其他线程上锁了，那么该线程会阻塞，直到该互斥锁可用。\n                * `pthread_mutex_trylock()`\n                  * pthread_mutex_trylock()函数等效于pthread_mutex_lock()，除非mutex引用的互斥对象当前被锁定（由任何线程，包括当前线程），则调用应立即返回。\n                * `pthread_mutex_unlock()`\n                  * pthread_mutex_unlock()函数将释放互斥锁引用的互斥锁对象。 释放互斥锁的方式取决于互斥锁的类型属性。\n\n        2. 读写锁：\n\n           1. ``pthread_rwlock_init()`、`pthread_rwlock_destory()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                \n                int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);\n                int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr);\n                \n                pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;\n                ```\n\n              * 函数说明：\n\n                * ``pthread_rwlock_init()`函数会分配参数rwkock参数引用的读写所所需的所有资源，并将读写锁初始化为具有参数attr指定的属性，并置为解锁状态，如果attr为NULL，则应使用默认的读写锁属性; 效果与传递默认读写锁属性对象的地址相同。\n                * `pthread_rwlock_destory()`函数将销毁rwlock引用的读写锁对象，并释放锁使用的所有资源。\n\n                \n\n           2. `pthread_rwlock_rdlock()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\n                int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\n                ```\n\n              * 函数说明：\n\n                两个函数函数都会对由rwlock引用的读写锁解开读锁。但是对于`pthread_rwlock_rdlock()`函数如果写入权限没有上锁并且互斥锁上没有写入权限被阻塞，则调用线程获取读锁定。调用该函数的线程读权限会被上锁。try函数遇到这种情况会返回调用失败两个函数都是成功返回０。\n\n           3. `pthread_rwlock_wrlock()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\n                int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n                ```\n\n              * 函数说明：\n\n                两个函数同样都会为调用者加写权限锁，但是try函数回去尝试，也就是说如果任何线程当前持有rwlock（用于读或写），函数将调用失败。但是另一个函数遇到这种情况会阻塞。函数执行成功返回０。\n\n           4. `pthread_rwlock_unlock()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);\n                ```\n\n              * 函数说明：\n\n                该函数将释放由rwlock引用的读写锁对象上的锁。 如果读写锁定rwlock未被调用线程保持，则结果是不确定的。\n\n        3. 条件变量：\n\n           1. `thread_cond_init()`、`thread_cond_destory()`\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                \n                int pthread_cond_destroy(pthread_cond_t *cond);\n                int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);\n                \n                pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n                ```\n\n              * 函数说明：\n\n                `pthread_cond_destroy()`函数将销毁由cond指定的给定条件变量; 实际上，对象会处于未初始化状态。可以使用`pthread_cond_init()`重新初始化已销毁的条件变量对象; 在对象被销毁之后引用该对象的结果是未定义的。`pthread_cond_init()`函数应使用attr引用的属性初始化cond引用的条件变量。\n\n           2. `thread_cond_wait()`、`thread_cond_timedwait()`：\n\n              - 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                \n                int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);\n                int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);\n                ```\n\n              - 函数说明：\n\n                两个函数都会阻塞条件变量。 应用程序应确保在调用线程锁定互斥锁的情况下调用这些函数; 否则，会产生错误或未定义的行为（对于其他互斥锁）。\n\n           3. `thread_cond_signal()`、`thread_cond_broadcast()`：\n\n              - 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                \n                int pthread_cond_broadcast(pthread_cond_t *cond);\n                int pthread_cond_signal(pthread_cond_t *cond);\n                ```\n\n              - 函数说明：\n\n                `pthread_cond_broadcast()`函数将取消阻止当前在指定条件变量cond上阻塞的所有线程。`pthread_cond_signal()`函数应解除阻塞在指定条件变量cond上阻塞的至少一个线程（如果在cond上阻塞了任何线程）。\n\n   * 共享内存相关：\n\n     1. `shmget()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <sys/ipc.h>\n          #include <sys/shm.h>\n          int shmget(key_t key, size_t size, int shmflg);\n          ```\n\n        * 函数说明：\n\n          * 该函数返回与参数key相关联的共享内存片段的标识符（identifier）。\n\n           * 该函数可以用于获取先前创建的共享内存的idenfifier（当shmflg为0并且key值不是IPC_PRIVATE< 预定义宏，见附录3 >的时候）\n           * 该函数还可以用于创建一个新共享内存，新的共享内存大小为size参数向上取整到PAGE_SIZE(预定义宏，见附录3)。使用该函数创建新的共享内存需满足如下条件：\n           * 1. key没有与它相对应的共享内存(无论参数key的值是不是IPC_PRIVATE（预定义宏，见附录3）)\n           * 2. shmflg参数指定了IPC_CREAT（预定义宏，见附录3）\n           * 如果参数shmflg指定了IPC_CREAT和IPC_EXECL并且key 已经存在与其相关联的共享内存，那么shmget函数创建新的共享内存失败，并且erron会被设置为EEXIST。(这有点像O_CREAT | O_EXCL 组合对于open()函数带来的影响)\n           * shmflg参数的取值如下：\n           * IPC_CREAT IPC_EXCL、SHM_HUGETLB、SHM_HUGE2MB(SHM_HUGE_1GB)、SHM_NORESERVE（详情见附录3）\n\n     2. `shmat()`、`shmdt()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <sys/types.h>\n          #include <sys/shm.h>\n          void *shmat(int shmid, const void *shmaddr, int shmflg);\n          int shmdt(const void *shmaddr);\n          ```\n\n        * 函数说明：\n\n          * shmat();\n           * 该函数把通过shmid标志的共享内存段链接到调用该函数的进程所在的地址空间中。\n           * 这个被链接的地址空间由shmaddr参数的如下定义所规定：\n              1. 如果shmaddr参数为空，系统会选择一个合适的（未使用的）对齐页地址去链接共享内存。\n              2. 如果shmaddr参数不为空并且shmflg参数指定了SHMLBA(见附录3)，会链接到shmaddr参数向下取整到离SHMLBA倍数最近值的地址。\n              3. 除此之外，一定会链接到shmaddr 附近的对齐页地址。\n           * 除了SHM_RND以外，shmflg位掩码参数还可能使用到一下规定的标志：\n           * SHM_EXEC、SHM_RDONLY、SHM_REMAP（详细说明见附录3）\n           * shmdt();\n           * 与上面的函数相反，该函数通过shmid表示的共享内存段从调用该用书的进程所在的地址空间中断开。\n           * 这个被断开的共享内存段必须是目前链接的，并且shmaddr参数的值为调用shmat()函数的返回值。\n           * 如果shmdt()调用成功，系统会更新与共享内存相关联的shmid_ds结构体，该结构体成员如下：\n           * shm_ttime : 被设置为当前时间。\n           * shm_lpid : 被设置为被调用的进程的进程ID。\n           * shm_nattch ：这个值逐一递减，如果这个值减为0并且这个共享内存段被标记为删除，那么这个共享内存段就被删除了。\n\n     3. `shmctl()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <sys/ipc.h>\n          #include <sys/shm.h>\n          int shmctl(int shmid, int cmd, struct shmid_ds *buf);\n          ```\n\n           * 该函数执行由cmd参数指定的操作，cmd参数存储在由shmid参数存储的识别码指向的共享内存段。\n\n           * buf参数是一个shmid_ds结构体指针，shmid_ds结构体在头文件<sys/shm.h>中定义，如下所示：\n\n             ```c\n             struct shmid_ds {\n                 struct ipc_perm shm_perm;\t/* 所有权和权限 */\n                 size_t shm_segsz;\t\t\t/* 段大小（单位：字节） */\n                 time_t shm_atime;\t\t\t/* 最后的链接时间 */\n                 time_t shm_dtime;\t\t\t/* 最后的断开链接时间 */\n                 time_t shm_ctime;\t\t\t/* 最后的更改时间 */\n                 pid_t  shm_cpid;\t\t\t/* 创建者的PID */\n                 pid_t  shm_lpid;\t\t\t/* 最后的shmat()函数或shmdt()函数的pid */\n                 ...\n             };\n             ipc_perm结构体的定义如下（其中udi、gid和mode可设置为IPC_SET）：\n             struct ipc_perm {\n             \tkey_t\t\t\t__key;\t\t/* 提供给shmget()函数的键值 */\n             \tuid_t\t\t\tuid;\t\t/* 有效的拥有者的UID */\n             \tgid_t\t\t\tgid;\t\t/* 有效的拥有者的GID */\n             \tuid_t\t\t\tcuid;\t\t/* 有效的创建者UID */\n             \tgid_t \t\t\tcgid;\t\t/* 有效的创建者GID */\n             \tunsigned short\tmode;\t\t/* 权限 + SHM_DEST 和 SHM_LOCKED 标记 */\n             \tunsigned short\t__seq;\t\t/* 序列号 */\n             };\n             ```\n           * cmd参数的有效值如下：\n\n             IPC_STAT、IPC_SET IPC_RMID、IPC_INFO、SHM_INFO、SHM_STAT、SHM_LOCK、SHM_UNLOCK 。\n\n \n\n---\n* 附录1（摘自网络）：\n\n  | 后缀 | 参数                                                         |\n  | ---- | ------------------------------------------------------------ |\n  | l    | 接收以逗号为分隔的参数列表，以NULL为结束符                   |\n  | v    | 接收以NULL为结束的字符串数组                                 |\n  | p    | 接收以NULL为结束的字符串数组指针，并可以利用DOS的PATH变量查找子程序文件 |\n  | e    | 传递环境变量。                                               |\n\n* 附录2（摘自网络）：\n\n  1. 不在函数内部使用静态或全局数据。\n  2. 不返回静态或全局数据，所有数据都由函数的调用者提供。\n  3. 使用本地数据，或通过拷贝全局数据到本地来保护全局数据。\n  4. 不调用不可重入性函数。\n\n* 附录三（翻译自man手册）：\n\n  | 宏名称                  | 意义                                                         |\n  | ----------------------- | ------------------------------------------------------------ |\n  | IPC_CREAT               | 创建一个新的段，如果这个标志没有被使用，shmget()函数将会寻找与这个段相对应的key参数值，并且检查使用者是否有读取这个段的权限。 |\n  | IPC_EXCL                | 该标志与IPC_BREAT一起被用作确认本次创建共享内存的调用成功与否。 |\n  | IPC_PRIVATE             | 它不是一个标志字段，而是一个key_t类型的值，如果函数调用的时候key参数中存储这个特殊的值，系统调用会忽略除了shmflg中最不重要的9位意外的所有并且创建一个新的共享内存。 |\n  | IPC_STAT                | 从内核中拷贝shmid中由buf指向的shmid_ds结构相关的数据结构信息。对于共享内存段调用者必须拥有可读权限。 |\n  | IPC_SET                 | 往参数buf指针指向的shmid_ds结构体的某些成员写入与该共享内存段相关联的内核数据结构，并且更新该结构体中的shm_ctime成员。以下成员可能会被改变：shm_perm.uid、shm_perm.gid和（最不重要的九位）shm_perm.mode。调用进程的有效UID必须与拥有者（shm_perm.uid）或共享内存的创建者（shm_per.cuid）相匹配，或者与一定是拥有特权的调用者相匹配。 |\n  | IPC_RMID                | 标记被销毁的共享内存段，实际上，这个共享内存段实在进程销毁的时候被销毁。（当shmid_ds相关构成员shm_nattch为空的时候）。调用者必须是共享内存的拥有者或者创建者，或者拥有特权。buf参数被忽略。 |\n  | SHM_NORESREVE           | （从linux内核2.6.15以后）这个标志与mmap()函数的MAP_NORESERVE 标志具有同样的目的。不保留交换空间对于共享内存段，当交换空间被保留了，他会保证共享内存是可用的。当交换空间没有被保留，并且物理内存不可用，那么可能会在写入时获取SIGSEGV。也可以查阅`/proc/sys/vm/overcommit`文件。 |\n  | SHM_REMAP               | （LInux特有）这个标志指定了在共享内存段中从shmaddr参数开始到段最后的范围内的段映射应该被替换成现有的映射。（一般情况下，一个EINVAL错误可能是由于一个映射在地址范围内已经存在）在这个案例中，shmaddr参数必须不为空。 |\n  | SHM_RDONLY              | 以只读的方式链接共享内存段。进程对共享内存段必须有读取权限。如果标志没有被指定，那么共享内存段会被以可读可写方式链接，并且进程对于该共享内存段必须拥有可读和可写权限。但这不意味着对共享内存段有只写权限。 |\n  | SHM_EXEC                | （Linux特有，从linux2.6.9以后）允许执行共享内存段中的内容。调用者对于共享内存段必须拥有可执行权限。 |\n  | SHM_HUGETLB             | （从linux内核2.6版以后）为共享内存段分配巨大空间，详情见linux内核源码文件中`Documentation/vm/hugetlbpage.txt`获取更多信息。 |\n  | SHM_HUGE2MB,SHM_HUGE1GB | （从linux内核3.8之后）与SHM_HUGETLB一起被用作选择替代hugetlb大页面的大小（分别是2MB和1GB），并且支持超过hugetlb大页面的大小。 |\n\n* 参考资料：\n\n  > 参考网站：[多进程编程总结](https://blog.csdn.net/hello_bravo_/article/details/52497401)、[C语言多进程编程](https://www.xuebuyuan.com/943688.html)、[多线程和多进程的区别（小结）](https://www.cnblogs.com/alanfeng/p/5055141.html)、[百度百科：程序并发执行](https://baike.baidu.com/item/程序并发执行/7387706)、[linux下c语言编程exec函数使用](https://blog.csdn.net/aile770339804/article/details/7443921)\n  >\n  >  参考书籍：[C语言核心技术](http://product.dangdang.com/25154067.html) 、man手册\n","tags":["note"]},{"title":"Linux常见配置文件","url":"%2F2019%2F09%2F02%2FLinux%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F","content":"\n> 转载自[CoderZhuang](https://www.cnblogs.com/zxj015/p/4457868.html)，对[CoderZhuang](https://www.cnblogs.com/zxj015/p/4457868.html)先生的博客进行补充和整理。\n\n1. `/etc` 配置文件\n    * `/etc/passwd` 用户数据库，其中的域给出了用户名、真实姓名、家目录、加密口令和用户的其他信息 \n      * `/etc/group` 类似`/etc/passwd` ，但说明的不是用户而是组。\n      * `/etc/inittab` init 的配置文件\n      * `/etc/issue` 在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。内容由系统管理员确定。\n      * `/etc/motd` 成功登录后自动输出，内容由系统管理员确定，经常用于通告信息，如计划关时间的警告。\n      * `/etc/mtab` 当前安装的文件系统列表。由`scripts` 初始化，并由`mount` 命令自动更新。需要一个当前\n        安装的文件系统的列表时使用，例如df 命令，当`df –a` 时，查看到的信息应和其一致。\n      * `/etc/shadow` 在安装了影子口令软件的系统上的影子口令文件。影子口令文件将`/etc/passwd` 文件中的\n        加密口令移动到`/etc/shadow` 中，而后者只对**root** 可读。这使破译口令更困难。\n    * `/etc/login.defs` login 命令的配置文件\n      * `/etc/profile` , `/etc/csh.login` , `/etc/csh.cshrc` 登录或启动（cshell）时读取的文件（shell不同，文件名称不同，具体查看man手册）。\n      * `/etc/printcap` 类似`/etc/termcap` ，但针对打印机。语法不同。\n      * `/etc/securetty` 确认安全终端，即哪个终端允许**root**登录。一般只列出虚拟控制台，这样就不可能\n        (至少很困难)通过modem 或网络闯入系统并得到超级用户特权。\n      * `/etc/shells` 列出可信任的shell。chsh命令允许用户在本文件指定范围内改变登录shell。提供一\n        台机器FTP 服务的服务进程ftpd 检查用户shell 是否列在 `/etc/shells` \n        文件中，如果不是将不允许该用户登录。\n      * `/etc/termcap`终端性能数据库。说明不同的终端用什么\"转义序列\"控制。写程序时不直接输出转义序列(这样\n        只能工作于特定品牌的终端)，而是从`/etc/termcap`中查找要做的工作的正确序列。这样，多数的\n        程序可以在多数终端上运行。\n      * `/etc/inputrc` 输入设备配置文件\n      * `/etc/default/useradd` 添加用户的默认信息的文件\n      * `/etc/login.defs` 是用户密码信息的默认属性\n      * `/etc/skel` 用户信息的骨架\n      * `/sbin/nologin` 不能登陆的用户\n      * `/var/log/message` 系统的日志文件\n      * `/etc/profile`全局配置文件可以在添加一行`PATH=$PATH：/usr/local/mysql/bin`即可以软件的命令可以使用\n      * `/root/bashrc` 命令的别名\n      * `/etc/yum.repos.d` 配置本地yun源(红帽系)\n      * `/etc/apt/sources.list.d` 配置本地apt源(debian系)\n      * `/etc/httpd/conf/httpd.conf` 配置http服务的配置文件\n      * `/etc/fstab` 系统启动时自动加载的设备，（用于配置自动挂载设备）\n      * `/etc/selinux` 安全Linux设定\n      * `/etc/sysconfig/network` 可以更改`hostname`（主机名）以及网卡工作状态\n      * `/etc/hosts` 更改主机名和IP 地址的对应关系，请注意其格式为`hostname.domain` `hostname` `localhost`\n        `localhost.domian`，当修改主机名后必须修改该文件\n      * `/etc/resolv.conf` 可配置DNS 地址，即第一DNS，第二DNS 以及DNS 的默认搜索路径\n      * `/etc/sysconfig/networking/profiles/default` 内含数个文件，可配置hosts、网卡、DNS 地址及\n        DNS 搜索路径等\n      * `/etc/sysconfig/network-scripts/ifcfg-eth0` 配置网卡eth0(具体名称请使用`ifconfig`查看)\n      * `/etc/rc.d/init.d/network restart` 重启网络\n      * `/etc/rc.d/init.d` 用于放置几乎所有服务的启动脚本\n      * `/etc/sysctl.conf` 内核参数配置文件\n         `/etc/sysconfig/i18n`\t设置系统语言和字符类型\n      * `/etc/crontab` 系统定义的任务计划\n      * `/etc/anacrontab` 实现检查过期和未完成的crontab的任务的配置文件\n      * `/etc/rc.d/init.d/functions` 定义功能的配置文件\n      * `/etc/rc.d/rc.sysinit` 系统启动设置配置文件\n      * `/etc/sysconfig/system-config-firewall`配置防火墙的信任端口，以及防火墙的工作状态。图形化配置防火\n        墙的存档文件，具体讲只保存图形界面的otherport里面设置的项目，如果主配置\n        文件存在相应的配置条目，那么它里面的配置条目存在与否并不重要。\n      * `/etc/sysconfig/iptables` 防火墙主配置文件\n      * `/etc/sysconfig/system-config-securitylevel` 系统安全等级文件，在防火墙配置中不会涉及\n      * `/etc/xinetd.conf xinetd` 的主配置文件\n      * `/etc/hosts.allow` TCP的一个许可表\n      * `/etc/host.deny` TCP的一个拒绝表\n      * `/etc/squid/squid.conf` 代理服务器（SQUID）配置文件\n      * `/etc/sysconfig/vncservers` VNC服务配置文件\n      * `/etc/vsftpd/ftpusers` 用于保存不允许进行FTP 登录的本地用户账号（黑名单）\n      * `/etc/vsftpd/user_list` 更灵活的用户访问控制，但需要在主配置文件中进行声明\n      * `/etc/inetd.conf` swat 配置\n      * `/etc/dhcpd.conf` DHCP 的配置文件\n      * `/etc/rc.d/init.d/dhcpd stop` 停止DHCP\n      * `/etc/access` 可以对sendmail 的邮件流进行控制\n      * `/etc/udev/rules.d` 系统初始化时将硬件探测信息输出成设备配置文件，是一个程序。\n        让用户定义udev的规则，从而实现在创建设备文件使用不同的设备文件名\n      * 注：`/etc/passwd` 存放用户的账号，存放形式 ：\n        `root:x:0:0:root:/root:/bin/bash` : \n        `用户名：密码位：UID：GID：CECOS(注释)：diectory（家目录）:shell`\n      * 注：`/etc/shadow` 存放用户的密码\n        `slaceware:$1$12345678$0ME5N6oDyoEAwUp7b5UDM/:15355:0:99999:7:::`\n        用户名：加密后的密码：时间1：时间2：时间3：时间4：时间5：时间6：预留段`\t\n        加密后的密码：以$分开，第一个$后是1，说明加密算法是md5，第二个$后是加的sail，第三个$后是加的密码。\n        时间1：从1970年1月1日起到最近的修改的天数\n        时间2：密码的最短使用期限\n        时间3：密码最长使用期限\n        时间4：在密码过期之前多少天开始警告\n        时间5：在密码过期多少天用户禁用\n        时间6：自1970年1月1日起多长时间用户被禁用\n      * 注：`/etc/group` 存放组的账号，存放形式： \n        `slackware:x:5000` : `Name：passwd位置：GID：附加组的用户列表`。\n      * 注：\n      * 交互式登陆的用户：\n        `/etc/profile -->/etc/profile.d/* -->~/.bash_profile -->~/.bashrc -->/etc/bashrc`\n    * 非交互式登录：\n      /.bashrc -->/etc/bashrc -->.etc/profile.d/*`\t\n2. `/proc` 配置文件\n    * `/proc/dma` 显示当前使用的DMA 通道。\n      * `/proc/filesystems` 核心配置的文件系统。\n      * `/proc/interrupts` 显示使用的中断，and how many of each there have been.\n      * `/proc/ioports` 当前使用的I/O 端口。\n      * `/proc/kcore` 系统物理内存映象。与物理内存大小完全一样，但不实际占用这么多内存；\n        it is generated on the fly as programs access it. \n        (记住：除非你把它拷贝到什么地方，`/proc` 下没有任何东西占用任何磁盘空间。）\n      * `/proc/kmsg` 核心输出的消息。也被送到syslog\n      * `/proc/ksyms` 核心符号表\n      * `/proc/loadavg` 系统\"平均负载\"；3 个指示器指出系统当前的工作量。\n      * `/proc/meminfo` 存储器使用信息，包括物理内存和swap。\n      * `/proc/modules` 当前加载了哪些核心模块。\n      * `/proc/net` 网络协议状态信息。\n      * `/proc/self` 到查看`/proc` 的程序的进程目录的符号连接。当2 个进程查看`/proc` \n        时，是不同的连接。这主要便于程序得到它自己的进程目录。 \n       * `/proc/stat` 系统的不同状态，such as the number of page faults since the system was booted.\n      * `/proc/uptime` 系统启动的时间长度。 \n      * `/proc/cpuinfo` 处理器信息，如类型、制造商、型号和性能。\n      * `/proc/devices` 当前运行的核心配置的设备驱动的列表。\n      * `/proc/version` 核心版本。\n      * `/proc/mdstat` RAID设备的信息\n      * `/proc/cmdline` ro root=/dev/vol0/root rhgb quiet grub信息\n      * `/proc/cpuinfo` 显示CPU的相关信息\n      * `/proc/cpuset` cpu集合 用于显示当前进程可以应用到哪些cpu上\n      * `/proc/filesystem`当前系统支持的文件系统种类\n      * `/etc/245/vm` 系统进程ID号为245的进程的虚拟内存信息\n      * `/etc/245/kernel` 系统进程ID号为245的进程的内核信息\n      * `/proc/mounts` 挂载的所有文件系统\n      * `/proc/swaps` 交换分区信息 \n      * `/proc/uptime` 启动系统运行时长\n      * `/proc/sys` (具有写权限)定义内核参数的值来定义内核的功能\n         `/proc/sys/kernel/hostname` 主机名的设定\t\n3. `/usr` 配置文件\n    * `/usr/bin` 众多的应用程序\n      * `/usr/doc` linux 文档\n      * `/usr/include` linux 下C 开发和编译应用程序所需要的头文件\n      * `/usr/include/g++` C++编译器的头文\n      * `/usr/lib` 常用的动态链接库和软件包的配置文件\n      * `/usr/src` 系统软件的源代码\n      * `/usr/src/linux` linux 内核的源代码\n      * `/usr/local/bin` 本地增加的命令\n      * `/usr/local/lib` 本地增加的库\n      * `/usr/sbin` 为系统管理员保留的程序\n      * `/usr/share/fonts` 字体文件\n      * `/usr/share/doc` 各种文档文件\n      * `/usr/share/man` 系统手册页\n      * `/usr/local/apache/man` 定义man目录文集\n        其它目录配置文件\t\n      * `/dev/null` 没有用的文件所放的位置，相当于回收站，吞噬设备\n      * `/dev/zero` 初始化磁盘（吐零） \n      * `/dev/random` 随机数生成器，熵池\n      * `/dev/urandom` 伪随机数生成器，熵池。（当熵池耗尽时，用软件生成随机数）\n      * `/var/spool/mail/root` 定义mail设置发送用户为root\n      * `/bin/bash` 系统内置脚本\n      * `/home/USERNAME` 用户配额文件\n      * `/var/spool/cron/USERNAME` 用户定义的任务计划\n4. 目录结构：\n    * `/boot` 用于自举加载程序（LILO 或GRUB）的文件。当计算机启动时（如果有多个操作系统，\n      有可能允许你选择启动哪一个操作系统），这些文件首先被装载。这个目录也会包含LINUX 核（压缩文件\n      vmlinuz），但LINUX 核也可以存在别处，只要配置LILO 并且LILO 知道LINUX 核在哪儿。\n      * `/bin` 系统启动时需要的引导程序(二进制执行文件)，这些文件可以被普通用户使用\n      * `/dev` 代表硬件组件的设备文件目录。LINUX 下设备被当成文件，这样一来硬件被抽象化，便\n        于读写、网络共享以及需要临时装载到文件系统中。正常情况下，设备会有一个独立的子目录。这些设备\n        的内容会出现在独立的子目录下。LINUX 没有所谓的驱动符。\n      * `/etc` 存放各种配置文件\n      * `/etc/rc.d` 启动的配置文件和脚本\n      * `/home` 用户主目录，包含参数设置文件、个性化文件、文档、数据、EMAIL、缓存数据等\n      * `/lib` 标准程序设计库，又叫动态链接共享库，作用类似windows 里的.dll 文件\n      * `/sbin` 为系统管理员保留的用于系统启动时的引导程序(二进制执行文件)，这些文件不打算被\n        普通用户使用(普通用户仍然可以使用它们，但要指定目录)\n      * `/tmp` 公用的临时文件存储点，该目录会被自动清理干净\n      * `/root` 系统管理员的主目录\n      * `/mnt` 系统提供这个目录是让用户临时挂载其他的文件系统。\n      * `/lost+found`这个目录平时是空的，系统非正常关机而留下“无家可归”的文件。\n      * `/proc` 虚拟的目录，是系统内存的映射，可直接访问这个目录来获取系统信息。目录整个包含\n        虚幻的文件。它们实际上并不存在磁盘上，也不占用任何空间。（用`ls –l` 可以显示它们的大小）当查看\n        这些文件时，实际上是在访问存在内存中的信息，这些信息用于访问系统\n      * `/proc/1` 关于进程1 的信息目录。每个进程在`/proc` 下有一个名为其进程号的目录。\n      * `/var` 某些大文件的溢出区，比方说各种服务的日志文件，包含在正常操作中被改变的文件：\n        假脱机文件、记录文件、加锁文件、临时文件和页格式化文件等\n      * `/var/spool mail, news`, 打印队列和其他队列工作的目录。每个不同的spool 在`/var/spool` 下有自己的\n        子目录，例如，用户的邮箱在`/var/spool/mail` 中。\n      * `/opt` 可选的应用程序，譬如，REDHAT 5.2 下的KDE （REDHAT 6.0 下，KDE 放在其它的\n        XWINDOWS 应用程序中，主执行程序在`/usr/bin` 目录下）\n      * `/usr` 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。\n      * `/home /var /usr/local` 经常是单独分区，因为经常会操作，容易产生碎片\n      * `/srv` 该目录存放一些服务启动之后需要提取的数据\n","tags":["转载"]},{"title":"deepin系统使用笔记","url":"%2F2019%2F09%2F02%2Fdeepin%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F","content":"\n> 1. 如果你是小白用户并且没有人在旁边指导，那么建议不要自行更改本文给出的命令。\n> 2. 图形界面相关的东西自行探索。\n\n\n\n##  deepin系统安装后推荐配置\n`sudo apt-get install -y git wget curl openssh-server manpages-* graphviz`\n\n\n##  zsh配置（linux高级用户推荐）\n  1. 安装：`sudo apt-get install zsh`\n    \n  2. 设置为默认SHELL(不要加sudo)：`chsh -s /bin/zsh`\n  3. 安装oh-my-zsh\n```bash\nsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n  4. 手动配置oh-my-zsh\n       1. 安装自动跳转插件：\n           1.` sudo apt-get install autojump`\n           \t2. 打开~/.zshrc，在文件末尾，另起一行添加：`source   /usr/share/autojump/autojump.sh`\n           2. 安装zsh-syntax-highlighting语法高亮插件：\n             1. `cd ~/ && git clone https://github.com/zsh-users/zsh-syntax-highlighting.git`\n             2. `cd ~/ &&echo \"source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\" >> ${ZDOTDIR:-$HOME}/.zshrc`\n           3. 安装zsh-autosuggestions语法历史记录插件:\n             1. `git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions`\n             2. 打开~/.zshrc，在文件末尾，另起一行添加：`source $ZSH_CUSTOM/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh`\n        2. 打开~/.zshrc:\n            1. 找到：plugins=(git)这个位置，在括号里面添加，每个单词单独一行，如果已经有了，就不用添加了：\n                ```shell\n                \tgit\n                \textract\n                \tz\n                \tweb-search\n                \tzsh-autosuggestions\n                \tcp\n                \tcommand-not-found\n                ```\n\n                2. 在文件末尾，另起一行添加：\n                ```shell\n                export EDITOR=vim\n                setopt HIST_IGNORE_DUPS\n                setopt no_nomatch\n                ```\n  5. 自动配置oh-my-zsh\n\n```shell\n\n         #!/bin/bash\n         \n         \n         if [[ ${?} -eq 1 ]];\n         then\n             exit 1;\n         fi\n         \n         \n         sudo apt-get install autojump\n         git clone https://github.com/zsh-users/zsh-syntax-highlighting.git\n         git clone git://github.com/zsh-users/zsh-autosuggestions  ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions\n         \n         \n         echo '\n         \n         \n         \n         #########################################\n         \n         alias ls=\"ls --color=auto\"\n         alias dir=\"dir --color=auto\"\n         alias la=\"ls -a --color=auto\"\n         alias ll=\"ls -al --color=auto\"\n         alias vdir=\"vdir --color=auto\"\n         \n         alias grep=\"grep --color=auto\"\n         alias egrep=\"egrep --color=auto\"\n         alias fgrep=\"fgrep --color=auto\"\n         \n         alias cls=\"clear\"\n         \n         export EDITOR=vim\n         setopt no_nomatch\n         setopt HIST_IGNORE_DUPS\n         \n         source /usr/share/autojump/autojump.sh\n         source ~/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\n         \n         ' >>  ~/.zshrc\n         \n         \n         sed -i 's/^plugins=(git)/plugin=\\(extract \\n  z \\n web-search \\n  zsh-autosuggestions \\n cp \\n command-no-found\\)/g' ~/.zshrc\n         \n         \n         \n```\n\n6. 通过手动或自动配置，zsh就彻底配置完成。\n\n   ​     \n## 常见文件\n- 搜狗输入法皮肤所在路径：~/.config/sogou-qimpanel/skin\n- desktop软件图标路径集合：\n  - ~/.local/share/applications : AppImage应用生成的图标。\n  - /usr/share/applications/ :  常用应用图标所在。\n  - /etc/xdg/autostart/ : 系统级别自启动应用图标。\n  - /opt/deepinwine/apps/ : deepin-wine应用图标。\n  - /var/lib/flatpak/app/ : flatpak应用图标。\n    以上所给路径仅为常见路径，并非所有。\n- \n- \n## 常用命令（linux入门用户推荐）：\n  - ls : 列出当前路径文件。\n\n  - pwd : 查看当前所在路径（绝对路径）。\n  - cd : 路径跳转。\n\n  - mv : 文件及目录移动以及更改名字。\n  - cp : 拷贝。\n  - mkdir : 创建目录。\n  - touch : 创建空白文件。\n- 桌面设置壁纸的内置壁纸保存位置：\n  如图：\n\n  这些壁纸保存在：/usr/share/wallpapers/deepin下。\n- vim 配置文件：~/.vimrc（用户级别配置文件，只针文件所在用户生效，其他用户不生效）\n- bash配置文件：~/.bashrc（用户级别配置文件，只针文件所在用户生效，其他用户不生效）\n\n\n\n##  vim 入门操作\n  *  vim配置:\n     1. vim的配置我们选择ma6174的配置，\n         终端命令：wget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -x\n         配置完成后会重新回到终端命令行（建议在网络较好的环境下配置）\n     2. 配置完成后打开python文件会发现报错，解决方案：\n        点击这里下载python.zip文件，将压缩包下载到本地解压，得到一个名称为python的文件夹，将其复制（覆盖并替换）到～/.vim/ftplugin/路径下即可。\n  *  三种模式：\n     - \t插入模式：\n    1. 普通模式下按i直接进入插入模式。\n    2. 普通模式下按I光标前一个位置进入插入模式。\n    3. 普通模式下按O光标的下一行进入插入模式。\n    4. 普通模式下按o光标的上一行进入插入模式。\n  - 普通模式：\n    - 在任何模式下按ESC进入普通模式。\n    - 在普通模式下：\n      - dd : 剪切当前行（可以当删除用）（只在普通模式和选择模式生效）。\n      - yy：复制当前行（只在普通模式和选择模式生效）。\n      - p ： 粘贴（只在普通模式生效）。\n  - 选择模式：\n    - c : 进入块选择模式。\n    - C:  进入行选择模式。\n    - CTRL + c : 进入列选择模式。\n","tags":["note"]},{"title":"HDU-1222","url":"%2F2019%2F09%2F02%2FHDU-1222%2F","content":"\n> [题目传送](http://acm.hdu.edu.cn/status.php?first=&pid=&user=sunowsir&lang=0&status=0)\n\n* 题目描述:\n\n  There is a hill with n holes around. The holes are signed from 0 to n-1.\n\n  A rabbit must hide in one of the holes. A wolf searches the rabbit in anticlockwise order. The first hole he get into is the one signed with 0. Then he will get into the hole every m holes. For example, m=2 and n=6, the wolf will get into the holes which are signed 0,2,4,0. If the rabbit hides in the hole which signed 1,3 or 5, she will survive. So we call these holes the safe holes.\n\n  InputThe input starts with a positive integer P which indicates the number of test cases. Then on the following P lines,each line consists 2 positive integer m and n(0<m,n<2147483648).\n  OutputFor each input m n, if safe holes exist, you should output \"YES\", else output \"NO\" in a single line.\n\nSample Input\n\t\n\t2\n\t1 2\n\t2 2\nSample Output\n\n\tNO\n\tYES\n\n* 题目思路：\n  只需要判断m和n的最大公约数是否等于1即可，不等于一则永远抓不到；\n\n* 代码：\n```c\n/*************************************************************************\n    > File Name: HDU-1222.cpp\n    > Author: sunowsir\n ************************************************************************/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a,int b){\n    return b==0? a:gcd(b , a%b);\n}\n\nint main(){\n    int m,n,N;\n    cin>>N;\n    while(N--){\n        cin>>m>>n;\n        if(gcd(m,n)!=1)  cout<<\"YES\"<<endl;\n        else  cout<<\"NO\"<<endl;\n    }\n    return 0;\n}\n```\n","tags":["HDU"]},{"title":"服务器健康监控","url":"%2F2019%2F09%2F02%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%81%A5%E5%BA%B7%E7%9B%91%E6%8E%A7%2F","content":"\n> [项目地址](https://github.com/sunowsir/SHMS)\n\n* 简介：\n  使用C语言和bash脚本实现的服务器健康监控系统。服务器端通过执行bash脚本获取健康信息，利用socket即时发送到监控端主机。\n\n* 监测数据类型：\n  > 采用bash脚本获取相关信息\n  * cpu\n  * 内存\n  * 硬盘\n  * 恶意进程\n  * 系统信息\n  * 登录用户信息\n\n* 技术说明：\n\n  * C语言socket编程。\n  * C语言多线程与多进程编程。\n  * 数据结构实现（链表）。\n  * linux的bash脚本编程。\n  * linux systemd 的使用。\n\n* 架构：\n\n  * 监控端（Master）\n\n    * 线程一：\n\n      循环监听：使用socket监听，将收到的连接的套接字存储到长度最短的链表里。\n\n    * 线程二：\n\n      数据接收：通过读取配置文件创建若干数据发送的线程，每个线程分配一个链表。\n\n      从链表读取一个套接字，接收六组数据，然后断开连接，将该套接字从链表中删除。\n\n      保证数据的可靠性：六组数据，每组数据接收前，发送约定好的数据类型标志码，通知服务器本组应该发送的数据的类型。然后接收数据，存储到本地。\n\n    * 线程三：\n\n      紧急连接：单独开启通道，接受服务器连接，发送紧急报警信息。\n\n      该数据单独存放在发送者目录下。\n\n  * 服务器端（Server）:\n\n    * 线程一：\n\n      数据监测：运行监测脚本，将监测数据存储到文件。\n\n    * 线程二：\n\n      数据发送：根据监控端发来的数据类型读取相应监测数据的日志文件，发送给监控端。\n\n      通过分析监测数据判断是否有警报信息，发送警报信息。\n\n      数据获取与警报信息的即时性：无法做到数据发送的实时性，但是可以保证监测数据的实时性。每次只发送每种类型数据日志文件中的最上面一行，一共六组数据发送完成关闭连接。该方式牺牲一定的资源与数据传输的实时性，来保证线程一的一定程度的实时性。若非如此，只能采用文件锁来避免文件指针的冲突，这将会导致线程一阻塞，从而导致既服务法达到信息传输的实时性又无法达到监测数据与警报信息的实时性。\n\n* 相关文件：\n  * 配置文件：\n    * 监控端：`/etc/SHMS-Master/master.conf` \n    * 服务端；`/etc/SHMS-Server/server.conf`\n  * 运行日志文件：\n    * 监控端：`/var/log/SHMS-Master/SHMS-Master.log`\n    * 服务端：`/var/log/SHMS-Server/SHMS-Server.log`\n\n* 编译安装：\n  * 进入目录：`cd ./Server/build/`(服务器端)或`cd ./Master/build/`(监控端)\n  * 清空编译文件：`make clean`\n  * 编译链接生成可执行程序：`make`\n  * 添加到系统服务(使用systemd)：`sudo make install`\n\n* deb包安装：\n  * 下载deb包：[release页面](https://github.com/sunowsir/SHMS/releases) \n  * 安装：`sudo dpkg -i xxx.deb`\n\n* 服务操作：\n  * 服务器端：\n    * 查看服务状态：`sudo systemctl status SHMS-Server.service`\n    * 启动服务：`sudo systemctl start SHMS-Server.service`\n    * 停止服务：`sudo systemctl stop SHMS-Server.service`\n    * 重启服务：`sudo systemctl restart SHMS-Server.service`\n  * 监控端：\n    * 查看服务状态：`sudo systemctl status SHMS-Master.service`\n    * 启动服务：`sudo systemctl start SHMS-Master.service`\n    * 停止服务：`sudo systemctl stop SHMS-Master.service`\n    * 重启服务：`sudo systemctl restart SHMS-Master.service`\n","tags":["C"]},{"title":"Linux三剑客之awk的使用","url":"%2F2019%2F09%2F02%2FLinux%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bawk%E7%9A%84%E4%BD%BF%E7%94%A8%2F","content":"\n> awk 是一款极其强大的文本处理工具，其语言于c语言的语法极其相似，上手很容易\n>  内置变量与运算符数据来自[RUNOOB](https://www.runoob.com/linux/linux-comm-awk.html)\n\n* 简单用法\n  ```bash\n  awk [参数] 'awk代码'\n  awk [参数] -f awk脚本文件 \n  ```\n* 常用参数\n  ```bash\n  cat xxx.txt | awk -F ':' 'BEGIN{}{printf(\"%s %s\", $1, $2);}END{printf(\"OK!\");}'\n  # -F 参数是指定对每行字符串以什么字符为分割，每个被分割的部分存储在变量：$1, $2, $3...中，整行字符串存储在$0中。\n  # BEGIN{}中的代码将在文本处理前执行，同样，END{}会文本处理后执行，{}中的代码用来处理每行的文本。\n  \n  cat xxx.txt | awk -v var1=${tmp} '{printf(\"%d\\n\", $3/var1);}'\n  # -v 参数是引入外部变量，把${tmp}赋值给var1，在awk内部代码中就可以使用var1了。\n  # -v参数可以多次引用，也就是说可以引入多个变量。\n  \n  cat xxx | awk -v var1=${tmp} '{\n  \tif ($1 ~ /eth/) {\n  \t\tprint $0;\n  \t}\n  }'\n  # 通过这种方式可以使用正则表达式进行字符串匹配。\n  # awk支持print，使用print末尾自动加上\\n。\n  ```\n\n* 内置变量\n\n| 变量 | 描述                                |\n| ---- | ----------------------------------- |\n| $n   | 当前记录的第n个字段，字段间由FS分隔 |\n| $0   | 完整的输入记录                      |\n| ARGC | 命令行参数的数目                    |\n|ARGIND\t|命令行中当前文件的位置(从0开始算)\nARGV\t包含命令行参数的数组|\n|CONVFMT|数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组|\n|ERRNO|最后一个系统错误的描述|\n|FIELDWIDTHS|字段宽度列表(用空格键分隔)|\n|FILENAME|当前文件名|\n|FNR|各文件分别计数的行号|\n|FS|字段分隔符(默认是任何空格)|\n|IGNORECASE|如果为真，则进行忽略大小写的匹配|\n|NF|一条记录的字段的数目|\n|NR|已经读出的记录数，就是行号，从1开始|\n|OFMT|数字的输出格式(默认值是%.6g)|\n|OFS|输出记录分隔符（输出换行符），输出时用指定的符号代替换行符|\n|ORS|输出记录分隔符(默认值是一个换行符)|\n|RLENGTH|由match函数所匹配的字符串的长度|\n|RS|记录分隔符(默认是一个换行符)|\n|RSTART|由match函数所匹配的字符串的第一个位置|\n|SUBSEP|数组下标分隔符(默认值是/034)|\n\n* 运算符\n\n| 运算符                  | 描述 |\n| ----------------------- | ---- |\n| = += -= *= /= %= ^= **= | 赋值 |\n|?:|C条件表达式\n| \\|\\||逻辑或|\n|&&|逻辑与|\n|~ 和 !~|匹配正则表达式和不匹配正则表达式|\n|< <= > >= != ==|关系运算符|\n|空格|连接|\n|+ -|加，减|\n|* / %|乘，除与求余|\n|+ - !\t|一元加，减和逻辑非|\n|^ ***|求幂|\n|++ --|增加或减少，作为前缀或后缀|\n|$|字段引用|\n|in|数组成员|\n","tags":["note"]},{"title":"linux三剑客之grep的使用","url":"%2F2019%2F09%2F02%2Flinux%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bgrep%E7%9A%84%E4%BD%BF%E7%94%A8%2F","content":"\n> 部分内容源自网络和grep帮助信息。\n\n## 用法\n\n```bash\ngrep [参数选项] [模式串] [文件或目录]\n```\n\n\n\n## 常用参数选项说明\n\n* `-o`只显示与模式串匹配的内容。\n\n* `-E` 使用扩展正则表达式。\n\n  栗子：\n\n  ```\n  cat index.html | grep -Eo '<img\\ [^>]*'\n  ```\n\n  \n\n* `-v`显示与模式串不匹配内容所在的整行内容。\n\n* `-w`只匹配整个单词，也就说只有独立的整个单词斗鱼模式串匹配才算。\n\n* `-x`只匹配整行，也就说只有整行都与模式串匹配才算。\n\n* `-i`忽略大小写。\n\n* `-H`显示每个符合样式字符串所在行所属的文件名。\n\n* `-n`显示行号。\n\n* `-I`忽略二进制文件。\n\n\n\n---\n\n更多用法请查看man手册或`grep --help` \n","tags":["note"]},{"title":"MYSQL-笔记1","url":"%2F2019%2F09%2F02%2FMYSQL-%E7%AC%94%E8%AE%B01%2F","content":"\n>   在MYSQL中查询操作涉及内容\n\n\n\n[TOC]\n\n## function\n\n>   对待查询字段在待查找表中出现的若干记录中的函数参数中指定的字段进行某些操作。\n\n*   `COUNT` ： 统计\n*   `SUM` ： 求和\n*   `AVG` ： 平均数\n\n[more about info](https://www.runoob.com/mysql/mysql-functions.html)\n\n\n\n\n\n## sentence\n\n>   各个语句执行顺序：select –>where –> group by–> having–>order by。\n\n\n\n### 常用语句\n\n* `limit` \n\n   限定查找记录的条数。\n\n* `offset`\n\n   查找偏移量，即前n条跳过，从n+1开始查询。\n\n* `with rollup` \n\n   进一步得到`group by`信息的汇总信息。\n\n* `having` \n\n   功能类似`where`，不同的是，`where`是筛选已存在的数据，`having`用来对前面的筛选进行进一步筛选。\n\n  例：\n\n  ```mysql\n  select \n  \tname,\n  \tSUM(sign), \n  \tSUM(score) \n  from \n  \tgames \n  group by \n  \tname \n  having \n  \tSUM(score) > 80\n  ;\n  -- SUM(score)在games表中不存在，是待筛数据。\n  -- 通过having可以对其进行进一步筛选。\n  ```\n\n  \n\n* `link`\n\n  常与`where配合使用`，使用`link`子句匹配模式串，可以将`link`看作`=`。\n\n  可以使用正则表达式中的`%`来匹配任意字符。\n\n  例：\n\n  ```mysql\n  select \n  \t* \n  from \n  \tComputer \n  where \n  \tModel link 'Mac%'\n  ;\n  \n  -- 查找Computer表中Model字段中含有'Mac'的记录。\n  ```\n\n  \n\n* `order by`\n\n  排序子句，给查找出来的记录排序，可以选择按照一个或多个字段为记录排序，\n\n  当然也可以设置升序(asc)还是降序(desc)，默认是升序。\n\n  当然也可以添加`where...link...`来设置更加复杂的排序规则。\n\n  例：\n\n  ```mysql\n  select \n  \t*\n  from \n  \tComputer\n  order by \n  \tSales_volume\n  ;\n  \n  -- 按照Sales_volume字段排序输出Computer表。\n  ```\n\n  \n\n* `select ... into outfile 'filename'`\n\n  导出查询结果到文件。\n\n* `union`\n\n  用来连接多个`select`语句，将结果合并输出，可选是(all)否(默认删除重复数据)删除重复数据。\n\n  例：\n\n  ```mysql\n  select \n  \tSales_volume\n  from \n  \tComputer\n  union all\n  select \n  \tSales_volume\n  from \n  \tMobile_Phone\n  order by \n  \tSales_volume\n  ;\n  \n  -- 查找Computer表和Mobile_Phone表中的Sales_volume字段数据，\n  -- 按照Sales_volume以默认方式排序，\n  -- 而且不删除重复数据。\n  ```\n\n\n\n\n\n### JOIN\n\n>   用于连接两个或多个表，从多个表中查询数据。\n>\n>   ...  tableA [join语句] tableB ...  on [条件]\n\n*   `inner join`：语句两端的两个表的交集。\n*   `left join`：读取左边表中所有的匹配数据，即使右侧表中无匹配数据。\n*   `righe join `：与`lefr join`正好相反。\n\n\n\n### NULL\n\n在MYSQL中判断空值使用`=`和`!=`是无效的，\n\n`NULL`与任何其他值的比较结果一定是`false`，需要使用`NULL`和`IS NULL`。\n\n在创建表的时候使用`NULL`和`NOT NULL`来设置完整性约束。\n\n\n\n### 正则表达式\n\n>   MYSQL也是支持正则表达式匹配的，例如`link`子句中可以使用`%`来匹配任意字符。\n\n在MYSQL中使用正则表达式需要使用` REGEXP`子句来连接待查找字段和模式串。\n\n常用模式：\n\n| 模式       | 描述                                                         |\n| :--------- | :----------------------------------------------------------- |\n| ^          | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\\n' 或 '\\r' 之后的位置。 |\n| $          | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\\n' 或 '\\r' 之前的位置。 |\n| .          | 匹配除 \"\\n\" 之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用象 '[.\\n]' 的模式。 |\n| [...]      | 字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 \"plain\" 中的 'a'。 |\n| [^...]     | 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 \"plain\" 中的'p'。 |\n| p1\\|p2\\|p3 | 匹配 p1 或 p2 或 p3。例如，'z\\|food' 能匹配 \"z\" 或 \"food\"。'(z\\|f)ood' 则匹配 \"zood\" 或 \"food\"。 |\n| *          | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于{0,}。 |\n| +          | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 |\n| {n}        | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。 |\n| {n,m}      | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。 |\n\n[上表引自RUNOOB](https://www.runoob.com/mysql/mysql-regexp.html)\n\n\n\n### 临时表\n\n临时表的生命周期与当前账号登陆时间等同，退出登陆时，该表空间释放。\n\n创建临时表需要使用`TEMPORARY`子句修饰`table`。\n\n手动删除使用`drop`子句。\n\n\n\n### 复制表\n\n当需要完全的克隆一个已存在的表，只需要找出建表记录，使用该建表记录创建新表，然后将数据 拷贝拷贝进入即可。\n\n1. 找出建表记录\n\n   `show create table 表名`\n\n2. 更改表名创建科隆表\n\n3. 克隆数据\n\n   `insert into ... select...`\n\n\n\n### 重复数据处理\n\n* 创建表时设置约束\n\n  使用`primary key`将不可重复字段设置为主键。\n\n  1.  在设置了主键或者唯一索引后使用通常的`insert into`插入重复数据将会报错\n  2.  使用`insert ignore into`插入重复数据将仅仅是警告，然后忽略重复数据不执行插入。\n  3.  使用`replace into`插入重复数据将使用带插入数据更新旧的数据。\n\n* 筛选\n\n  1.  在`select`的时候使用`distinct`筛掉重复数据。\n  2.  使用`group by` 对不需要重复的字段进行读取不重复的字段。\n\n\n\n\n\n---\n\n参考：\n\n[RUNOOB.COM](https://www.runoob.com/mysql/mysql-tutorial.html)\n[CSDN Blog ](https://blog.csdn.net/jiangnan2014/article/details/17229713)\t\n[CSDN Blog](https://blog.csdn.net/AinUser/article/details/72803175)\n[CSDN Blog](https://blog.csdn.net/love_xsq/article/details/42417917)\n","tags":["note"]},{"title":"HDU - 2072","url":"%2F2019%2F09%2F02%2FHDU-2072%2F","content":"\n> [题目传送](http://acm.hdu.edu.cn/showproblem.php?pid=2072)\n\n\n* Sample Input\n\n  ```txt\n  you are my friend #\n  ```\n\n* Sample Output\n  ```txt\n  4\n  ```\n\n\n* 思路：\n\n  利用STL的set,但是需要注意字符串的处理，利用set的特性，建立一个中间字符串变量tmp，把当前单词暂时存在tmp中，根据判断条件（输入的字符串是否为空格或者到了末尾）来判断把tmp存入set中。\n\n  另一个需要注意的就是遍历的for需要从0到字符串最后的后面一个，为了防止什么都没有的情况。\n\n* 代码：\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nset<string> se;\n\nvoid word(string str){\n    se.clear();\n    string tmp=\"\";\n    for(int i=0;i<=str.size();i++){\n        if(str[i]==' '||i==str.size()){\n            if(tmp==\"\")  continue;\n            se.insert(tmp);\n            tmp=\"\";\n        }\n        else  tmp+=str[i];\n    }\n    cout<<se.size()<<endl;\n}\n\nint main(){\n    string str;\n    while(getline(cin,str)&&str[0]!='#')\n        word(str);\n    return 0;\n}\n```\n\n---\n该代码来源于杭电讨论区的朋友（ 喜欢你的笑声）。\n","tags":["HDU"]},{"title":"方便的轻文本处理语言-markdown","url":"%2F2019%2F09%2F02%2F%E6%96%B9%E4%BE%BF%E7%9A%84%E8%BD%BB%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E8%AF%AD%E8%A8%80-markdown%2F","content":"\n>   如果你并不需要word那么复杂的功能，没有极强的专业性需求，那么markdown是你很好的选择。\n>\n>   不同的markdown编辑器对markdown语法的支持与拓展会有一些出入，但是基础语法基本都会支持。\n>\n>   有的效果默认关闭，需要到设置里打开。\n>\n>   本文代码使用typora编辑器。推荐[typora](https://typora.io/)。\n>\n>   一般的markdown编辑器都是可以导出为各种格式的：pdf、html、word以及png等等。\n>\n>   粘贴下面代码框中的代码到你的markdown编辑器中看看效果！\n>\n>   部分高级用法内容资源来自网络其他博客和wiki。\n\n\n\n## 标题\n\n在文字的开头加上若干`#`最后跟上空格，这段文字就变成了相应等级的标题。\n\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n\n\n## 引用\n\n当我们需要加上一段引用文字或者一些声明的时候可以选择使用引用语法\n\n```markdown\n> 这是引用\n>> 这也是引用\n```\n\n\n\n## 列表\n\n当我们需要列举若干项的时候可以选择使用有序、无序列表和任务列表\n\n```markdown\n* 无序列表1\n* 无序列表2\n\n- 无序列表1\n- 无序列表2\n\n1. 有序列表1\n2. 有序列表2\n\n- [ ] 任务列表，未完成项\n- [x] 任务列表，已完成项\n```\n\n\n\n## 插入代码\n\n当我们需要插入一段代码的时候可以使用代码块语法。\n\n1. 文本中插入一段短的代码可以使用键盘中`1`左边的点把代码括起来\n\n2. 长的规范的代码可以适用代码块，使用键盘中`1`左边的点，输入两行这个点，每行三个，第一行行末输入代码的语言。\n\n3. 示例\n\n   C语言中使用`#include<>`引入头文件\n\n   ```c\n   #include <stdio.h>\n   int main () {\n   \treturn 0;\n   }\n   ```\n\n\n\n## 数学公式\n\n当我们需要插入数学公式，并且想要漂亮一些，可以使用数学公式的语法，更多的markdown数学转义符号请自行搜索，很容易搜到的。\n\n```markdown\n在数学中$\\sum$ 是求和符号。\n例如：\n$$\n$\\sum^{k}_{i = 1}{x / i}$\n$$\n```\n\n\n\n## 文字显示控制\n\n我们可能有时候需要对文本加粗、高亮等，这里markdown也提供了支持。\n\n每种效果可以叠加使用。\n\n```markdown\n*斜体*\n**加粗**\n==高亮==\n~~删除~~\n***斜体并加粗***\n==*斜体并高亮*==\n```\n\n\n\n## 表格\n\n当然了， 常用的表格markdown也是支持的。\n\n通过冒号可以控制对齐方式\n\n```markdown\n|first head|second head|third head|\n|:--|:--:|--:|\n|左对齐列|中心对齐列|右侧对齐列|\n|asd|fgh|jkl|\n```\n\n\n\n## 脚注\n\nmarkdown也是支持脚注的。\n\n```markdown\n可以这样使用脚注[^1]\n[^1]:脚注1的内容\n```\n## 分割线\n\n当我们想要分割两段内容的时候可以用分割线\n\n```markdown\n上面的内容\n---\n下面的内容\n```\n\n\n\n## 引入图像与链接\n\n引入图像和链接是必不可少的功能。\n\n```markdown\n![Linux引入图片](/home/UserName/1.jpg)\n![windows引入图片](C:\\Users\\UserName\\Downloads\\2.png)\n[百度](https://www.baidu.com)\n[参考链接]: www.baidu.com\n<www.baidu.com>\n[页内链接](#一级标题)\n```\n\n\n\n## 目录树\n\n当文本过长，需要加上目录树。\n\n```markdown\n文本1\n\n[TOC]\n\n文本2\n```\n\n\n\n## emoji表情\n\n有些markdown编辑器是支持emoji表情插入的。\n\n```markdown\n:smile:\n```\n\n\n\n## 文本折叠\n\n当我们的某个段落太长需要折叠起来，markdown貌似没有原生语法支持折叠，\n\n但是有些markdown编辑器是支持HTML语法的，这里可以使用HTML实现。\n\n```html\n<details>\n    <summary>测试标题</summary>\n测试文本\n</details>\n```\n\n## 注释\n\nmarkdown当然也有像C语言中`//`一样的注释\n\n```markdown\n<!--这是注释-->\n```\n\n\n\n## 流程图\n\nmarkdown当然也可以画流程图\n\n按照上面插入代码的方式，按照下面的例子编写代码插入到代码块中，语言是mermaid\n\n```markdown\nflowchat\nflow\nst=>start: Start\nop=>operation: Your Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n\n\n## 时序图\n\n既然支持流程图，当然也支持时序图，语言也是mermaid。\n\n```markdown\nsequenceDiagram\nX->>Y: 一起去电影院怎么样？\nNote right of Y: 去不去\nY->>X: 好的，我等你！\n```\n\n\n\n## 甘特图\n\n语言也是mermaid。\n\n```markdown\ngantt\ndateFormat  YYYY-MM-DD\ntitle 软件开发甘特图\n    \nsection 设计\n\t需求                      :done,    des1, 2014-01-06,2014-01-08\n\t原型                      :active,  des2, 2014-01-09, 3d\n\tUI设计                    :         des3, after des2, 5d\n\t未来任务                   :         des4, after des3, 5d\n\nsection 开发\n    学习准备理解需求                      :crit, done, 2014-01-06,24h\n    设计框架                             :crit, done, after des2, 2d\n    开发                                 :crit, active, 3d\n    未来任务                              :crit, 5d\n    耍                                   :2d\n\nsection 测试\n    功能测试                              :active, a1, after des3, 3d\n    压力测试                               :after a1  , 20h\n    测试报告                               : 48h\n```\n\n[来自百度经验](https://jingyan.baidu.com/article/48b558e3035d9a7f38c09aeb.html)\n\n","tags":["tools"]}]