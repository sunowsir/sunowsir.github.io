{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/Annie/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/js/resizediv.js","path":"js/resizediv.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/css/Annie.styl","path":"css/Annie.styl","modified":0,"renderable":1},{"_id":"themes/Annie/source/css/comment.styl","path":"css/comment.styl","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/logo3.png","path":"img/logo3.png","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/pure-bg.png","path":"img/pure-bg.png","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/placeholder.jpg","path":"img/placeholder.jpg","modified":0,"renderable":1},{"_id":"themes/Annie/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/chinese/chinese.js","path":"plugin/chinese/chinese.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/clipboard/clipboard.js","path":"plugin/clipboard/clipboard.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/comment/valine.min.js","path":"plugin/comment/valine.min.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/fancybox/jquery.fancybox.css","path":"plugin/fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/gallerypage/natural-gallery.full.css","path":"plugin/gallerypage/natural-gallery.full.css","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/gallerypage/natural.css","path":"plugin/gallerypage/natural.css","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/imgLazyLoader/yall.min.js","path":"plugin/imgLazyLoader/yall.min.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/imgResize/jquery.resizeimagetoparent.min.js","path":"plugin/imgResize/jquery.resizeimagetoparent.min.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/love/love.js","path":"plugin/love/love.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/search/search.js","path":"plugin/search/search.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/search/ziploader.js","path":"plugin/search/ziploader.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/toc/katelog.min.js","path":"plugin/toc/katelog.min.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/vibrant/vibrant.js","path":"plugin/vibrant/vibrant.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/quote/danger.svg","path":"img/quote/danger.svg","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/quote/info.svg","path":"img/quote/info.svg","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/quote/quote-left.svg","path":"img/quote/quote-left.svg","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/quote/success.svg","path":"img/quote/success.svg","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/quote/warning.svg","path":"img/quote/warning.svg","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/gallerypage/data.json","path":"plugin/gallerypage/data.json","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/nicescroll/jquery.nicescroll.js","path":"plugin/nicescroll/jquery.nicescroll.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/fancybox/jquery.fancybox.js","path":"plugin/fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/gallerypage/natural-gallery.full.js","path":"plugin/gallerypage/natural-gallery.full.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/gallerypage/images/default-skin.png","path":"plugin/gallerypage/images/default-skin.png","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/gallerypage/images/default-skin.svg","path":"plugin/gallerypage/images/default-skin.svg","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/gallerypage/images/preloader.gif","path":"plugin/gallerypage/images/preloader.gif","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/cart_cover.jpg","path":"img/cart_cover.jpg","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/motto/motto.js","path":"plugin/motto/motto.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/1.jpg","path":"img/1.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"4911fbecb63555c7798ce6967fc3899ce1084056","modified":1586265072418},{"_id":"themes/Annie/.project","hash":"e74f16ba9e77ca103622e508e45cff12955f9018","modified":1583666605720},{"_id":"themes/Annie/LICENSE","hash":"c224e65a5fd27ee195e6d1a205ae12c278e50147","modified":1583666605720},{"_id":"themes/Annie/README.md","hash":"136bb7a39a9d8cb4710e6acd9f66a62c3b5e16f0","modified":1583666605720},{"_id":"themes/Annie/_config.yml","hash":"254bf889b51ffee8d082d601e19eb6577678461f","modified":1583666605720},{"_id":"source/_posts/BASH杂记.md","hash":"7d5dc36886f3ed1afa142605d9fcab25726736b8","modified":1583666606770},{"_id":"source/_posts/BASH脚本实现素数线性筛.md","hash":"a78005baa9f79d35579981ffcee23184dd233d92","modified":1586316282529},{"_id":"source/_posts/Codeforces-787a.md","hash":"16ba9e6da54ddd923d0ea2b4bcd40b11b1b71540","modified":1586316417517},{"_id":"source/_posts/HDU-1222.md","hash":"903db92f75187ccd159c60746d4f1433eb677d7a","modified":1586316691831},{"_id":"source/_posts/HDU-1276.md","hash":"87369d0fdad51af4a17b414a650b1dd8d3661e88","modified":1586316741384},{"_id":"source/_posts/CPU信息获取.md","hash":"c3f42ca25de8e33959569999355fd7849b4cdb72","modified":1586316538214},{"_id":"source/_posts/HDU-1072.md","hash":"4de8e455679a2e5e4c8d92d5657959e4588c80c1","modified":1586316643785},{"_id":"source/_posts/HDU-2072.md","hash":"fc02dc3b24587c0ff2b1bfd9b0d3ba0e30ccd4ab","modified":1586316776200},{"_id":"source/_posts/Linux三剑客之awk的使用.md","hash":"bd5138949f22ee4255be703ed395e0b81724ff63","modified":1586316872497},{"_id":"source/_posts/POJ-1979.md","hash":"fa39a07df1a10ef0b3ad25ce35b705e28c3ce454","modified":1586317172239},{"_id":"source/_posts/MYSQL-笔记1.md","hash":"690024eaa77688ae785c8746831b90c0bea04282","modified":1586317137746},{"_id":"source/_posts/hexo低成本搭建静态网页博客.md","hash":"b70bc101ffa3c1e8a7ebb459e53bcc57632b8da0","modified":1586316815430},{"_id":"source/_posts/linux三剑客之grep的使用.md","hash":"17d222be0d4ad8a15b011c2027c31b8ab121da71","modified":1586316972116},{"_id":"source/_posts/Linux常见配置文件.md","hash":"f98812ccd9f773284bda51dc4c9d52402fe1698f","modified":1586317015850},{"_id":"source/_posts/deepin系统使用笔记.md","hash":"1607cfcc73c33cbac712cc1e3491aed20f50fcce","modified":1586316600829},{"_id":"source/_posts/内存信息获取.md","hash":"945b97a4faf73976ac708ef1073ae21440c49d73","modified":1586317295950},{"_id":"source/_posts/用户信息获取.md","hash":"306ed1354e7234f08d4985247dcce784d6802ec6","modified":1586317477986},{"_id":"source/_posts/服务器健康监控.md","hash":"50b67b022c2dde18b95b2cb369e913b556b25e13","modified":1586317437430},{"_id":"source/_posts/方便的轻文本处理语言-markdown.md","hash":"2d753cb00310b1361253f3e3cc0a62c01b0d4f74","modified":1586317385223},{"_id":"source/_posts/磁盘信息获取.md","hash":"734fb361c10af5bc1a261369b423c48155db796f","modified":1586317525445},{"_id":"source/_posts/进程信息获取.md","hash":"daf6e7ca3453118e03195fb879eae07acfaeb31d","modified":1586317711627},{"_id":"source/gallery/index.md","hash":"8c960918a40511b0be7680972b182c2547d285cc","modified":1583666606764},{"_id":"source/_posts/系统信息获取.md","hash":"75320ddd24e08f8ceb1d20ee7a503aabe7428f12","modified":1586317569219},{"_id":"source/_posts/八大排序算法总结.md","hash":"d3cb8272a11896fb5837341c8c57ead5c03d5b32","modified":1586317232540},{"_id":"themes/Annie/.git/FETCH_HEAD","hash":"7113aac6dc93acb2537e81d8e256027f314a910a","modified":1583666605827},{"_id":"themes/Annie/.git/config","hash":"5e7ab2817a79eb992d24a4eda74e592f2d13998e","modified":1583666605824},{"_id":"themes/Annie/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1583666605824},{"_id":"themes/Annie/.git/ORIG_HEAD","hash":"29bf34a593c07d57ee4f711e5361be0eb72162e7","modified":1583666605827},{"_id":"themes/Annie/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1583666605827},{"_id":"source/_posts/进程、线程及共享内存学习笔记.md","hash":"e6d2506d5c77530bf38f29d60e3b2f83c382e5a6","modified":1586317658804},{"_id":"themes/Annie/.git/packed-refs","hash":"94c1a39c5c1983a6375af05c580e3a0540f7fd84","modified":1583666605824},{"_id":"themes/Annie/.git/index","hash":"88faf8e9ede2704233376843a14a5de849cc0b0e","modified":1583666605827},{"_id":"themes/Annie/languages/default.yml","hash":"aa9aa92118b2e57ddd350511400c783e1b45a7dd","modified":1583666605724},{"_id":"themes/Annie/languages/en.yml","hash":"c1039029ab233468b794219c79727194d42a2bb3","modified":1583666605724},{"_id":"themes/Annie/languages/zh-CN.yml","hash":"02f5d095f5ed39bf94f900cc8b11d800167889c0","modified":1583666605724},{"_id":"themes/Annie/languages/zh-TW.yml","hash":"e9cea5e3ed2ef016ddefa19861d4ea8ba80e5039","modified":1583666605724},{"_id":"themes/Annie/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1583666605724},{"_id":"themes/Annie/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1583666605724},{"_id":"themes/Annie/layout/layout.ejs","hash":"187e05a6dfa94945e13bf28670d0c22cb3543b73","modified":1583666605727},{"_id":"themes/Annie/layout/index.ejs","hash":"03736132c5ad33748553b829378290815611e234","modified":1583666605727},{"_id":"themes/Annie/layout/gallery.ejs","hash":"ef51d11f6883648ece07a2457668d089bed91d05","modified":1583666605724},{"_id":"themes/Annie/layout/page.ejs","hash":"7ea1bad6d26c79b7baccbf452ca8a52113be2716","modified":1583666605727},{"_id":"themes/Annie/layout/post.ejs","hash":"c1fe38aba639c318ba79eecab914c18c8272c818","modified":1583666605727},{"_id":"themes/Annie/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1583666605724},{"_id":"themes/Annie/scripts/colorquote.js","hash":"ffb2efc045281e3a736d99168d149532f0a9036d","modified":1583666605824},{"_id":"source/_posts/八大排序算法总结/1.希尔排序.webp","hash":"927e021b6de6cc1a3107c48f452b6448ef711881","modified":1583666606774},{"_id":"themes/Annie/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1583666605830},{"_id":"themes/Annie/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1583666605830},{"_id":"themes/Annie/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1583666605830},{"_id":"themes/Annie/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1583666605830},{"_id":"themes/Annie/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1583666605830},{"_id":"themes/Annie/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1583666605830},{"_id":"themes/Annie/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1583666605830},{"_id":"themes/Annie/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1583666605830},{"_id":"themes/Annie/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1583666605830},{"_id":"themes/Annie/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1583666605830},{"_id":"themes/Annie/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1583666605834},{"_id":"themes/Annie/.git/logs/HEAD","hash":"4e05ba726b419e40488edf93ec82420ac3b3127c","modified":1583666605987},{"_id":"themes/Annie/.github/ISSUE_TEMPLATE/feature_request.md","hash":"e751c04e5ba9c084e904208360bc15b0c7291c53","modified":1583666605824},{"_id":"themes/Annie/.github/ISSUE_TEMPLATE/general-issue.md","hash":"4af71474cda52243b3e23d8dd3dae1463c878eb5","modified":1583666605824},{"_id":"themes/Annie/.github/ISSUE_TEMPLATE/pull-request.md","hash":"c06eb5ad4ddeefd7cf4ff254a2c11938eb795b7c","modified":1583666605824},{"_id":"themes/Annie/.github/ISSUE_TEMPLATE/bug_report.md","hash":"d032cefa84810dc7432c14da8ed30bef38558ada","modified":1583666605824},{"_id":"themes/Annie/layout/_partial/archive.ejs","hash":"d55133fa55d801e98b5431750c010098e8c3ab4a","modified":1583666605727},{"_id":"themes/Annie/layout/_partial/footer-after.ejs","hash":"185041321bd84719e0e51b65677830e9b6f6aa96","modified":1583666605730},{"_id":"themes/Annie/layout/_partial/footer-social.ejs","hash":"d57e9e709c3358e51c3ec5899de1f35a478099a7","modified":1583666605730},{"_id":"themes/Annie/layout/_partial/footer.ejs","hash":"489197b5abfae544ecffdcc1c9446b181ec4ffd1","modified":1583666605727},{"_id":"themes/Annie/layout/_partial/head.ejs","hash":"042767d4ce26639a4f0206edf23ecca1904b07b6","modified":1583666605727},{"_id":"themes/Annie/layout/_partial/header.ejs","hash":"055eb896171109e7e6e9997d895520c99bbcb6ce","modified":1583666605730},{"_id":"themes/Annie/layout/_partial/index-cart.ejs","hash":"63bf654827c69d304a5640d48e79a40f3fb93edd","modified":1583666605727},{"_id":"themes/Annie/layout/_partial/index-pure.ejs","hash":"db66980a0f438a6ed89871553626d25e2b551d61","modified":1583666605730},{"_id":"themes/Annie/layout/_partial/katex.min.css","hash":"24901f5c3bd4b159a81bf064ff44d430997d5bf9","modified":1583666605730},{"_id":"themes/Annie/layout/_partial/nav.ejs","hash":"93f81c42bc724b6fa28c1d6d88767e1dc2be9482","modified":1583666605730},{"_id":"themes/Annie/layout/_partial/page-header.ejs","hash":"752a1800252f803d9c1794fd8dec1c1b07a29718","modified":1583666605727},{"_id":"themes/Annie/layout/_partial/page.ejs","hash":"c2409a24888ca0cf908f2bb1c6d86c597f37ec95","modified":1583666605727},{"_id":"themes/Annie/layout/_partial/paginator.ejs","hash":"4bc4131fff9ee7ac15ac8375cff767cbcc86969f","modified":1583666605727},{"_id":"themes/Annie/layout/_partial/post-like.ejs","hash":"cf3f9b4b10077b1d4182601c11829b95b9b6ff59","modified":1583666605727},{"_id":"themes/Annie/layout/_partial/post-relate.ejs","hash":"ea841d89df973987e6bde654a5a691c3d879f1f9","modified":1583666605727},{"_id":"themes/Annie/layout/_partial/post-number.ejs","hash":"1ec5db7c301b7f4aaa6576354320cef9364e0dd3","modified":1583666605727},{"_id":"themes/Annie/layout/_partial/post.ejs","hash":"f0c7655d7aaba56386289ab0804ccf9107ce3acc","modified":1583666605730},{"_id":"themes/Annie/source/js/leancloud.js","hash":"0380f86667c85b6c23eca0e1adaa27cd05930247","modified":1583666605780},{"_id":"themes/Annie/source/js/main.js","hash":"1aeebe962d875798e8a546a9f5fecafea41e1dea","modified":1583666605780},{"_id":"themes/Annie/source/js/resizediv.js","hash":"1b3e3eb33aee0de1f02384dbdbd3941716e0fda5","modified":1583666605780},{"_id":"themes/Annie/source/css/Annie.styl","hash":"668f7313533c05e02bb75b7d970ce2440fe42703","modified":1583666605740},{"_id":"themes/Annie/source/css/_archive.styl","hash":"d712ae0aa5204223801f9979c774272dbdf05e4c","modified":1583666605740},{"_id":"themes/Annie/source/css/_main.styl","hash":"fa056d8bdffb0ce233e66f468e0eb6046238a5dc","modified":1583666605740},{"_id":"themes/Annie/source/css/_mobile.styl","hash":"d3aaedbd9b4cd0828519b973190f47f946f97401","modified":1583666605740},{"_id":"themes/Annie/source/css/_page.styl","hash":"2fdfe235534dfdaceb7266fa406562de10ce0073","modified":1583666605740},{"_id":"themes/Annie/source/css/_post.styl","hash":"5cd783076935cb346a88a81eb1b09c4cca22b774","modified":1583666605744},{"_id":"themes/Annie/source/css/_nav.styl","hash":"7235317d61d4f9b9cf37311a99681b1ec3a86237","modified":1583666605744},{"_id":"themes/Annie/source/css/_toc.styl","hash":"d2762bccfb37160c3c099cccf75c8ea9a13318c5","modified":1583666605740},{"_id":"themes/Annie/source/css/comment.styl","hash":"a01dad8c4422a5d1cda6b30c2a7d7205744c4966","modified":1583666605740},{"_id":"themes/Annie/source/css/_search.styl","hash":"eb55d9130c5be7a5caeaebeb8977564f5c66a239","modified":1583666605744},{"_id":"themes/Annie/source/img/logo.png","hash":"bb5467cab6beceecc9b48f772bea1e18c23ca28c","modified":1583666605747},{"_id":"themes/Annie/source/img/logo3.png","hash":"bb5467cab6beceecc9b48f772bea1e18c23ca28c","modified":1583666605747},{"_id":"themes/Annie/source/img/pure-bg.png","hash":"874074999995e6981d7602a7d5a770043a10b932","modified":1583666605747},{"_id":"themes/Annie/source/img/placeholder.jpg","hash":"e94eb7ddf701c97d3d2abbeba5c42da0bbab5d8e","modified":1583666605747},{"_id":"themes/Annie/source/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1583666605780},{"_id":"themes/Annie/.git/refs/heads/master","hash":"29bf34a593c07d57ee4f711e5361be0eb72162e7","modified":1583666605830},{"_id":"themes/Annie/layout/_partial/custom/XXX.ejs","hash":"bc338dc74c1b2d4668f8149b78d348c945a28d50","modified":1583666605734},{"_id":"themes/Annie/.git/objects/pack/pack-09d47bb651c410fabeadaf3751b0a8f7a943939c.idx","hash":"711a664ef696f48dcb79bc54a98c5509d5e78a02","modified":1583666605927},{"_id":"themes/Annie/layout/_partial/plugin/clipboard.ejs","hash":"b0c76a76c31abbed1255b057c8a9789294164bbe","modified":1583666605734},{"_id":"themes/Annie/layout/_partial/plugin/comment.ejs","hash":"11a5afa834a69727fc77e995603a478a81407514","modified":1583666605734},{"_id":"themes/Annie/layout/_partial/plugin/mathjax.ejs","hash":"4ddeccccdbf54fae9b0aebbf3df6c93215d7319d","modified":1583666605737},{"_id":"themes/Annie/layout/_partial/plugin/motto.ejs","hash":"1536976ac6e8f4315f8f79730c780026d608f962","modified":1583666605734},{"_id":"themes/Annie/layout/_partial/plugin/search.ejs","hash":"004bf820c43c935c2d41702d073ede831665d840","modified":1583666605734},{"_id":"themes/Annie/layout/_partial/plugin/share.ejs","hash":"48e74cc02711e84db24971e922171a9a4ddd74ff","modified":1583666605734},{"_id":"themes/Annie/layout/_partial/plugin/toc.ejs","hash":"08f3a7025bb4c411539928a8bb08243bee2765f5","modified":1583666605734},{"_id":"themes/Annie/layout/_partial/plugin/statistics.ejs","hash":"da3b8578df4b11575690a90e9d6cf1815eae99ee","modified":1583666605734},{"_id":"themes/Annie/layout/_partial/post/category.ejs","hash":"4c89f93ff34f620df53fb778e7005c658fcef05c","modified":1583666605730},{"_id":"themes/Annie/layout/_partial/post/date.ejs","hash":"faf8da7eb617454a6e1e728af9ffc50fa17e3997","modified":1583666605730},{"_id":"themes/Annie/layout/_partial/post/gallery.ejs","hash":"7b000ab5152a623d565a3a486f87b907bf1fd928","modified":1583666605730},{"_id":"themes/Annie/layout/_partial/widget/time-js.ejs","hash":"0590dfe1b273df42795d64e28e950f1a617ee1af","modified":1583666605734},{"_id":"themes/Annie/layout/_partial/post/navigation.ejs","hash":"490d7d2a99033e2dfcfa8f5e1a03eb400f174ff6","modified":1583666605730},{"_id":"themes/Annie/layout/_partial/post/title.ejs","hash":"8c62c05b4f9df9e43d0c20c283a750d25ece6074","modified":1583666605730},{"_id":"themes/Annie/layout/_partial/widget/totop.ejs","hash":"ba31da24a7a32146389233caf037b82f0cd255b4","modified":1583666605734},{"_id":"themes/Annie/layout/_partial/post/tag.ejs","hash":"1bb4d90e1075739797c15c6f2021396c819ee7f0","modified":1583666605730},{"_id":"themes/Annie/source/css/_highlight/_code-copy.styl","hash":"63266ec55cdd44f6470b1d4fed49fd420573aa02","modified":1583666605744},{"_id":"themes/Annie/source/css/_highlight/_diff.styl","hash":"ef9a09da02e61982a0a7adc2a609e0ab2f9c83eb","modified":1583666605744},{"_id":"themes/Annie/source/css/_highlight/highlight.styl","hash":"99dc7738c2666901262ece43c0e4dd68204fb597","modified":1583666605744},{"_id":"themes/Annie/source/css/_highlight/_theme.styl","hash":"53a02db002bd1062f4b55684b4cc268df7be578f","modified":1583666605744},{"_id":"themes/Annie/source/css/_highlight/_variables.styl","hash":"3c84c1b2ea98abc97490190ae8f85b5a865b24e3","modified":1583666605744},{"_id":"themes/Annie/source/plugin/chinese/chinese.js","hash":"986dfdf6f27852151e2225aaaa22d2302d5d24dc","modified":1583666605810},{"_id":"themes/Annie/source/plugin/clipboard/clipboard.js","hash":"43d4af727a32a793d9146eb828ed114e3ca29cec","modified":1583666605807},{"_id":"themes/Annie/source/plugin/comment/valine.min.js","hash":"0c698e2d51cdc0d2eb303c8c3a81ddd6d6cf667f","modified":1583666605797},{"_id":"themes/Annie/source/plugin/fancybox/jquery.fancybox.css","hash":"7a81dceacd45c9249b1da50c3a51eb6aec68424c","modified":1583666605794},{"_id":"themes/Annie/source/plugin/gallerypage/natural-gallery.full.css","hash":"d5c5ff93bf13e2d4ece69ccaa6cd72a2486daba0","modified":1583666605814},{"_id":"themes/Annie/source/plugin/gallerypage/natural.css","hash":"8014a4791f5789e55aa8921def9eb93b3f31d48d","modified":1583666605814},{"_id":"themes/Annie/source/plugin/imgLazyLoader/yall.min.js","hash":"59e3ca7c5cc98368156826ea857fa1a8dea6aaa4","modified":1583666605810},{"_id":"themes/Annie/source/plugin/imgResize/jquery.resizeimagetoparent.min.js","hash":"2a232d3bdf76bfedc1c51fa27b6a3ada658e156e","modified":1583666605804},{"_id":"themes/Annie/source/plugin/love/love.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1583666605820},{"_id":"themes/Annie/source/plugin/search/search.js","hash":"2004e1450c2d7e76a8d86f4d7ec69902f629eaf7","modified":1583666605807},{"_id":"themes/Annie/source/plugin/search/ziploader.js","hash":"93c976bea5ae21811807cf27b4ca8c3c94640b04","modified":1583666605807},{"_id":"themes/Annie/source/plugin/toc/katelog.min.js","hash":"7acaa9e4a1a3689b84382c1814b58b1168c57e2c","modified":1583666605804},{"_id":"themes/Annie/source/plugin/vibrant/vibrant.js","hash":"96bd870eb5e1e2803ae20135f56db90756b10d94","modified":1583666605820},{"_id":"themes/Annie/source/img/quote/danger.svg","hash":"b2db56f2cc13fce73dbea46c7b446d9bcb3bf0fd","modified":1583666605780},{"_id":"themes/Annie/source/img/quote/info.svg","hash":"c8aa387e935ba9a7fa72c5dd000b7d46f2e030c4","modified":1583666605780},{"_id":"themes/Annie/source/img/quote/quote-left.svg","hash":"d2561fa8d13e63ff196b71232a5968415ec6e372","modified":1583666605777},{"_id":"themes/Annie/source/img/quote/success.svg","hash":"029b8b3523b7daa4005983b4463cd93408308aab","modified":1583666605780},{"_id":"themes/Annie/source/img/quote/warning.svg","hash":"7153fa2a0c21e32da6a1f96a333d8b66a178569d","modified":1583666605780},{"_id":"themes/Annie/source/plugin/gallerypage/data.json","hash":"b1af217109ef799dd029e9bd0d2a41f946702781","modified":1583666605810},{"_id":"themes/Annie/source/plugin/nicescroll/jquery.nicescroll.js","hash":"25b8db3ad673a4661334b1cdeaf37ed881ffd17c","modified":1583666605800},{"_id":"themes/Annie/.git/logs/refs/heads/master","hash":"4e05ba726b419e40488edf93ec82420ac3b3127c","modified":1583666605990},{"_id":"themes/Annie/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1583666605827},{"_id":"themes/Annie/layout/_partial/plugin/clipboard/code-copy.ejs","hash":"1865c576492f8a86075a80b4af65eadff39877d8","modified":1583666605740},{"_id":"themes/Annie/layout/_partial/plugin/comment/livere.ejs","hash":"2e3567bc92eaf9eaa9104063073d275109edf312","modified":1583666605740},{"_id":"themes/Annie/layout/_partial/plugin/comment/valine.ejs","hash":"65ea46b14fe5724472046dd1a7169f963d720174","modified":1583666605737},{"_id":"themes/Annie/layout/_partial/plugin/comment/gitalk.ejs","hash":"cd97072a9b65a392c7e3de47d778498521a47c62","modified":1583666605740},{"_id":"themes/Annie/layout/_partial/plugin/share/addThis.ejs","hash":"589fe43a3d1c01a9510e72094c4f4c9a131fdee9","modified":1583666605740},{"_id":"themes/Annie/layout/_partial/plugin/share/shareThis.ejs","hash":"e25bf80455ad2baac13efc1b5bec1f81452e56ad","modified":1583666605740},{"_id":"themes/Annie/layout/_partial/plugin/share/baidu-share.ejs","hash":"c16edab203bff57320eeb9f6fed224f66d94202a","modified":1583666605740},{"_id":"themes/Annie/layout/_partial/plugin/share/social-share.ejs","hash":"f38a4e16f6c1ab39888cb0641cbbb346aa5d4c90","modified":1583666605740},{"_id":"themes/Annie/layout/_partial/plugin/statistics/baidu-analytics.ejs","hash":"2b0c7ffb8408cb6708ac2f21e6289c84bde92e99","modified":1583666605737},{"_id":"themes/Annie/layout/_partial/plugin/statistics/cnzz_analytics.ejs","hash":"a16b8110f98b0cd940d5d3dd4f41d7efcb755e97","modified":1583666605737},{"_id":"themes/Annie/layout/_partial/plugin/statistics/busuanzi.ejs","hash":"806f5ba2d3eb9d9230713d476761f11a7d38dd54","modified":1583666605737},{"_id":"themes/Annie/layout/_partial/plugin/statistics/google_analytics.ejs","hash":"065f4987a3140f0e15e49a787f5733bb1f182a53","modified":1583666605737},{"_id":"themes/Annie/layout/_partial/plugin/statistics/topN-post.ejs","hash":"3cbd3ca21a234d0d0c741d52c9de4f99111dd9d6","modified":1583666605737},{"_id":"themes/Annie/layout/_partial/plugin/statistics/leancloud.ejs","hash":"cc7f6d5102255f1188cc8c1fe05baf707e167135","modified":1583666605737},{"_id":"themes/Annie/layout/_partial/plugin/statistics/tencent_analytics.ejs","hash":"33a5a7a83e1114df6bc3b0093750887a3aad143e","modified":1583666605737},{"_id":"themes/Annie/source/plugin/fancybox/jquery.fancybox.js","hash":"c4461bc0cacd6a1d58885ca0f466ba1b7562c85d","modified":1583666605794},{"_id":"themes/Annie/source/plugin/gallerypage/natural-gallery.full.js","hash":"5b3dfb0b5279055706c57484e14c8dac321be7e8","modified":1583666605810},{"_id":"themes/Annie/source/plugin/gallerypage/images/default-skin.png","hash":"f6c7bd39c5ceda639276e64447f6007ad28ac0dd","modified":1583666605817},{"_id":"themes/Annie/source/plugin/gallerypage/images/default-skin.svg","hash":"bf61aaab4ee361ac7537b68abee8780ac6fd22f3","modified":1583666605817},{"_id":"themes/Annie/source/plugin/gallerypage/images/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1583666605817},{"_id":"themes/Annie/source/img/favicon.ico","hash":"92da6723b6526aa98c23501e6086c5948a13083c","modified":1583666605770},{"_id":"themes/Annie/source/img/cart_cover.jpg","hash":"a1daf66cf98995234980c47a876c41dcc79a142e","modified":1583666605747},{"_id":"themes/Annie/.git/logs/refs/remotes/origin/HEAD","hash":"4e05ba726b419e40488edf93ec82420ac3b3127c","modified":1583666605990},{"_id":"themes/Annie/source/plugin/motto/motto.js","hash":"282eac08d66a6e14f1b170cf1dbea67e53fba436","modified":1583666605787},{"_id":"themes/Annie/source/img/1.jpg","hash":"6a4e95d51354d2977d1fda52300ef25d4046733b","modified":1583666605747},{"_id":"themes/Annie/.git/objects/pack/pack-09d47bb651c410fabeadaf3751b0a8f7a943939c.pack","hash":"0bac8586125412194153ebbecab6941c1ba5d05a","modified":1583666605850},{"_id":"public/atom.xml","hash":"3779d6d67c8c52e1d83fbba23b144d656f5b12dd","modified":1586317725858},{"_id":"public/searchVersion.txt","hash":"ec37ec12e6e22b924a9dbbd032be491032c37fe1","modified":1586317725794},{"_id":"public/search.json","hash":"ac3dbcc91973e557790d397610f0a6507669baea","modified":1586315305167},{"_id":"public/gallery/index.html","hash":"7d1a2e7e2f111154dcd765adb334fa477b221d6c","modified":1586315305398},{"_id":"public/page/3/index.html","hash":"3a19d78434baeb25dfd14b0372f545d849e788d0","modified":1586317727536},{"_id":"public/2020/02/22/BASH杂记/index.html","hash":"8083679b24d65bd0a4248cd46e5ab81192250eb7","modified":1586317727537},{"_id":"public/2019/09/27/八大排序算法总结/index.html","hash":"4e61ca5af5e1201e2c00332c5b794ebdb780261e","modified":1586317727537},{"_id":"public/2019/09/16/hexo低成本搭建静态网页博客/index.html","hash":"9d16dd8ef43ce2e764aa5774646371f463897bef","modified":1586317727537},{"_id":"public/2019/09/02/HDU-1276/index.html","hash":"633096398a9de9bdcb0531965699b78c628f86ab","modified":1586317727537},{"_id":"public/2019/09/02/CPU信息获取/index.html","hash":"5cb399ce5b33794e6e291a54b7396e6da51066ba","modified":1586317727537},{"_id":"public/2019/09/02/POJ-1979/index.html","hash":"eac67055bfdaead84a18d6ce62213fb79cd32b79","modified":1586317727537},{"_id":"public/2019/09/02/Codeforces-787a/index.html","hash":"e55769b902f349441b80984507fff84fed6a4fb4","modified":1586317727537},{"_id":"public/2019/09/02/HDU-1072/index.html","hash":"b5a6e8019147d82b745237e539840e7056b7a6d3","modified":1586317727538},{"_id":"public/2019/09/02/BASH脚本实现素数线性筛/index.html","hash":"b6595e42ab6c1d3804f3cd752b36abd69c51d9e4","modified":1586317727538},{"_id":"public/2019/09/02/磁盘信息获取/index.html","hash":"95bd0e827f62b958ee39683c9b7f48ca10b6a74a","modified":1586317727538},{"_id":"public/2019/09/02/进程信息获取/index.html","hash":"d34c7321b3077bea510f3ffecb918a8c3d3631fd","modified":1586317727538},{"_id":"public/2019/09/02/内存信息获取/index.html","hash":"3747e3df8d007fe5c9de7a71dbaa851e0d7c561b","modified":1586317727538},{"_id":"public/2019/09/02/系统信息获取/index.html","hash":"c8d9d0b823cfbc6460ad1c44938cba82c2851a9e","modified":1586317727538},{"_id":"public/2019/09/02/用户信息获取/index.html","hash":"640ec18bb3f7e60454f72e5b156035fe22d4ae30","modified":1586317727538},{"_id":"public/2019/09/02/进程、线程及共享内存学习笔记/index.html","hash":"579b8c30f5b2435bd5de26d46089f45e01883aa3","modified":1586317727538},{"_id":"public/2019/09/02/Linux常见配置文件/index.html","hash":"22f70c20b662eb003981c84f12240bac8bb6e62c","modified":1586317727538},{"_id":"public/2019/09/02/deepin系统使用笔记/index.html","hash":"ae0cd517954abd34b23502b0967d4a7dc5e866c6","modified":1586317727539},{"_id":"public/2019/09/02/HDU-1222/index.html","hash":"6f43fc5b4ce6657e8e936171e90d6803d632a18f","modified":1586317727539},{"_id":"public/2019/09/02/服务器健康监控/index.html","hash":"bbbb175320171edfa15249d694168e2f7e9aeabf","modified":1586317727539},{"_id":"public/2019/09/02/Linux三剑客之awk的使用/index.html","hash":"118c227eec9528d4357556a093a8b79a7a67f94c","modified":1586317727539},{"_id":"public/2019/09/02/linux三剑客之grep的使用/index.html","hash":"71014fc54de1665e531f72929a744c5e62c078f2","modified":1586317727540},{"_id":"public/2019/09/02/MYSQL-笔记1/index.html","hash":"22c3929a61b3089011e3ee7ab7beaf5920cc4c35","modified":1586317727540},{"_id":"public/2019/09/02/HDU-2072/index.html","hash":"c453c73d8f91e256dc14929c54850f4495d5f12e","modified":1586317727540},{"_id":"public/2019/09/02/方便的轻文本处理语言-markdown/index.html","hash":"93108c1886fab9d93f335ba39a7a717a52f96ab3","modified":1586317727540},{"_id":"public/archives/index.html","hash":"023736cadbb120ef8eacb2208f3a715f640b3870","modified":1586315305400},{"_id":"public/archives/page/2/index.html","hash":"628022417bc2cf22056f3f0aafe486b93e9f232f","modified":1586315305400},{"_id":"public/archives/page/3/index.html","hash":"3fbf7518f9033f3edabca5028964d4dcde8afa6f","modified":1586315305400},{"_id":"public/archives/2019/index.html","hash":"a142b78a27501f0728661f4b202d074620f736f9","modified":1586315305400},{"_id":"public/archives/2019/page/2/index.html","hash":"c4d48338e93a5585713c6a5329359e4192aedf3d","modified":1586315305401},{"_id":"public/archives/2019/page/3/index.html","hash":"283f81df70bae8824f0bd6fe4b5a99fbf101742e","modified":1586315305401},{"_id":"public/archives/2019/09/index.html","hash":"dde8dd435ef9079c68af6678126300a5dd1d689b","modified":1586315305401},{"_id":"public/archives/2019/09/page/2/index.html","hash":"9d53c653ab332d4db41adc29d92116d166940305","modified":1586315305401},{"_id":"public/archives/2019/09/page/3/index.html","hash":"13e947d86809ac101ed96f88a8f61cc03267f599","modified":1586315305401},{"_id":"public/archives/2020/index.html","hash":"cc3cf935c72d8a1258aceabec97969772a65556d","modified":1586315305401},{"_id":"public/archives/2020/02/index.html","hash":"c7d9f824af955138175ad3e0028a4f4b8da016e5","modified":1586315305401},{"_id":"public/index.html","hash":"f18f06649bdf53514f1c738d2dca01f71e1280d5","modified":1586317727540},{"_id":"public/page/2/index.html","hash":"c3817410ee1e722d8be992a3d6275f56cac8757f","modified":1586317727540},{"_id":"public/tags/script/index.html","hash":"a1597b8f0a2dd534d916bf997084a130d2e06f2d","modified":1586315305401},{"_id":"public/tags/linux/index.html","hash":"360bee9aa53a6a2af5ad9a0ee5d67faddbb49ce4","modified":1586315305401},{"_id":"public/tags/algorithm/index.html","hash":"479b2c97479fbe46c838297a76effe329f74f321","modified":1586315305401},{"_id":"public/tags/题解/index.html","hash":"6b8cf0d15b0486eee09f22f5b7c578540bc3f4d9","modified":1586315305401},{"_id":"public/tags/HDU/index.html","hash":"e2569ff884010e0e4a81490d566ce576db74e786","modified":1586315305401},{"_id":"public/tags/codeforces/index.html","hash":"e61e354c22825b7aa3ef0e6c68f75c54d1cb5774","modified":1586315305402},{"_id":"public/tags/note/index.html","hash":"2bc2ebeb1c225598bef286999d00ea6fecc874b1","modified":1586315305402},{"_id":"public/tags/POJ/index.html","hash":"9732a68d09c60508650755ecd8714051eb540bdc","modified":1586315305402},{"_id":"public/tags/转载/index.html","hash":"308f89614be05b60caf5264dafae7bd4e63d337a","modified":1586315305402},{"_id":"public/tags/Project/index.html","hash":"2f44b5f6810b6619a05a436c2fde9f6ffad68016","modified":1586315305402},{"_id":"public/tags/C/index.html","hash":"ae75798cac9dcf1e103b4b933e7fb025d6e5eaaa","modified":1586315305402},{"_id":"public/tags/tools/index.html","hash":"c028b2775770ec234be31f63e96705a09225c642","modified":1586315305402},{"_id":"public/tags/alogrithm/index.html","hash":"3f791dbde333fa2c4df7b14548cdc0d5dbcc68fb","modified":1586315305402},{"_id":"public/CNAME","hash":"4911fbecb63555c7798ce6967fc3899ce1084056","modified":1586315305410},{"_id":"public/img/logo.png","hash":"bb5467cab6beceecc9b48f772bea1e18c23ca28c","modified":1586315305410},{"_id":"public/img/logo3.png","hash":"bb5467cab6beceecc9b48f772bea1e18c23ca28c","modified":1586315305410},{"_id":"public/img/pure-bg.png","hash":"874074999995e6981d7602a7d5a770043a10b932","modified":1586315305410},{"_id":"public/img/placeholder.jpg","hash":"e94eb7ddf701c97d3d2abbeba5c42da0bbab5d8e","modified":1586315305411},{"_id":"public/img/quote/danger.svg","hash":"b2db56f2cc13fce73dbea46c7b446d9bcb3bf0fd","modified":1586315305411},{"_id":"public/img/quote/info.svg","hash":"c8aa387e935ba9a7fa72c5dd000b7d46f2e030c4","modified":1586315305411},{"_id":"public/img/quote/quote-left.svg","hash":"d2561fa8d13e63ff196b71232a5968415ec6e372","modified":1586315305411},{"_id":"public/img/quote/success.svg","hash":"029b8b3523b7daa4005983b4463cd93408308aab","modified":1586315305411},{"_id":"public/img/quote/warning.svg","hash":"7153fa2a0c21e32da6a1f96a333d8b66a178569d","modified":1586315305411},{"_id":"public/plugin/gallerypage/images/default-skin.png","hash":"f6c7bd39c5ceda639276e64447f6007ad28ac0dd","modified":1586315305411},{"_id":"public/plugin/gallerypage/images/default-skin.svg","hash":"bf61aaab4ee361ac7537b68abee8780ac6fd22f3","modified":1586315305411},{"_id":"public/plugin/gallerypage/images/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1586315305411},{"_id":"public/2019/09/27/八大排序算法总结/1.希尔排序.webp","hash":"927e021b6de6cc1a3107c48f452b6448ef711881","modified":1586315305411},{"_id":"public/js/main.js","hash":"1aeebe962d875798e8a546a9f5fecafea41e1dea","modified":1586315305782},{"_id":"public/js/leancloud.js","hash":"0380f86667c85b6c23eca0e1adaa27cd05930247","modified":1586315305782},{"_id":"public/css/comment.css","hash":"4a1b64540f9c72b9d43dd2cbac532a498331ca00","modified":1586315305782},{"_id":"public/js/resizediv.js","hash":"1b3e3eb33aee0de1f02384dbdbd3941716e0fda5","modified":1586315305782},{"_id":"public/plugin/chinese/chinese.js","hash":"986dfdf6f27852151e2225aaaa22d2302d5d24dc","modified":1586315305783},{"_id":"public/plugin/gallerypage/natural.css","hash":"8014a4791f5789e55aa8921def9eb93b3f31d48d","modified":1586315305783},{"_id":"public/plugin/imgResize/jquery.resizeimagetoparent.min.js","hash":"2a232d3bdf76bfedc1c51fa27b6a3ada658e156e","modified":1586315305783},{"_id":"public/plugin/imgLazyLoader/yall.min.js","hash":"59e3ca7c5cc98368156826ea857fa1a8dea6aaa4","modified":1586315305783},{"_id":"public/plugin/love/love.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1586315305783},{"_id":"public/plugin/search/search.js","hash":"2004e1450c2d7e76a8d86f4d7ec69902f629eaf7","modified":1586315305783},{"_id":"public/plugin/toc/katelog.min.js","hash":"7acaa9e4a1a3689b84382c1814b58b1168c57e2c","modified":1586315305783},{"_id":"public/css/Annie.css","hash":"9a58e8a2a7651c022338615b6dd645990b25a89d","modified":1586315305783},{"_id":"public/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1586315305783},{"_id":"public/plugin/clipboard/clipboard.js","hash":"43d4af727a32a793d9146eb828ed114e3ca29cec","modified":1586315305783},{"_id":"public/plugin/comment/valine.min.js","hash":"0c698e2d51cdc0d2eb303c8c3a81ddd6d6cf667f","modified":1586315305783},{"_id":"public/plugin/fancybox/jquery.fancybox.css","hash":"7a81dceacd45c9249b1da50c3a51eb6aec68424c","modified":1586315305783},{"_id":"public/plugin/gallerypage/natural-gallery.full.css","hash":"d5c5ff93bf13e2d4ece69ccaa6cd72a2486daba0","modified":1586315305783},{"_id":"public/plugin/search/ziploader.js","hash":"93c976bea5ae21811807cf27b4ca8c3c94640b04","modified":1586315305783},{"_id":"public/plugin/vibrant/vibrant.js","hash":"96bd870eb5e1e2803ae20135f56db90756b10d94","modified":1586315305784},{"_id":"public/plugin/gallerypage/data.json","hash":"a827712b50f4805533735999a50684999788986c","modified":1586315305784},{"_id":"public/plugin/fancybox/jquery.fancybox.js","hash":"c4461bc0cacd6a1d58885ca0f466ba1b7562c85d","modified":1586315305784},{"_id":"public/plugin/gallerypage/natural-gallery.full.js","hash":"5b3dfb0b5279055706c57484e14c8dac321be7e8","modified":1586315305784},{"_id":"public/plugin/nicescroll/jquery.nicescroll.js","hash":"25b8db3ad673a4661334b1cdeaf37ed881ffd17c","modified":1586315305784},{"_id":"public/plugin/motto/motto.js","hash":"282eac08d66a6e14f1b170cf1dbea67e53fba436","modified":1586315305785},{"_id":"public/img/favicon.ico","hash":"92da6723b6526aa98c23501e6086c5948a13083c","modified":1586315305790},{"_id":"public/img/cart_cover.jpg","hash":"a1daf66cf98995234980c47a876c41dcc79a142e","modified":1586315305792},{"_id":"public/img/1.jpg","hash":"6a4e95d51354d2977d1fda52300ef25d4046733b","modified":1586315305801},{"_id":"source/_posts/BASH脚本实现素数线性筛/title.jpg","hash":"5cfe6fc41b5b8a40ca562849dceba96840311993","modified":1566515531000},{"_id":"public/2019/09/02/BASH脚本实现素数线性筛/title.jpg","hash":"5cfe6fc41b5b8a40ca562849dceba96840311993","modified":1586316296662},{"_id":"source/_posts/HDU-2072/title.jpg","hash":"395463e56153e3a9ebadb1cf69ba089aed55402d","modified":1564976560000},{"_id":"source/_posts/HDU-1072/wallhaven-kwlwy6.jpg","hash":"d3507e7cc56c338a59c0160adea4f3149282deee","modified":1565181132000},{"_id":"source/_posts/hexo低成本搭建静态网页博客/title.jpg","hash":"fa451a4a24b222ae497c43839bf0220e6f106c65","modified":1413646003000},{"_id":"source/_posts/POJ-1979/title.jpg","hash":"7fa39db8bdfd2acf99f9014d914e03c75ccfd6ba","modified":1566903723000},{"_id":"source/_posts/HDU-1276/title.jpg","hash":"f579b07aa67588283bf72d166cccabbbf7798af3","modified":1565226400000},{"_id":"source/_posts/linux三剑客之grep的使用/title.jpg","hash":"d3b00e8302dbb01510852ff3fad356552556c7dd","modified":1568133946000},{"_id":"source/_posts/Linux常见配置文件/title.jpg","hash":"8834e09bf254979279b4f83e45e750ccd520f2c3","modified":1565771287000},{"_id":"source/_posts/CPU信息获取/title.jpg","hash":"ba1b173053842ffecba316aac6c03d00cfd1e69d","modified":1565542008000},{"_id":"source/_posts/HDU-1222/title.jpg","hash":"2f5a35bd6dfdbce7525ba54b5ff1ad51e08fc808","modified":1564870203000},{"_id":"source/_posts/Linux三剑客之awk的使用/title.jpg","hash":"107642b0cf9923603ded451c36a01ca775967774","modified":1566247667000},{"_id":"source/_posts/用户信息获取/title.jpg","hash":"08c278856ae6e3a6c2b6eca2c29026fd111f24a5","modified":1567044803000},{"_id":"source/_posts/deepin系统使用笔记/title.jpg","hash":"5b6adad54a76b0554a644fc9e73bd055143dba8f","modified":1565513499000},{"_id":"source/_posts/八大排序算法总结/title.jpg","hash":"fb1279128912db602316395110c59b95fe4982d6","modified":1569181118000},{"_id":"source/_posts/Codeforces-787a/title.jpg","hash":"b968ec748b4266a78b67a3c82bfe65f72e8c26d1","modified":1566978285000},{"_id":"source/_posts/进程、线程及共享内存学习笔记/title.jpg","hash":"8a8caa0f650e21df35f77b8eadc4a7b99c03683f","modified":1566557771000},{"_id":"source/_posts/服务器健康监控/title.jpg","hash":"6da5a34269372fd26ed89172eaa4b00eda3df4ac","modified":1567624048000},{"_id":"source/_posts/进程信息获取/title.jpg","hash":"c1361a28cff980ad2e4e75a1c62cf7d540664d36","modified":1567772818000},{"_id":"source/_posts/磁盘信息获取/title.jpg","hash":"74fe6a58c93582b661da22bfaa3f80c1b7ea0a25","modified":1567466841000},{"_id":"source/_posts/磁盘信息获取/wallhaven-5wm328.jpg","hash":"2bbf730fc6853e2d37b28013ddeb154f5f114d1b","modified":1566256462000},{"_id":"source/_posts/MYSQL-笔记1/title.jpg","hash":"a70c7621c155c801a9b007b80ddf70a5bed38159","modified":1567991922000},{"_id":"source/_posts/内存信息获取/title.jpg","hash":"fcc1048749b5acb05ea26b2848e11f5e71133e74","modified":1565875183000},{"_id":"source/_posts/方便的轻文本处理语言-markdown/wallhaven-g8mw63.png","hash":"0e38c41351a709faa5a6e6dc1011b3f8c22131ea","modified":1565546694000},{"_id":"public/2019/09/02/HDU-2072/title.jpg","hash":"395463e56153e3a9ebadb1cf69ba089aed55402d","modified":1586317727573},{"_id":"public/2019/09/02/HDU-1072/wallhaven-kwlwy6.jpg","hash":"d3507e7cc56c338a59c0160adea4f3149282deee","modified":1586317727580},{"_id":"public/2019/09/02/POJ-1979/title.jpg","hash":"7fa39db8bdfd2acf99f9014d914e03c75ccfd6ba","modified":1586317727596},{"_id":"public/2019/09/16/hexo低成本搭建静态网页博客/title.jpg","hash":"fa451a4a24b222ae497c43839bf0220e6f106c65","modified":1586317727603},{"_id":"public/2019/09/02/linux三剑客之grep的使用/title.jpg","hash":"d3b00e8302dbb01510852ff3fad356552556c7dd","modified":1586317727623},{"_id":"public/2019/09/02/HDU-1276/title.jpg","hash":"f579b07aa67588283bf72d166cccabbbf7798af3","modified":1586317727628},{"_id":"public/2019/09/02/Linux常见配置文件/title.jpg","hash":"8834e09bf254979279b4f83e45e750ccd520f2c3","modified":1586317727632},{"_id":"public/2019/09/02/CPU信息获取/title.jpg","hash":"ba1b173053842ffecba316aac6c03d00cfd1e69d","modified":1586317727640},{"_id":"public/2019/09/02/HDU-1222/title.jpg","hash":"2f5a35bd6dfdbce7525ba54b5ff1ad51e08fc808","modified":1586317727640},{"_id":"public/2019/09/02/用户信息获取/title.jpg","hash":"08c278856ae6e3a6c2b6eca2c29026fd111f24a5","modified":1586317727660},{"_id":"public/2019/09/02/Linux三剑客之awk的使用/title.jpg","hash":"107642b0cf9923603ded451c36a01ca775967774","modified":1586317727664},{"_id":"public/2019/09/02/deepin系统使用笔记/title.jpg","hash":"5b6adad54a76b0554a644fc9e73bd055143dba8f","modified":1586317727679},{"_id":"public/2019/09/27/八大排序算法总结/title.jpg","hash":"fb1279128912db602316395110c59b95fe4982d6","modified":1586317727684},{"_id":"public/2019/09/02/Codeforces-787a/title.jpg","hash":"b968ec748b4266a78b67a3c82bfe65f72e8c26d1","modified":1586317727692},{"_id":"public/2019/09/02/进程、线程及共享内存学习笔记/title.jpg","hash":"8a8caa0f650e21df35f77b8eadc4a7b99c03683f","modified":1586317727712},{"_id":"public/2019/09/02/服务器健康监控/title.jpg","hash":"6da5a34269372fd26ed89172eaa4b00eda3df4ac","modified":1586317727756},{"_id":"public/2019/09/02/进程信息获取/title.jpg","hash":"c1361a28cff980ad2e4e75a1c62cf7d540664d36","modified":1586317727762},{"_id":"public/2019/09/02/磁盘信息获取/title.jpg","hash":"74fe6a58c93582b661da22bfaa3f80c1b7ea0a25","modified":1586317727783},{"_id":"public/2019/09/02/磁盘信息获取/wallhaven-5wm328.jpg","hash":"2bbf730fc6853e2d37b28013ddeb154f5f114d1b","modified":1586317727795},{"_id":"public/2019/09/02/MYSQL-笔记1/title.jpg","hash":"a70c7621c155c801a9b007b80ddf70a5bed38159","modified":1586317727837},{"_id":"public/2019/09/02/内存信息获取/title.jpg","hash":"fcc1048749b5acb05ea26b2848e11f5e71133e74","modified":1586317727855},{"_id":"public/2019/09/02/方便的轻文本处理语言-markdown/wallhaven-g8mw63.png","hash":"0e38c41351a709faa5a6e6dc1011b3f8c22131ea","modified":1586317727888}],"Category":[],"Data":[],"Page":[{"title":"gallery","albums":[["img_url","img_caption"],["img_url","img_caption"]],"date":"2019-08-31T02:57:46.000Z","_content":"","source":"gallery/index.md","raw":"---\ntitle: gallery\nalbums: [\n            [\"img_url\",\"img_caption\"],\n            [\"img_url\",\"img_caption\"]\n        ]\ndate: 2019-08-31 10:57:46\n---\n","updated":"2020-03-08T11:23:26.764Z","path":"gallery/index.html","comments":1,"layout":"page","_id":"ck8qr69cv00015d3awko0061r","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"BASH杂记","date":"2020-02-22T04:44:03.000Z","_content":"","source":"_posts/BASH杂记.md","raw":"---\ntitle: BASH杂记\ndate: 2020-02-22 12:44:03\ntags:\n---\n","slug":"BASH杂记","published":1,"updated":"2020-03-08T11:23:26.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8qr69cr00005d3a6prp1n60","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"BASH脚本实现素数线性筛","date":"2019-09-02T08:45:33.000Z","cover":"title.jpg","_content":"\n\n\n* 知识准备\n  1. `for`循环\n     ```bash\n     for i in `seq 1 10`;\n     do\n     \techo ${i}\n     done\n     #执行结果\n     ---------\n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     --------\n     for ((i = 0; i < 10; i++));\n     do\n     \techo ${i}\n     done\n     # 执行结果与上面代码相同\n     # 双小括号中可以使用C语言一样的语法进行数学计算\n     # echo 是回显\n     # 美元符号用来取值：取变量值和数组值（用大括号括把变量或数组起来）、取命令的值（用小括号或<Tab>键上面的``符号括起来，如果用`符号扩起来就不用美元符号取值了）\n     ```\n  2. `if`分支语句\n     ```bash\n     num=0\n     if [[ ${num} -eq 0 ]];then\n     \techo \"YES\"\n     elif [[ ${num} -eq 1 ]];then\n     \techo \"NO\"\n     else\n     \techo \"???\"\n     fi\n     # 执行结果\n     # 数值判断用-eq(==)、-ne（!=）、-gt(>)、-ge(>=)、-lt(<)、-le(<=)\n     # 字符串判断用逻辑等和不等（==、!=）\n     ---------\n     YES\n     ---------\n     ```\n  3. expr 语句 该语句后面加上数学表达式，可以求数学表达式的值，但是`*`号前需要加上转义符号`\\`\n* 代码\n  ```bash\n  #!/bin/bash\n  \n  if [[ \"x${1}\" == x ]];then \n      MAX=10\n      else\n          MAX=${1}\n  fi\n  \n  num=0\n  \n  for((i = 0; i < ${MAX}; i++));\n  do\n  \n      prime[${i}]=0\n  \n  done\n  \n  for((i = 2; i < ${MAX}; i++));\n  do\n      \n      if [[ ${prime[$i]} -eq 0 ]];then\n          prime[$num]=$i\n          ((num++))\n      fi\n      for((j = 0; j < ${num}; j++));\n      do\n          pj=${prime[$j]}\n          if [[ `expr ${i}\\*$pj` -gt ${MAX} ]];then\n              break;\n          fi\n          prime[`expr ${i}\\*${pj}`]=1\n          if [[ `expr ${i}%${pj}` == 0 ]];then\n              break;\n          fi\n      done\n  \n  done\n  \n  for((i=0;i<$num;i++));\n  do\n  \n      echo ${prime[$i]}\n  \n  done\n  \n  ```\n\n\n\n\n  \n","source":"_posts/BASH脚本实现素数线性筛.md","raw":"---\ntitle: BASH脚本实现素数线性筛\ndate: 2019-09-02 16:45:33\ncover: title.jpg\ntags:\n- script\n- linux\n- algorithm\n---\n\n\n\n* 知识准备\n  1. `for`循环\n     ```bash\n     for i in `seq 1 10`;\n     do\n     \techo ${i}\n     done\n     #执行结果\n     ---------\n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     --------\n     for ((i = 0; i < 10; i++));\n     do\n     \techo ${i}\n     done\n     # 执行结果与上面代码相同\n     # 双小括号中可以使用C语言一样的语法进行数学计算\n     # echo 是回显\n     # 美元符号用来取值：取变量值和数组值（用大括号括把变量或数组起来）、取命令的值（用小括号或<Tab>键上面的``符号括起来，如果用`符号扩起来就不用美元符号取值了）\n     ```\n  2. `if`分支语句\n     ```bash\n     num=0\n     if [[ ${num} -eq 0 ]];then\n     \techo \"YES\"\n     elif [[ ${num} -eq 1 ]];then\n     \techo \"NO\"\n     else\n     \techo \"???\"\n     fi\n     # 执行结果\n     # 数值判断用-eq(==)、-ne（!=）、-gt(>)、-ge(>=)、-lt(<)、-le(<=)\n     # 字符串判断用逻辑等和不等（==、!=）\n     ---------\n     YES\n     ---------\n     ```\n  3. expr 语句 该语句后面加上数学表达式，可以求数学表达式的值，但是`*`号前需要加上转义符号`\\`\n* 代码\n  ```bash\n  #!/bin/bash\n  \n  if [[ \"x${1}\" == x ]];then \n      MAX=10\n      else\n          MAX=${1}\n  fi\n  \n  num=0\n  \n  for((i = 0; i < ${MAX}; i++));\n  do\n  \n      prime[${i}]=0\n  \n  done\n  \n  for((i = 2; i < ${MAX}; i++));\n  do\n      \n      if [[ ${prime[$i]} -eq 0 ]];then\n          prime[$num]=$i\n          ((num++))\n      fi\n      for((j = 0; j < ${num}; j++));\n      do\n          pj=${prime[$j]}\n          if [[ `expr ${i}\\*$pj` -gt ${MAX} ]];then\n              break;\n          fi\n          prime[`expr ${i}\\*${pj}`]=1\n          if [[ `expr ${i}%${pj}` == 0 ]];then\n              break;\n          fi\n      done\n  \n  done\n  \n  for((i=0;i<$num;i++));\n  do\n  \n      echo ${prime[$i]}\n  \n  done\n  \n  ```\n\n\n\n\n  \n","slug":"BASH脚本实现素数线性筛","published":1,"updated":"2020-04-08T03:24:42.529Z","_id":"ck8qr69cw00025d3ah6mys7i3","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>知识准备\n<ol>\n<li>\n<p><code>for</code>循环</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> `seq 1 10`;</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;i&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\">#执行结果</span></span><br><span class=\"line\">---------</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">--------</span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i = 0; i &lt; 10; i++));</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;i&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\"># 执行结果与上面代码相同</span></span><br><span class=\"line\"><span class=\"comment\"># 双小括号中可以使用C语言一样的语法进行数学计算</span></span><br><span class=\"line\"><span class=\"comment\"># echo 是回显</span></span><br><span class=\"line\"><span class=\"comment\"># 美元符号用来取值：取变量值和数组值（用大括号括把变量或数组起来）、取命令的值（用小括号或&lt;Tab&gt;键上面的``符号括起来，如果用`符号扩起来就不用美元符号取值了）</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>if</code>分支语句</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num=0</span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;num&#125;</span> -eq 0 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"YES\"</span></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ <span class=\"variable\">$&#123;num&#125;</span> -eq 1 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"NO\"</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"???\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"comment\"># 执行结果</span></span><br><span class=\"line\"><span class=\"comment\"># 数值判断用-eq(==)、-ne（!=）、-gt(&gt;)、-ge(&gt;=)、-lt(&lt;)、-le(&lt;=)</span></span><br><span class=\"line\"><span class=\"comment\"># 字符串判断用逻辑等和不等（==、!=）</span></span><br><span class=\"line\">---------</span><br><span class=\"line\">YES</span><br><span class=\"line\">---------</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>expr 语句 该语句后面加上数学表达式，可以求数学表达式的值，但是<code>*</code>号前需要加上转义符号<code>\\</code></p>\n</li>\n</ol>\n</li>\n<li>代码<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"string\">\"x<span class=\"variable\">$&#123;1&#125;</span>\"</span> == x ]];<span class=\"keyword\">then</span> </span><br><span class=\"line\">    MAX=10</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        MAX=<span class=\"variable\">$&#123;1&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">num=0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>((i = 0; i &lt; <span class=\"variable\">$&#123;MAX&#125;</span>; i++));</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"></span><br><span class=\"line\">    prime[<span class=\"variable\">$&#123;i&#125;</span>]=0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>((i = 2; i &lt; <span class=\"variable\">$&#123;MAX&#125;</span>; i++));</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;prime[$i]&#125;</span> -eq 0 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">        prime[<span class=\"variable\">$num</span>]=<span class=\"variable\">$i</span></span><br><span class=\"line\">        ((num++))</span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>((j = 0; j &lt; <span class=\"variable\">$&#123;num&#125;</span>; j++));</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">        pj=<span class=\"variable\">$&#123;prime[$j]&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [[ `expr <span class=\"variable\">$&#123;i&#125;</span>\\*<span class=\"variable\">$pj</span>` -gt <span class=\"variable\">$&#123;MAX&#125;</span> ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">        prime[`expr <span class=\"variable\">$&#123;i&#125;</span>\\*<span class=\"variable\">$&#123;pj&#125;</span>`]=1</span><br><span class=\"line\">        <span class=\"keyword\">if</span> [[ `expr <span class=\"variable\">$&#123;i&#125;</span>%<span class=\"variable\">$&#123;pj&#125;</span>` == 0 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>((i=0;i&lt;<span class=\"variable\">$num</span>;i++));</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;prime[$i]&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>知识准备\n<ol>\n<li>\n<p><code>for</code>循环</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> `seq 1 10`;</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;i&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\">#执行结果</span></span><br><span class=\"line\">---------</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">--------</span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i = 0; i &lt; 10; i++));</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;i&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"comment\"># 执行结果与上面代码相同</span></span><br><span class=\"line\"><span class=\"comment\"># 双小括号中可以使用C语言一样的语法进行数学计算</span></span><br><span class=\"line\"><span class=\"comment\"># echo 是回显</span></span><br><span class=\"line\"><span class=\"comment\"># 美元符号用来取值：取变量值和数组值（用大括号括把变量或数组起来）、取命令的值（用小括号或&lt;Tab&gt;键上面的``符号括起来，如果用`符号扩起来就不用美元符号取值了）</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>if</code>分支语句</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num=0</span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;num&#125;</span> -eq 0 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"YES\"</span></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ <span class=\"variable\">$&#123;num&#125;</span> -eq 1 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"NO\"</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"???\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"comment\"># 执行结果</span></span><br><span class=\"line\"><span class=\"comment\"># 数值判断用-eq(==)、-ne（!=）、-gt(&gt;)、-ge(&gt;=)、-lt(&lt;)、-le(&lt;=)</span></span><br><span class=\"line\"><span class=\"comment\"># 字符串判断用逻辑等和不等（==、!=）</span></span><br><span class=\"line\">---------</span><br><span class=\"line\">YES</span><br><span class=\"line\">---------</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>expr 语句 该语句后面加上数学表达式，可以求数学表达式的值，但是<code>*</code>号前需要加上转义符号<code>\\</code></p>\n</li>\n</ol>\n</li>\n<li>代码<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"string\">\"x<span class=\"variable\">$&#123;1&#125;</span>\"</span> == x ]];<span class=\"keyword\">then</span> </span><br><span class=\"line\">    MAX=10</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        MAX=<span class=\"variable\">$&#123;1&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">num=0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>((i = 0; i &lt; <span class=\"variable\">$&#123;MAX&#125;</span>; i++));</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"></span><br><span class=\"line\">    prime[<span class=\"variable\">$&#123;i&#125;</span>]=0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>((i = 2; i &lt; <span class=\"variable\">$&#123;MAX&#125;</span>; i++));</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> [[ <span class=\"variable\">$&#123;prime[$i]&#125;</span> -eq 0 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">        prime[<span class=\"variable\">$num</span>]=<span class=\"variable\">$i</span></span><br><span class=\"line\">        ((num++))</span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>((j = 0; j &lt; <span class=\"variable\">$&#123;num&#125;</span>; j++));</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">        pj=<span class=\"variable\">$&#123;prime[$j]&#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [[ `expr <span class=\"variable\">$&#123;i&#125;</span>\\*<span class=\"variable\">$pj</span>` -gt <span class=\"variable\">$&#123;MAX&#125;</span> ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">        prime[`expr <span class=\"variable\">$&#123;i&#125;</span>\\*<span class=\"variable\">$&#123;pj&#125;</span>`]=1</span><br><span class=\"line\">        <span class=\"keyword\">if</span> [[ `expr <span class=\"variable\">$&#123;i&#125;</span>%<span class=\"variable\">$&#123;pj&#125;</span>` == 0 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>((i=0;i&lt;<span class=\"variable\">$num</span>;i++));</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;prime[$i]&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"HDU-1222","date":"2019-09-02T08:38:28.000Z","cover":"title.jpg","_content":"\n> [题目传送](http://acm.hdu.edu.cn/status.php?first=&pid=&user=sunowsir&lang=0&status=0)\n\n* 题目描述:\n\n  There is a hill with n holes around. The holes are signed from 0 to n-1.\n\n  A rabbit must hide in one of the holes. A wolf searches the rabbit in anticlockwise order. The first hole he get into is the one signed with 0. Then he will get into the hole every m holes. For example, m=2 and n=6, the wolf will get into the holes which are signed 0,2,4,0. If the rabbit hides in the hole which signed 1,3 or 5, she will survive. So we call these holes the safe holes.\n\n  InputThe input starts with a positive integer P which indicates the number of test cases. Then on the following P lines,each line consists 2 positive integer m and n(0<m,n<2147483648).\n  OutputFor each input m n, if safe holes exist, you should output \"YES\", else output \"NO\" in a single line.\n\nSample Input\n\t\n\t2\n\t1 2\n\t2 2\nSample Output\n\n\tNO\n\tYES\n\n* 题目思路：\n  只需要判断m和n的最大公约数是否等于1即可，不等于一则永远抓不到；\n\n* 代码：\n```c\n/*************************************************************************\n    > File Name: HDU-1222.cpp\n    > Author: sunowsir\n ************************************************************************/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a,int b){\n    return b==0? a:gcd(b , a%b);\n}\n\nint main(){\n    int m,n,N;\n    cin>>N;\n    while(N--){\n        cin>>m>>n;\n        if(gcd(m,n)!=1)  cout<<\"YES\"<<endl;\n        else  cout<<\"NO\"<<endl;\n    }\n    return 0;\n}\n```\n","source":"_posts/HDU-1222.md","raw":"---\ntitle: HDU-1222\ndate: 2019-09-02 16:38:28\ncover: title.jpg\ntags: \n- 题解\n- HDU\n---\n\n> [题目传送](http://acm.hdu.edu.cn/status.php?first=&pid=&user=sunowsir&lang=0&status=0)\n\n* 题目描述:\n\n  There is a hill with n holes around. The holes are signed from 0 to n-1.\n\n  A rabbit must hide in one of the holes. A wolf searches the rabbit in anticlockwise order. The first hole he get into is the one signed with 0. Then he will get into the hole every m holes. For example, m=2 and n=6, the wolf will get into the holes which are signed 0,2,4,0. If the rabbit hides in the hole which signed 1,3 or 5, she will survive. So we call these holes the safe holes.\n\n  InputThe input starts with a positive integer P which indicates the number of test cases. Then on the following P lines,each line consists 2 positive integer m and n(0<m,n<2147483648).\n  OutputFor each input m n, if safe holes exist, you should output \"YES\", else output \"NO\" in a single line.\n\nSample Input\n\t\n\t2\n\t1 2\n\t2 2\nSample Output\n\n\tNO\n\tYES\n\n* 题目思路：\n  只需要判断m和n的最大公约数是否等于1即可，不等于一则永远抓不到；\n\n* 代码：\n```c\n/*************************************************************************\n    > File Name: HDU-1222.cpp\n    > Author: sunowsir\n ************************************************************************/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a,int b){\n    return b==0? a:gcd(b , a%b);\n}\n\nint main(){\n    int m,n,N;\n    cin>>N;\n    while(N--){\n        cin>>m>>n;\n        if(gcd(m,n)!=1)  cout<<\"YES\"<<endl;\n        else  cout<<\"NO\"<<endl;\n    }\n    return 0;\n}\n```\n","slug":"HDU-1222","published":1,"updated":"2020-04-08T03:31:31.831Z","_id":"ck8qr69cy00035d3amv15fi4m","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><a href=\"http://acm.hdu.edu.cn/status.php?first=&amp;pid=&amp;user=sunowsir&amp;lang=0&amp;status=0\" target=\"_blank\" rel=\"noopener\">题目传送</a></p>\n</blockquote>\n<ul>\n<li>\n<p>题目描述:</p>\n<p>There is a hill with n holes around. The holes are signed from 0 to n-1.</p>\n<p>A rabbit must hide in one of the holes. A wolf searches the rabbit in anticlockwise order. The first hole he get into is the one signed with 0. Then he will get into the hole every m holes. For example, m=2 and n=6, the wolf will get into the holes which are signed 0,2,4,0. If the rabbit hides in the hole which signed 1,3 or 5, she will survive. So we call these holes the safe holes.</p>\n<p>InputThe input starts with a positive integer P which indicates the number of test cases. Then on the following P lines,each line consists 2 positive integer m and n(0&lt;m,n&lt;2147483648).<br>\nOutputFor each input m n, if safe holes exist, you should output “YES”, else output “NO” in a single line.</p>\n</li>\n</ul>\n<p>Sample Input</p>\n<pre><code>2\n1 2\n2 2\n</code></pre>\n<p>Sample Output</p>\n<pre><code>NO\nYES\n</code></pre>\n<ul>\n<li>\n<p>题目思路：<br>\n只需要判断m和n的最大公约数是否等于1即可，不等于一则永远抓不到；</p>\n</li>\n<li>\n<p>代码：</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">    &gt; File Name: HDU-1222.cpp</span></span><br><span class=\"line\"><span class=\"comment\">    &gt; Author: sunowsir</span></span><br><span class=\"line\"><span class=\"comment\"> ************************************************************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b==<span class=\"number\">0</span>? a:gcd(b , a%b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m,n,N;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;N;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(N--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(gcd(m,n)!=<span class=\"number\">1</span>)  <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"YES\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"NO\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"http://acm.hdu.edu.cn/status.php?first=&amp;pid=&amp;user=sunowsir&amp;lang=0&amp;status=0\" target=\"_blank\" rel=\"noopener\">题目传送</a></p>\n</blockquote>\n<ul>\n<li>\n<p>题目描述:</p>\n<p>There is a hill with n holes around. The holes are signed from 0 to n-1.</p>\n<p>A rabbit must hide in one of the holes. A wolf searches the rabbit in anticlockwise order. The first hole he get into is the one signed with 0. Then he will get into the hole every m holes. For example, m=2 and n=6, the wolf will get into the holes which are signed 0,2,4,0. If the rabbit hides in the hole which signed 1,3 or 5, she will survive. So we call these holes the safe holes.</p>\n<p>InputThe input starts with a positive integer P which indicates the number of test cases. Then on the following P lines,each line consists 2 positive integer m and n(0&lt;m,n&lt;2147483648).<br>\nOutputFor each input m n, if safe holes exist, you should output “YES”, else output “NO” in a single line.</p>\n</li>\n</ul>\n<p>Sample Input</p>\n<pre><code>2\n1 2\n2 2\n</code></pre>\n<p>Sample Output</p>\n<pre><code>NO\nYES\n</code></pre>\n<ul>\n<li>\n<p>题目思路：<br>\n只需要判断m和n的最大公约数是否等于1即可，不等于一则永远抓不到；</p>\n</li>\n<li>\n<p>代码：</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">    &gt; File Name: HDU-1222.cpp</span></span><br><span class=\"line\"><span class=\"comment\">    &gt; Author: sunowsir</span></span><br><span class=\"line\"><span class=\"comment\"> ************************************************************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b==<span class=\"number\">0</span>? a:gcd(b , a%b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m,n,N;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;N;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(N--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(gcd(m,n)!=<span class=\"number\">1</span>)  <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"YES\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"NO\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Codeforces-787a","cover":"title.jpg","mathjax":"true","date":"2019-09-02T08:48:33.000Z","_content":"\n> [题目传送](https://vjudge.net/problem/709847/origin)\n* 题目思路：\n  拓展欧几里德：\n  $$\n  a*x+b=c*y+d; <=> a*x+c*y=d-b;\n  $$\n\n\n代码：\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nll exgcd(ll a,ll b,ll &x,ll &y){\n    if(b==0){\n        x=1;\n        y=0;\n        return a;\n    }\n    ll d=exgcd(b,a%b,x,y);\n    ll tmp=x;\n    x=y;\n    y=tmp-a/b*y;\n    return d;\n}\n\nint main(){\n    ll a,b,C,D,x,y;\n    while(cin>>a>>b>>C>>D){\n        if(b<D){//若b<D,那么y<0，\n            //原方程式等价于y=(a*x+b-d)/c,\n            //下面的处理可保证x不小于0,但是不能保证y，\n            //所以需要保证(a*x+b-d)%c==0,即：保证：b>D；若不成立需交换；\n            swap(a,C);\n            swap(b,D);\n        }\n        ll d = exgcd(a,C,x,y);\n        ll c = D-b;\n        if(c%d)  cout<<\"-1\"<<endl;\n        else{\n            x=x*(c/d);\n            x=(x%(C/d)+(C/d))%(C/d);\n            cout<<b+a*x<<endl;\n        }\n    }\n    return 0;\n}\n```\n","source":"_posts/Codeforces-787a.md","raw":"---\ntitle: Codeforces-787a\ntags:\n- 题解\n- codeforces\ncover: title.jpg\nmathjax: 'true'\ndate: 2019-09-02 16:48:33\n---\n\n> [题目传送](https://vjudge.net/problem/709847/origin)\n* 题目思路：\n  拓展欧几里德：\n  $$\n  a*x+b=c*y+d; <=> a*x+c*y=d-b;\n  $$\n\n\n代码：\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nll exgcd(ll a,ll b,ll &x,ll &y){\n    if(b==0){\n        x=1;\n        y=0;\n        return a;\n    }\n    ll d=exgcd(b,a%b,x,y);\n    ll tmp=x;\n    x=y;\n    y=tmp-a/b*y;\n    return d;\n}\n\nint main(){\n    ll a,b,C,D,x,y;\n    while(cin>>a>>b>>C>>D){\n        if(b<D){//若b<D,那么y<0，\n            //原方程式等价于y=(a*x+b-d)/c,\n            //下面的处理可保证x不小于0,但是不能保证y，\n            //所以需要保证(a*x+b-d)%c==0,即：保证：b>D；若不成立需交换；\n            swap(a,C);\n            swap(b,D);\n        }\n        ll d = exgcd(a,C,x,y);\n        ll c = D-b;\n        if(c%d)  cout<<\"-1\"<<endl;\n        else{\n            x=x*(c/d);\n            x=(x%(C/d)+(C/d))%(C/d);\n            cout<<b+a*x<<endl;\n        }\n    }\n    return 0;\n}\n```\n","slug":"Codeforces-787a","published":1,"updated":"2020-04-08T03:26:57.517Z","_id":"ck8qr69d100055d3av8d6sr50","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><a href=\"https://vjudge.net/problem/709847/origin\" target=\"_blank\" rel=\"noopener\">题目传送</a></p>\n</blockquote>\n<ul>\n<li>题目思路：<br>\n拓展欧几里德：<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>x</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>c</mi><mo>∗</mo><mi>y</mi><mo>+</mo><mi>d</mi><mo separator=\"true\">;</mo><mo>&lt;</mo><mo>=</mo><mo>&gt;</mo><mi>a</mi><mo>∗</mo><mi>x</mi><mo>+</mo><mi>c</mi><mo>∗</mo><mi>y</mi><mo>=</mo><mi>d</mi><mo>−</mo><mi>b</mi><mo separator=\"true\">;</mo></mrow><annotation encoding=\"application/x-tex\">a*x+b=c*y+d; &lt;=&gt; a*x+c*y=d-b;\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">a</span><span class=\"mbin\">∗</span><span class=\"mord mathit\">x</span><span class=\"mbin\">+</span><span class=\"mord mathit\">b</span><span class=\"mrel\">=</span><span class=\"mord mathit\">c</span><span class=\"mbin\">∗</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mbin\">+</span><span class=\"mord mathit\">d</span><span class=\"mpunct\">;</span><span class=\"mrel\">&lt;</span><span class=\"mrel\">=</span><span class=\"mrel\">&gt;</span><span class=\"mord mathit\">a</span><span class=\"mbin\">∗</span><span class=\"mord mathit\">x</span><span class=\"mbin\">+</span><span class=\"mord mathit\">c</span><span class=\"mbin\">∗</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mrel\">=</span><span class=\"mord mathit\">d</span><span class=\"mbin\">−</span><span class=\"mord mathit\">b</span><span class=\"mpunct\">;</span></span></span></span></span></p>\n</li>\n</ul>\n<p>代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">exgcd</span><span class=\"params\">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        x=<span class=\"number\">1</span>;</span><br><span class=\"line\">        y=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll d=exgcd(b,a%b,x,y);</span><br><span class=\"line\">    ll tmp=x;</span><br><span class=\"line\">    x=y;</span><br><span class=\"line\">    y=tmp-a/b*y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ll a,b,C,D,x,y;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;C&gt;&gt;D)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&lt;D)&#123;<span class=\"comment\">//若b&lt;D,那么y&lt;0，</span></span><br><span class=\"line\">            <span class=\"comment\">//原方程式等价于y=(a*x+b-d)/c,</span></span><br><span class=\"line\">            <span class=\"comment\">//下面的处理可保证x不小于0,但是不能保证y，</span></span><br><span class=\"line\">            <span class=\"comment\">//所以需要保证(a*x+b-d)%c==0,即：保证：b&gt;D；若不成立需交换；</span></span><br><span class=\"line\">            swap(a,C);</span><br><span class=\"line\">            swap(b,D);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ll d = exgcd(a,C,x,y);</span><br><span class=\"line\">        ll c = D-b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c%d)  <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"-1\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            x=x*(c/d);</span><br><span class=\"line\">            x=(x%(C/d)+(C/d))%(C/d);</span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;b+a*x&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://vjudge.net/problem/709847/origin\" target=\"_blank\" rel=\"noopener\">题目传送</a></p>\n</blockquote>\n<ul>\n<li>题目思路：<br>\n拓展欧几里德：<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>x</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>c</mi><mo>∗</mo><mi>y</mi><mo>+</mo><mi>d</mi><mo separator=\"true\">;</mo><mo>&lt;</mo><mo>=</mo><mo>&gt;</mo><mi>a</mi><mo>∗</mo><mi>x</mi><mo>+</mo><mi>c</mi><mo>∗</mo><mi>y</mi><mo>=</mo><mi>d</mi><mo>−</mo><mi>b</mi><mo separator=\"true\">;</mo></mrow><annotation encoding=\"application/x-tex\">a*x+b=c*y+d; &lt;=&gt; a*x+c*y=d-b;\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">a</span><span class=\"mbin\">∗</span><span class=\"mord mathit\">x</span><span class=\"mbin\">+</span><span class=\"mord mathit\">b</span><span class=\"mrel\">=</span><span class=\"mord mathit\">c</span><span class=\"mbin\">∗</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mbin\">+</span><span class=\"mord mathit\">d</span><span class=\"mpunct\">;</span><span class=\"mrel\">&lt;</span><span class=\"mrel\">=</span><span class=\"mrel\">&gt;</span><span class=\"mord mathit\">a</span><span class=\"mbin\">∗</span><span class=\"mord mathit\">x</span><span class=\"mbin\">+</span><span class=\"mord mathit\">c</span><span class=\"mbin\">∗</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mrel\">=</span><span class=\"mord mathit\">d</span><span class=\"mbin\">−</span><span class=\"mord mathit\">b</span><span class=\"mpunct\">;</span></span></span></span></span></p>\n</li>\n</ul>\n<p>代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">exgcd</span><span class=\"params\">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        x=<span class=\"number\">1</span>;</span><br><span class=\"line\">        y=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll d=exgcd(b,a%b,x,y);</span><br><span class=\"line\">    ll tmp=x;</span><br><span class=\"line\">    x=y;</span><br><span class=\"line\">    y=tmp-a/b*y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ll a,b,C,D,x,y;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;C&gt;&gt;D)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&lt;D)&#123;<span class=\"comment\">//若b&lt;D,那么y&lt;0，</span></span><br><span class=\"line\">            <span class=\"comment\">//原方程式等价于y=(a*x+b-d)/c,</span></span><br><span class=\"line\">            <span class=\"comment\">//下面的处理可保证x不小于0,但是不能保证y，</span></span><br><span class=\"line\">            <span class=\"comment\">//所以需要保证(a*x+b-d)%c==0,即：保证：b&gt;D；若不成立需交换；</span></span><br><span class=\"line\">            swap(a,C);</span><br><span class=\"line\">            swap(b,D);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ll d = exgcd(a,C,x,y);</span><br><span class=\"line\">        ll c = D-b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c%d)  <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"-1\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            x=x*(c/d);</span><br><span class=\"line\">            x=(x%(C/d)+(C/d))%(C/d);</span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;b+a*x&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"HDU-1276","date":"2019-09-02T08:52:14.000Z","cover":"title.jpg","_content":"\n* 题目描述\n\n  某部队进行新兵队列训练，将新兵从一开始按顺序依次编号，并排成一行横队，训练的规则如下：从头开始一至二报数，凡报到二的出列，剩下的向小序号方向靠拢，再从头开始进行一至三报数，凡报到三的出列，剩下的向小序号方向靠拢，继续从头开始进行一至二报数。。。，以后从头开始轮流进行一至二报数、一至三报数直到剩下的人数不超过三人为止。\n\n  Input\n\n  本题有多个测试数据组，第一行为组数N，接着为N行新兵人数，新兵人数不超过5000。\n\n  Output\n\n  共有N行，分别对应输入的新兵人数，每行输出剩下的新兵最初的编号，编号之间有一个空格。\n\n* Sample Input\n\n```\n2 20 40\n```\n\n* Sample Output\n\n```\n1 7 19 1 19 37\n```\n\n\n\n* 代码如下：\n\n\n\n```c++\n************************/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\n    int N,n,sol_num,cnt;\n\n    int sol[5005];\n\n    //输入数据的组数；\n\n    cin>>n;\n\n    while(n--){\n\n        //每次都需要把数组清零；\n\n        memset(sol,0,sizeof(sol));\n\n        //输入新兵的人数；\n\n        cin>>sol_num;\n\n        //把初始编号存入数组；\n\n        for(int i=1;i<=sol_num;i++)  sol[i]=i;\n\n        //把变量sol_num用作每次筛选剩下的人数；\n\n        N=sol_num;\n\n        //剩下的人数不超过3个；\n\n        while(sol_num>3){\n\n            cnt=0;\n\n            //当人数不超过3个的时候跳出\n\n            if(sol_num>3){\n\n                //每次都循环到N；\n\n                for(int i=1;i<=N;i++){\n\n                    //跳过被赋值为另的位置；\n\n                    if(sol[i])  cnt++;\n\n                    //把报数为2的赋值为0，当前长度减1；\n\n                    if(cnt==2){\n\n                        sol[i]=0;\n\n                        sol_num--;\n\n                        cnt=0;\n\n                    }\n\n                }\n\n            }\n\n            cnt=0;\n\n            //当人数不超过三个的时候跳出；\n\n            if(sol_num>3){\n\n                for(int i=1;i<=N;i++){\n\n                    if(sol[i])  cnt++;\n\n                    if(cnt==3){\n\n                        sol[i]=0;\n\n                        sol_num--;\n\n                        cnt=0;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        //输出的时候注意控制空格，为零的位置要直接跳过；\n\n        int tmp=0;\n\n        for(int i=1;i<=N;i++){\n\n            if(sol[i]!=0){\n\n                if(tmp==1)  cout<<\" \";\n\n                tmp=1;\n\n                cout<<sol[i];\n\n            }\n\n        }\n\n        cout<<endl;\n\n    }\n\n    return 0;\n\n}\n\n\n\n```\n\n\n\n\n\n---\n\n该题思想来自网络；\n","source":"_posts/HDU-1276.md","raw":"---\ntitle: HDU-1276\ndate: 2019-09-02 16:52:14\ncover: title.jpg\ntags:\n- 题解\n- HDU\n---\n\n* 题目描述\n\n  某部队进行新兵队列训练，将新兵从一开始按顺序依次编号，并排成一行横队，训练的规则如下：从头开始一至二报数，凡报到二的出列，剩下的向小序号方向靠拢，再从头开始进行一至三报数，凡报到三的出列，剩下的向小序号方向靠拢，继续从头开始进行一至二报数。。。，以后从头开始轮流进行一至二报数、一至三报数直到剩下的人数不超过三人为止。\n\n  Input\n\n  本题有多个测试数据组，第一行为组数N，接着为N行新兵人数，新兵人数不超过5000。\n\n  Output\n\n  共有N行，分别对应输入的新兵人数，每行输出剩下的新兵最初的编号，编号之间有一个空格。\n\n* Sample Input\n\n```\n2 20 40\n```\n\n* Sample Output\n\n```\n1 7 19 1 19 37\n```\n\n\n\n* 代码如下：\n\n\n\n```c++\n************************/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\n    int N,n,sol_num,cnt;\n\n    int sol[5005];\n\n    //输入数据的组数；\n\n    cin>>n;\n\n    while(n--){\n\n        //每次都需要把数组清零；\n\n        memset(sol,0,sizeof(sol));\n\n        //输入新兵的人数；\n\n        cin>>sol_num;\n\n        //把初始编号存入数组；\n\n        for(int i=1;i<=sol_num;i++)  sol[i]=i;\n\n        //把变量sol_num用作每次筛选剩下的人数；\n\n        N=sol_num;\n\n        //剩下的人数不超过3个；\n\n        while(sol_num>3){\n\n            cnt=0;\n\n            //当人数不超过3个的时候跳出\n\n            if(sol_num>3){\n\n                //每次都循环到N；\n\n                for(int i=1;i<=N;i++){\n\n                    //跳过被赋值为另的位置；\n\n                    if(sol[i])  cnt++;\n\n                    //把报数为2的赋值为0，当前长度减1；\n\n                    if(cnt==2){\n\n                        sol[i]=0;\n\n                        sol_num--;\n\n                        cnt=0;\n\n                    }\n\n                }\n\n            }\n\n            cnt=0;\n\n            //当人数不超过三个的时候跳出；\n\n            if(sol_num>3){\n\n                for(int i=1;i<=N;i++){\n\n                    if(sol[i])  cnt++;\n\n                    if(cnt==3){\n\n                        sol[i]=0;\n\n                        sol_num--;\n\n                        cnt=0;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        //输出的时候注意控制空格，为零的位置要直接跳过；\n\n        int tmp=0;\n\n        for(int i=1;i<=N;i++){\n\n            if(sol[i]!=0){\n\n                if(tmp==1)  cout<<\" \";\n\n                tmp=1;\n\n                cout<<sol[i];\n\n            }\n\n        }\n\n        cout<<endl;\n\n    }\n\n    return 0;\n\n}\n\n\n\n```\n\n\n\n\n\n---\n\n该题思想来自网络；\n","slug":"HDU-1276","published":1,"updated":"2020-04-08T03:32:21.384Z","_id":"ck8qr69d200065d3aufvzldkm","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>\n<p>题目描述</p>\n<p>某部队进行新兵队列训练，将新兵从一开始按顺序依次编号，并排成一行横队，训练的规则如下：从头开始一至二报数，凡报到二的出列，剩下的向小序号方向靠拢，再从头开始进行一至三报数，凡报到三的出列，剩下的向小序号方向靠拢，继续从头开始进行一至二报数。。。，以后从头开始轮流进行一至二报数、一至三报数直到剩下的人数不超过三人为止。</p>\n<p>Input</p>\n<p>本题有多个测试数据组，第一行为组数N，接着为N行新兵人数，新兵人数不超过5000。</p>\n<p>Output</p>\n<p>共有N行，分别对应输入的新兵人数，每行输出剩下的新兵最初的编号，编号之间有一个空格。</p>\n</li>\n<li>\n<p>Sample Input</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 20 40</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Sample Output</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 7 19 1 19 37</span><br></pre></td></tr></table></figure>\n<ul>\n<li>代码如下：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">************************/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> N,n,sol_num,cnt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sol[<span class=\"number\">5005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//输入数据的组数；</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//每次都需要把数组清零；</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(sol,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(sol));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//输入新兵的人数；</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cin</span>&gt;&gt;sol_num;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//把初始编号存入数组；</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=sol_num;i++)  sol[i]=i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//把变量sol_num用作每次筛选剩下的人数；</span></span><br><span class=\"line\"></span><br><span class=\"line\">        N=sol_num;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//剩下的人数不超过3个；</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sol_num&gt;<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//当人数不超过3个的时候跳出</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sol_num&gt;<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//每次都循环到N；</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//跳过被赋值为另的位置；</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(sol[i])  cnt++;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//把报数为2的赋值为0，当前长度减1；</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(cnt==<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        sol[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                        sol_num--;</span><br><span class=\"line\"></span><br><span class=\"line\">                        cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//当人数不超过三个的时候跳出；</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sol_num&gt;<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(sol[i])  cnt++;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(cnt==<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        sol[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                        sol_num--;</span><br><span class=\"line\"></span><br><span class=\"line\">                        cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//输出的时候注意控制空格，为零的位置要直接跳过；</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sol[i]!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp==<span class=\"number\">1</span>)  <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                tmp=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;sol[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>该题思想来自网络；</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>\n<p>题目描述</p>\n<p>某部队进行新兵队列训练，将新兵从一开始按顺序依次编号，并排成一行横队，训练的规则如下：从头开始一至二报数，凡报到二的出列，剩下的向小序号方向靠拢，再从头开始进行一至三报数，凡报到三的出列，剩下的向小序号方向靠拢，继续从头开始进行一至二报数。。。，以后从头开始轮流进行一至二报数、一至三报数直到剩下的人数不超过三人为止。</p>\n<p>Input</p>\n<p>本题有多个测试数据组，第一行为组数N，接着为N行新兵人数，新兵人数不超过5000。</p>\n<p>Output</p>\n<p>共有N行，分别对应输入的新兵人数，每行输出剩下的新兵最初的编号，编号之间有一个空格。</p>\n</li>\n<li>\n<p>Sample Input</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 20 40</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Sample Output</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 7 19 1 19 37</span><br></pre></td></tr></table></figure>\n<ul>\n<li>代码如下：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">************************/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> N,n,sol_num,cnt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sol[<span class=\"number\">5005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//输入数据的组数；</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//每次都需要把数组清零；</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(sol,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(sol));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//输入新兵的人数；</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cin</span>&gt;&gt;sol_num;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//把初始编号存入数组；</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=sol_num;i++)  sol[i]=i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//把变量sol_num用作每次筛选剩下的人数；</span></span><br><span class=\"line\"></span><br><span class=\"line\">        N=sol_num;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//剩下的人数不超过3个；</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sol_num&gt;<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//当人数不超过3个的时候跳出</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sol_num&gt;<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//每次都循环到N；</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//跳过被赋值为另的位置；</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(sol[i])  cnt++;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//把报数为2的赋值为0，当前长度减1；</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(cnt==<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        sol[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                        sol_num--;</span><br><span class=\"line\"></span><br><span class=\"line\">                        cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//当人数不超过三个的时候跳出；</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sol_num&gt;<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(sol[i])  cnt++;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(cnt==<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        sol[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                        sol_num--;</span><br><span class=\"line\"></span><br><span class=\"line\">                        cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//输出的时候注意控制空格，为零的位置要直接跳过；</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sol[i]!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp==<span class=\"number\">1</span>)  <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                tmp=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;sol[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>该题思想来自网络；</p>\n"},{"title":"HDU-1072","date":"2019-09-02T08:46:45.000Z","cover":"title.jpg","_content":"\n* 题目描述：\n  首先输入一个N；代表测试数据的个数;\n  然后每个测试数据的开头第一行输入一个n和一个命令（FIFO或FILO<就是先进先出或先进后出>）\n  然后是该测试数据的n行，每行包括“IN”加一个数字（代表入栈或入队）或者一个“OUT”（代表出队或出栈）\n  若已经是空的了遇到“OUT”命令时输出“None”；\n\n* 题目思路：\n  其实就是c++STL的队列和栈的简单应用；\n\n* 代码如下：\n\n  ```c++\n  \n  #include<bits/stdc++.h>\n  using namespace std;\n  int main(){\n    \tint n;\n    \tcin>>n;\n    \twhile(n--){\n        \tint com_num,typ_num;\n        \tcin>>com_num;\n        \tstring com;\n        \tcin>>com;\n        \tif(com==\"FIFO\"){\n            \tqueue<int> q;\n            \tfor(int i=0;i<com_num;i++){\n                \tcin>>com;\n                \tif(com==\"IN\"){\n                    \tcin>>typ_num;\n                    \tq.push(typ_num);\n                \t}\n                \tif(com==\"OUT\"){\n                    \tif(q.empty()){\n                        \tcout<<\"None\"<<endl;\n                    \t}\n                    \telse{\n                        \tcout<<q.front()<<endl;\n                        \tq.pop();\n                    \t}\n                \t}\n            \t}\n        \t}\n        \tif(com==\"FILO\"){\n            stack<int> st;\n            for(int i=0;i<com_num;i++){\n                cin>>com;\n                if(com==\"IN\"){\n                    cin>>typ_num;\n                    st.push(typ_num);\n                \t}\n                \tif(com==\"OUT\"){\n                    \tif(st.empty()){\n                        \tcout<<\"None\"<<endl;\n                    \t}\n                    \telse{\n                        \tcout<<st.top()<<endl;\n                        \tst.pop();\n                    \t}\n                \t}\n            \t}\n        \t}\n    \t}\n    \treturn 0;\n  }\n  ```\n","source":"_posts/HDU-1072.md","raw":"---\ntitle: HDU-1072\ndate: 2019-09-02 16:46:45\ncover: title.jpg\ntags: \n- 题解\n- HDU\n---\n\n* 题目描述：\n  首先输入一个N；代表测试数据的个数;\n  然后每个测试数据的开头第一行输入一个n和一个命令（FIFO或FILO<就是先进先出或先进后出>）\n  然后是该测试数据的n行，每行包括“IN”加一个数字（代表入栈或入队）或者一个“OUT”（代表出队或出栈）\n  若已经是空的了遇到“OUT”命令时输出“None”；\n\n* 题目思路：\n  其实就是c++STL的队列和栈的简单应用；\n\n* 代码如下：\n\n  ```c++\n  \n  #include<bits/stdc++.h>\n  using namespace std;\n  int main(){\n    \tint n;\n    \tcin>>n;\n    \twhile(n--){\n        \tint com_num,typ_num;\n        \tcin>>com_num;\n        \tstring com;\n        \tcin>>com;\n        \tif(com==\"FIFO\"){\n            \tqueue<int> q;\n            \tfor(int i=0;i<com_num;i++){\n                \tcin>>com;\n                \tif(com==\"IN\"){\n                    \tcin>>typ_num;\n                    \tq.push(typ_num);\n                \t}\n                \tif(com==\"OUT\"){\n                    \tif(q.empty()){\n                        \tcout<<\"None\"<<endl;\n                    \t}\n                    \telse{\n                        \tcout<<q.front()<<endl;\n                        \tq.pop();\n                    \t}\n                \t}\n            \t}\n        \t}\n        \tif(com==\"FILO\"){\n            stack<int> st;\n            for(int i=0;i<com_num;i++){\n                cin>>com;\n                if(com==\"IN\"){\n                    cin>>typ_num;\n                    st.push(typ_num);\n                \t}\n                \tif(com==\"OUT\"){\n                    \tif(st.empty()){\n                        \tcout<<\"None\"<<endl;\n                    \t}\n                    \telse{\n                        \tcout<<st.top()<<endl;\n                        \tst.pop();\n                    \t}\n                \t}\n            \t}\n        \t}\n    \t}\n    \treturn 0;\n  }\n  ```\n","slug":"HDU-1072","published":1,"updated":"2020-04-08T03:30:43.785Z","_id":"ck8qr69d300075d3a5tzw7156","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>\n<p>题目描述：<br>\n首先输入一个N；代表测试数据的个数;<br>\n然后每个测试数据的开头第一行输入一个n和一个命令（FIFO或FILO&lt;就是先进先出或先进后出&gt;）<br>\n然后是该测试数据的n行，每行包括“IN”加一个数字（代表入栈或入队）或者一个“OUT”（代表出队或出栈）<br>\n若已经是空的了遇到“OUT”命令时输出“None”；</p>\n</li>\n<li>\n<p>题目思路：<br>\n其实就是c++STL的队列和栈的简单应用；</p>\n</li>\n<li>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">  \t<span class=\"built_in\">cin</span>&gt;&gt;n;</span><br><span class=\"line\">  \t<span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">int</span> com_num,typ_num;</span><br><span class=\"line\">      \t<span class=\"built_in\">cin</span>&gt;&gt;com_num;</span><br><span class=\"line\">      \t<span class=\"built_in\">string</span> com;</span><br><span class=\"line\">      \t<span class=\"built_in\">cin</span>&gt;&gt;com;</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span>(com==<span class=\"string\">\"FIFO\"</span>)&#123;</span><br><span class=\"line\">          \t<span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">          \t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;com_num;i++)&#123;</span><br><span class=\"line\">              \t<span class=\"built_in\">cin</span>&gt;&gt;com;</span><br><span class=\"line\">              \t<span class=\"keyword\">if</span>(com==<span class=\"string\">\"IN\"</span>)&#123;</span><br><span class=\"line\">                  \t<span class=\"built_in\">cin</span>&gt;&gt;typ_num;</span><br><span class=\"line\">                  \tq.push(typ_num);</span><br><span class=\"line\">              \t&#125;</span><br><span class=\"line\">              \t<span class=\"keyword\">if</span>(com==<span class=\"string\">\"OUT\"</span>)&#123;</span><br><span class=\"line\">                  \t<span class=\"keyword\">if</span>(q.empty())&#123;</span><br><span class=\"line\">                      \t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"None\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                  \t&#125;</span><br><span class=\"line\">                  \t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                      \t<span class=\"built_in\">cout</span>&lt;&lt;q.front()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                      \tq.pop();</span><br><span class=\"line\">                  \t&#125;</span><br><span class=\"line\">              \t&#125;</span><br><span class=\"line\">          \t&#125;</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span>(com==<span class=\"string\">\"FILO\"</span>)&#123;</span><br><span class=\"line\">          <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;com_num;i++)&#123;</span><br><span class=\"line\">              <span class=\"built_in\">cin</span>&gt;&gt;com;</span><br><span class=\"line\">              <span class=\"keyword\">if</span>(com==<span class=\"string\">\"IN\"</span>)&#123;</span><br><span class=\"line\">                  <span class=\"built_in\">cin</span>&gt;&gt;typ_num;</span><br><span class=\"line\">                  st.push(typ_num);</span><br><span class=\"line\">              \t&#125;</span><br><span class=\"line\">              \t<span class=\"keyword\">if</span>(com==<span class=\"string\">\"OUT\"</span>)&#123;</span><br><span class=\"line\">                  \t<span class=\"keyword\">if</span>(st.empty())&#123;</span><br><span class=\"line\">                      \t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"None\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                  \t&#125;</span><br><span class=\"line\">                  \t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                      \t<span class=\"built_in\">cout</span>&lt;&lt;st.top()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                      \tst.pop();</span><br><span class=\"line\">                  \t&#125;</span><br><span class=\"line\">              \t&#125;</span><br><span class=\"line\">          \t&#125;</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>\n<p>题目描述：<br>\n首先输入一个N；代表测试数据的个数;<br>\n然后每个测试数据的开头第一行输入一个n和一个命令（FIFO或FILO&lt;就是先进先出或先进后出&gt;）<br>\n然后是该测试数据的n行，每行包括“IN”加一个数字（代表入栈或入队）或者一个“OUT”（代表出队或出栈）<br>\n若已经是空的了遇到“OUT”命令时输出“None”；</p>\n</li>\n<li>\n<p>题目思路：<br>\n其实就是c++STL的队列和栈的简单应用；</p>\n</li>\n<li>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">  \t<span class=\"built_in\">cin</span>&gt;&gt;n;</span><br><span class=\"line\">  \t<span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">int</span> com_num,typ_num;</span><br><span class=\"line\">      \t<span class=\"built_in\">cin</span>&gt;&gt;com_num;</span><br><span class=\"line\">      \t<span class=\"built_in\">string</span> com;</span><br><span class=\"line\">      \t<span class=\"built_in\">cin</span>&gt;&gt;com;</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span>(com==<span class=\"string\">\"FIFO\"</span>)&#123;</span><br><span class=\"line\">          \t<span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">          \t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;com_num;i++)&#123;</span><br><span class=\"line\">              \t<span class=\"built_in\">cin</span>&gt;&gt;com;</span><br><span class=\"line\">              \t<span class=\"keyword\">if</span>(com==<span class=\"string\">\"IN\"</span>)&#123;</span><br><span class=\"line\">                  \t<span class=\"built_in\">cin</span>&gt;&gt;typ_num;</span><br><span class=\"line\">                  \tq.push(typ_num);</span><br><span class=\"line\">              \t&#125;</span><br><span class=\"line\">              \t<span class=\"keyword\">if</span>(com==<span class=\"string\">\"OUT\"</span>)&#123;</span><br><span class=\"line\">                  \t<span class=\"keyword\">if</span>(q.empty())&#123;</span><br><span class=\"line\">                      \t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"None\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                  \t&#125;</span><br><span class=\"line\">                  \t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                      \t<span class=\"built_in\">cout</span>&lt;&lt;q.front()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                      \tq.pop();</span><br><span class=\"line\">                  \t&#125;</span><br><span class=\"line\">              \t&#125;</span><br><span class=\"line\">          \t&#125;</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span>(com==<span class=\"string\">\"FILO\"</span>)&#123;</span><br><span class=\"line\">          <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;com_num;i++)&#123;</span><br><span class=\"line\">              <span class=\"built_in\">cin</span>&gt;&gt;com;</span><br><span class=\"line\">              <span class=\"keyword\">if</span>(com==<span class=\"string\">\"IN\"</span>)&#123;</span><br><span class=\"line\">                  <span class=\"built_in\">cin</span>&gt;&gt;typ_num;</span><br><span class=\"line\">                  st.push(typ_num);</span><br><span class=\"line\">              \t&#125;</span><br><span class=\"line\">              \t<span class=\"keyword\">if</span>(com==<span class=\"string\">\"OUT\"</span>)&#123;</span><br><span class=\"line\">                  \t<span class=\"keyword\">if</span>(st.empty())&#123;</span><br><span class=\"line\">                      \t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"None\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                  \t&#125;</span><br><span class=\"line\">                  \t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                      \t<span class=\"built_in\">cout</span>&lt;&lt;st.top()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                      \tst.pop();</span><br><span class=\"line\">                  \t&#125;</span><br><span class=\"line\">              \t&#125;</span><br><span class=\"line\">          \t&#125;</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"CPU信息获取","date":"2019-09-02T08:50:49.000Z","cover":"title.jpg","mathjax":"trues","_content":"\n* 准备知识\n\n  1. `/proc`文件系统是一个伪文件系统，该文件系统中存储着内核控制相关信息，通俗点说就是这个目录是虚拟的，它受内核直接控制，存储与内核控制相关的数据，与其他目录不同的是`/proc`目录不是真实存储在硬盘中的，它的数据存储在内存中，但是由于它和其他目录一样把自己注册到虚拟文件系统层了，所以我们还是能看到这个目录相关信息，然而只有虚拟文件系统层调用它的时候，他才会建立相关文件和目录并与内核沟通获取相关信息。\n\n  2. 上面我们说道`/proc` 文件系统存储着内核控制相关信息的目录，该目录下的`/proc/stat`文件存储的是`CPU`相关信息，我们想要获取`CPU`相关信息最直接和最快速的方式就是读取该文件，其实`Linux下`很多的工具都是读取的这个文件。在这个文件中包含了所有的`CPU`活动信息，并且该文件中所有值都是从系统启动算起直到访问文件的这一刻的数据。如下就是某一刻`/proc/stat`文件中的数据：\n\n     ```bash \n     cpu  499312 1086 227835 10498412 3803 0 10904 0 0 0\n     cpu0 125361 278 56675 2626355 450 0 2242 0 0 0\n     cpu1 124704 288 57768 2627741 350 0 2168 0 0 0\n     cpu2 130284 261 55543 2620559 2442 0 1762 0 0 0\n     cpu3 118961 258 57848 2623755 560 0 4731 0 0 0\n     intr 46393945 9 924 0 0 0 0 0 0 1 14751 0 0 215 0 0 0 139800 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4476 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 408029 0 283839 7963609 40 945 1535489 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n     ctxt 124171702\n     btime 1539737966\n     processes 626819\n     procs_running 4\n     procs_blocked 0\n     softirq 27922585 9163685 6158929 26 485 278010 0 160301 6495615 0 5665534\n     ```\n\n     > 数据单位：jiffies\n\n     * 如上数据中从cpu到cpu3五行（从左到右按顺序）每一列的含义如下：\n\n       1. `user`：如上**499312**、**125361**、**124704**等，用户态时间。\n       2. `nice`：如上**1086**等第二列数据，`nice`值为负数的进程所占时间。\n       3. `system`：如上第三列数据，核心时间。\n       4. `idle`：如上第四列数据，除硬盘IO等待时间之外的时间。\n       5. `iowait`：如上第五列数据，硬盘IO等待时间。\n       6. `irq`：如上第六列数据，硬中断时间。\n       7. `softirq`如上第七列数据，软中断时间。\n\n       $$\n       CPU_{time}=user_{line:1} +nice_{line:2} + system_{line:3} + idle_{line:4} + iowait_{line:5} + irq_{line:6} + sortirq_{line:7}\n       $$\n\n     * 剩下的几行：\n\n       1. `initr`：中断次数\n       2. `ctxt`：交换次数\n       3. `btime`:从系统启动到访问文件为止的时间。\n       4. `processes`：任务数。\n       5. `procs_runing`：当前运行队列的任务数。\n       6. `procs_blocked`：当前被阻塞的任务数。\n\n     * `CPU`利用率计算可以采用两点采样取差值的方式：\n\n       $$\n       CPU_{usage} = (idle_{第二次采样} - idle_{第一次采样}) / (CPU_{time第二次采样} - CPU_{time第一次采样}) * 100\n       $$\n\n  3. CPU温度的获取：\n\n     cpu温度存储在`/sys/class/thermal/thermal_zone0/temp`中，读取出的数值需要除以1000。\n\n  4. bash 工具：\n\n     1. `cat`：工具用来强制读取一个文件。\n     2. `gerp`：工具用来筛选数据。\n     3. `awk`：用来处理数据。\n     4. `uptime`：获取cpu负载信息\n\n  5. bash 数值计算：\n\n     bash中的数值计算比较方便的方式是双小括号：\n\n     ```bash\n     num=0\n     ((num++)) # 在双小括号中可以正常使用C语言的数值计算语法\n     echo ${num}\n     \n     # 结果输出---------------\n     1\n     ```\n\n* 代码\n```bash\n#!/bin/bash\n\ntime_and_load=`date +\"%Y-%m-%d__%H:%M:%S \"``uptime | tr -s \" \" \"\\n\" | tr -s \",\" \" \" | awk NF | tail -3 | tr -s \"\\n\" \" \"`\n\n# 0.5s 前\n# 开机后总时间\ncpu_local1=`cat /proc/stat | grep  -w \"cpu\" | awk '{printf(\"%d\", $2 + $3 + $4 + $5 + $6 + $7 + 8);}'`\n# 开机后累计空闲\ncpu_idle1=`cat /proc/stat | grep  -w \"cpu\" | awk '{printf(\"%d\", $5);}'`\n\nsleep 0.5s\n\n# 0.5s 后\n# 开机后总时间\ncpu_local2=`cat /proc/stat | grep  -w \"cpu\" | awk '{printf(\"%d\", $2 + $3 + $4 + $5 + $6 + $7 + 8);}'`\n# 开机后累计空闲\ncpu_idle2=`cat /proc/stat | grep  -w \"cpu\" | awk '{printf(\"%d\", $5);}'`\n\n# 0.5s 内\n((cpu_local = $cpu_local2 - $cpu_local1))\n((cpu_idle = $cpu_idle2 - $cpu_idle1))\n\n# 计算cpu占用率\ncpu_occu=`echo \"$cpu_local $cpu_idle\" | awk '{printf(\"%.2f%%\", (1 - $2 / $1) * 100);}'`\n\n# CPU温度\ncpu_temp_info=`cat /sys/class/thermal/thermal_zone0/temp | awk '{\n        if ($1 >= 1000 && $1 < 50000) {\n            printf(\"%.2f normal\", $1 / 1000);\n        }\n        else if ($1 >= 50000 && $1 <= 70000) {\n            printf(\"%.2f note\", $1 / 1000);\n        }\n        else {\n            printf(\"%.2f warning\", $1 / 1000);\n        }\n    }'`\n\n\necho \"${time_and_load}${cpu_occu} ${cpu_temp_info}\"\n```\n","source":"_posts/CPU信息获取.md","raw":"---\ntitle: CPU信息获取\ndate: 2019-09-02 16:50:49\ncover: title.jpg\nmathjax: trues\ntags:\n- script\n- linux\n---\n\n* 准备知识\n\n  1. `/proc`文件系统是一个伪文件系统，该文件系统中存储着内核控制相关信息，通俗点说就是这个目录是虚拟的，它受内核直接控制，存储与内核控制相关的数据，与其他目录不同的是`/proc`目录不是真实存储在硬盘中的，它的数据存储在内存中，但是由于它和其他目录一样把自己注册到虚拟文件系统层了，所以我们还是能看到这个目录相关信息，然而只有虚拟文件系统层调用它的时候，他才会建立相关文件和目录并与内核沟通获取相关信息。\n\n  2. 上面我们说道`/proc` 文件系统存储着内核控制相关信息的目录，该目录下的`/proc/stat`文件存储的是`CPU`相关信息，我们想要获取`CPU`相关信息最直接和最快速的方式就是读取该文件，其实`Linux下`很多的工具都是读取的这个文件。在这个文件中包含了所有的`CPU`活动信息，并且该文件中所有值都是从系统启动算起直到访问文件的这一刻的数据。如下就是某一刻`/proc/stat`文件中的数据：\n\n     ```bash \n     cpu  499312 1086 227835 10498412 3803 0 10904 0 0 0\n     cpu0 125361 278 56675 2626355 450 0 2242 0 0 0\n     cpu1 124704 288 57768 2627741 350 0 2168 0 0 0\n     cpu2 130284 261 55543 2620559 2442 0 1762 0 0 0\n     cpu3 118961 258 57848 2623755 560 0 4731 0 0 0\n     intr 46393945 9 924 0 0 0 0 0 0 1 14751 0 0 215 0 0 0 139800 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4476 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 408029 0 283839 7963609 40 945 1535489 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n     ctxt 124171702\n     btime 1539737966\n     processes 626819\n     procs_running 4\n     procs_blocked 0\n     softirq 27922585 9163685 6158929 26 485 278010 0 160301 6495615 0 5665534\n     ```\n\n     > 数据单位：jiffies\n\n     * 如上数据中从cpu到cpu3五行（从左到右按顺序）每一列的含义如下：\n\n       1. `user`：如上**499312**、**125361**、**124704**等，用户态时间。\n       2. `nice`：如上**1086**等第二列数据，`nice`值为负数的进程所占时间。\n       3. `system`：如上第三列数据，核心时间。\n       4. `idle`：如上第四列数据，除硬盘IO等待时间之外的时间。\n       5. `iowait`：如上第五列数据，硬盘IO等待时间。\n       6. `irq`：如上第六列数据，硬中断时间。\n       7. `softirq`如上第七列数据，软中断时间。\n\n       $$\n       CPU_{time}=user_{line:1} +nice_{line:2} + system_{line:3} + idle_{line:4} + iowait_{line:5} + irq_{line:6} + sortirq_{line:7}\n       $$\n\n     * 剩下的几行：\n\n       1. `initr`：中断次数\n       2. `ctxt`：交换次数\n       3. `btime`:从系统启动到访问文件为止的时间。\n       4. `processes`：任务数。\n       5. `procs_runing`：当前运行队列的任务数。\n       6. `procs_blocked`：当前被阻塞的任务数。\n\n     * `CPU`利用率计算可以采用两点采样取差值的方式：\n\n       $$\n       CPU_{usage} = (idle_{第二次采样} - idle_{第一次采样}) / (CPU_{time第二次采样} - CPU_{time第一次采样}) * 100\n       $$\n\n  3. CPU温度的获取：\n\n     cpu温度存储在`/sys/class/thermal/thermal_zone0/temp`中，读取出的数值需要除以1000。\n\n  4. bash 工具：\n\n     1. `cat`：工具用来强制读取一个文件。\n     2. `gerp`：工具用来筛选数据。\n     3. `awk`：用来处理数据。\n     4. `uptime`：获取cpu负载信息\n\n  5. bash 数值计算：\n\n     bash中的数值计算比较方便的方式是双小括号：\n\n     ```bash\n     num=0\n     ((num++)) # 在双小括号中可以正常使用C语言的数值计算语法\n     echo ${num}\n     \n     # 结果输出---------------\n     1\n     ```\n\n* 代码\n```bash\n#!/bin/bash\n\ntime_and_load=`date +\"%Y-%m-%d__%H:%M:%S \"``uptime | tr -s \" \" \"\\n\" | tr -s \",\" \" \" | awk NF | tail -3 | tr -s \"\\n\" \" \"`\n\n# 0.5s 前\n# 开机后总时间\ncpu_local1=`cat /proc/stat | grep  -w \"cpu\" | awk '{printf(\"%d\", $2 + $3 + $4 + $5 + $6 + $7 + 8);}'`\n# 开机后累计空闲\ncpu_idle1=`cat /proc/stat | grep  -w \"cpu\" | awk '{printf(\"%d\", $5);}'`\n\nsleep 0.5s\n\n# 0.5s 后\n# 开机后总时间\ncpu_local2=`cat /proc/stat | grep  -w \"cpu\" | awk '{printf(\"%d\", $2 + $3 + $4 + $5 + $6 + $7 + 8);}'`\n# 开机后累计空闲\ncpu_idle2=`cat /proc/stat | grep  -w \"cpu\" | awk '{printf(\"%d\", $5);}'`\n\n# 0.5s 内\n((cpu_local = $cpu_local2 - $cpu_local1))\n((cpu_idle = $cpu_idle2 - $cpu_idle1))\n\n# 计算cpu占用率\ncpu_occu=`echo \"$cpu_local $cpu_idle\" | awk '{printf(\"%.2f%%\", (1 - $2 / $1) * 100);}'`\n\n# CPU温度\ncpu_temp_info=`cat /sys/class/thermal/thermal_zone0/temp | awk '{\n        if ($1 >= 1000 && $1 < 50000) {\n            printf(\"%.2f normal\", $1 / 1000);\n        }\n        else if ($1 >= 50000 && $1 <= 70000) {\n            printf(\"%.2f note\", $1 / 1000);\n        }\n        else {\n            printf(\"%.2f warning\", $1 / 1000);\n        }\n    }'`\n\n\necho \"${time_and_load}${cpu_occu} ${cpu_temp_info}\"\n```\n","slug":"CPU信息获取","published":1,"updated":"2020-04-08T03:28:58.214Z","_id":"ck8qr69d400095d3ajohn3de9","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>\n<p>准备知识</p>\n<ol>\n<li>\n<p><code>/proc</code>文件系统是一个伪文件系统，该文件系统中存储着内核控制相关信息，通俗点说就是这个目录是虚拟的，它受内核直接控制，存储与内核控制相关的数据，与其他目录不同的是<code>/proc</code>目录不是真实存储在硬盘中的，它的数据存储在内存中，但是由于它和其他目录一样把自己注册到虚拟文件系统层了，所以我们还是能看到这个目录相关信息，然而只有虚拟文件系统层调用它的时候，他才会建立相关文件和目录并与内核沟通获取相关信息。</p>\n</li>\n<li>\n<p>上面我们说道<code>/proc</code> 文件系统存储着内核控制相关信息的目录，该目录下的<code>/proc/stat</code>文件存储的是<code>CPU</code>相关信息，我们想要获取<code>CPU</code>相关信息最直接和最快速的方式就是读取该文件，其实<code>Linux下</code>很多的工具都是读取的这个文件。在这个文件中包含了所有的<code>CPU</code>活动信息，并且该文件中所有值都是从系统启动算起直到访问文件的这一刻的数据。如下就是某一刻<code>/proc/stat</code>文件中的数据：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpu  499312 1086 227835 10498412 3803 0 10904 0 0 0</span><br><span class=\"line\">cpu0 125361 278 56675 2626355 450 0 2242 0 0 0</span><br><span class=\"line\">cpu1 124704 288 57768 2627741 350 0 2168 0 0 0</span><br><span class=\"line\">cpu2 130284 261 55543 2620559 2442 0 1762 0 0 0</span><br><span class=\"line\">cpu3 118961 258 57848 2623755 560 0 4731 0 0 0</span><br><span class=\"line\">intr 46393945 9 924 0 0 0 0 0 0 1 14751 0 0 215 0 0 0 139800 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4476 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 408029 0 283839 7963609 40 945 1535489 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class=\"line\">ctxt 124171702</span><br><span class=\"line\">btime 1539737966</span><br><span class=\"line\">processes 626819</span><br><span class=\"line\">procs_running 4</span><br><span class=\"line\">procs_blocked 0</span><br><span class=\"line\">softirq 27922585 9163685 6158929 26 485 278010 0 160301 6495615 0 5665534</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>数据单位：jiffies</p>\n</blockquote>\n<ul>\n<li>\n<p>如上数据中从cpu到cpu3五行（从左到右按顺序）每一列的含义如下：</p>\n<ol>\n<li><code>user</code>：如上<strong>499312</strong>、<strong>125361</strong>、<strong>124704</strong>等，用户态时间。</li>\n<li><code>nice</code>：如上<strong>1086</strong>等第二列数据，<code>nice</code>值为负数的进程所占时间。</li>\n<li><code>system</code>：如上第三列数据，核心时间。</li>\n<li><code>idle</code>：如上第四列数据，除硬盘IO等待时间之外的时间。</li>\n<li><code>iowait</code>：如上第五列数据，硬盘IO等待时间。</li>\n<li><code>irq</code>：如上第六列数据，硬中断时间。</li>\n<li><code>softirq</code>如上第七列数据，软中断时间。</li>\n</ol>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>C</mi><mi>P</mi><msub><mi>U</mi><mrow><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow></msub><mo>=</mo><mi>u</mi><mi>s</mi><mi>e</mi><msub><mi>r</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>:</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>n</mi><mi>i</mi><mi>c</mi><msub><mi>e</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>:</mo><mn>2</mn></mrow></msub><mo>+</mo><mi>s</mi><mi>y</mi><mi>s</mi><mi>t</mi><mi>e</mi><msub><mi>m</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>:</mo><mn>3</mn></mrow></msub><mo>+</mo><mi>i</mi><mi>d</mi><mi>l</mi><msub><mi>e</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>:</mo><mn>4</mn></mrow></msub><mo>+</mo><mi>i</mi><mi>o</mi><mi>w</mi><mi>a</mi><mi>i</mi><msub><mi>t</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>:</mo><mn>5</mn></mrow></msub><mo>+</mo><mi>i</mi><mi>r</mi><msub><mi>q</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>:</mo><mn>6</mn></mrow></msub><mo>+</mo><mi>s</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>i</mi><mi>r</mi><msub><mi>q</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>:</mo><mn>7</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">CPU_{time}=user_{line:1} +nice_{line:2} + system_{line:3} + idle_{line:4} + iowait_{line:5} + irq_{line:6} + sortirq_{line:7}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.10903em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\">t</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">m</span><span class=\"mord mathit\">e</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mrel\">=</span><span class=\"mord mathit\">u</span><span class=\"mord mathit\">s</span><span class=\"mord mathit\">e</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.02778em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">e</span><span class=\"mrel\">:</span><span class=\"mord mathrm\">1</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">c</span><span class=\"mord\"><span class=\"mord mathit\">e</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">e</span><span class=\"mrel\">:</span><span class=\"mord mathrm\">2</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathit\">s</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathit\">s</span><span class=\"mord mathit\">t</span><span class=\"mord mathit\">e</span><span class=\"mord\"><span class=\"mord mathit\">m</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">e</span><span class=\"mrel\">:</span><span class=\"mord mathrm\">3</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\"><span class=\"mord mathit\">e</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">e</span><span class=\"mrel\">:</span><span class=\"mord mathrm\">4</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">o</span><span class=\"mord mathit\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathit\">a</span><span class=\"mord mathit\">i</span><span class=\"mord\"><span class=\"mord mathit\">t</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">e</span><span class=\"mrel\">:</span><span class=\"mord mathrm\">5</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">q</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.03588em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">e</span><span class=\"mrel\">:</span><span class=\"mord mathrm\">6</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathit\">s</span><span class=\"mord mathit\">o</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathit\">t</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">q</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.03588em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">e</span><span class=\"mrel\">:</span><span class=\"mord mathrm\">7</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span></span></p>\n</li>\n<li>\n<p>剩下的几行：</p>\n<ol>\n<li><code>initr</code>：中断次数</li>\n<li><code>ctxt</code>：交换次数</li>\n<li><code>btime</code>:从系统启动到访问文件为止的时间。</li>\n<li><code>processes</code>：任务数。</li>\n<li><code>procs_runing</code>：当前运行队列的任务数。</li>\n<li><code>procs_blocked</code>：当前被阻塞的任务数。</li>\n</ol>\n</li>\n<li>\n<p><code>CPU</code>利用率计算可以采用两点采样取差值的方式：</p>\nCPU_{usage} = (idle_{第二次采样} - idle_{第一次采样}) / (CPU_{time第二次采样} - CPU_{time第一次采样}) * 100\n\n</li>\n</ul>\n</li>\n<li>\n<p>CPU温度的获取：</p>\n<p>cpu温度存储在<code>/sys/class/thermal/thermal_zone0/temp</code>中，读取出的数值需要除以1000。</p>\n</li>\n<li>\n<p>bash 工具：</p>\n<ol>\n<li><code>cat</code>：工具用来强制读取一个文件。</li>\n<li><code>gerp</code>：工具用来筛选数据。</li>\n<li><code>awk</code>：用来处理数据。</li>\n<li><code>uptime</code>：获取cpu负载信息</li>\n</ol>\n</li>\n<li>\n<p>bash 数值计算：</p>\n<p>bash中的数值计算比较方便的方式是双小括号：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num=0</span><br><span class=\"line\">((num++)) <span class=\"comment\"># 在双小括号中可以正常使用C语言的数值计算语法</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;num&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结果输出---------------</span></span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p>代码</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">time_and_load=`date +<span class=\"string\">\"%Y-%m-%d__%H:%M:%S \"</span>``uptime | tr -s <span class=\"string\">\" \"</span> <span class=\"string\">\"\\n\"</span> | tr -s <span class=\"string\">\",\"</span> <span class=\"string\">\" \"</span> | awk NF | tail -3 | tr -s <span class=\"string\">\"\\n\"</span> <span class=\"string\">\" \"</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0.5s 前</span></span><br><span class=\"line\"><span class=\"comment\"># 开机后总时间</span></span><br><span class=\"line\">cpu_local1=`cat /proc/<span class=\"built_in\">stat</span> | grep  -w <span class=\"string\">\"cpu\"</span> | awk <span class=\"string\">'&#123;printf(\"%d\", $2 + $3 + $4 + $5 + $6 + $7 + 8);&#125;'</span>`</span><br><span class=\"line\"><span class=\"comment\"># 开机后累计空闲</span></span><br><span class=\"line\">cpu_idle1=`cat /proc/<span class=\"built_in\">stat</span> | grep  -w <span class=\"string\">\"cpu\"</span> | awk <span class=\"string\">'&#123;printf(\"%d\", $5);&#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">sleep 0.5s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0.5s 后</span></span><br><span class=\"line\"><span class=\"comment\"># 开机后总时间</span></span><br><span class=\"line\">cpu_local2=`cat /proc/<span class=\"built_in\">stat</span> | grep  -w <span class=\"string\">\"cpu\"</span> | awk <span class=\"string\">'&#123;printf(\"%d\", $2 + $3 + $4 + $5 + $6 + $7 + 8);&#125;'</span>`</span><br><span class=\"line\"><span class=\"comment\"># 开机后累计空闲</span></span><br><span class=\"line\">cpu_idle2=`cat /proc/<span class=\"built_in\">stat</span> | grep  -w <span class=\"string\">\"cpu\"</span> | awk <span class=\"string\">'&#123;printf(\"%d\", $5);&#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0.5s 内</span></span><br><span class=\"line\">((cpu_local = <span class=\"variable\">$cpu_local2</span> - <span class=\"variable\">$cpu_local1</span>))</span><br><span class=\"line\">((cpu_idle = <span class=\"variable\">$cpu_idle2</span> - <span class=\"variable\">$cpu_idle1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算cpu占用率</span></span><br><span class=\"line\">cpu_occu=`<span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$cpu_local</span> <span class=\"variable\">$cpu_idle</span>\"</span> | awk <span class=\"string\">'&#123;printf(\"%.2f%%\", (1 - $2 / $1) * 100);&#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CPU温度</span></span><br><span class=\"line\">cpu_temp_info=`cat /sys/class/thermal/thermal_zone0/temp | awk <span class=\"string\">'&#123;</span></span><br><span class=\"line\"><span class=\"string\">        if ($1 &gt;= 1000 &amp;&amp; $1 &lt; 50000) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            printf(\"%.2f normal\", $1 / 1000);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        else if ($1 &gt;= 50000 &amp;&amp; $1 &lt;= 70000) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            printf(\"%.2f note\", $1 / 1000);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        else &#123;</span></span><br><span class=\"line\"><span class=\"string\">            printf(\"%.2f warning\", $1 / 1000);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$&#123;time_and_load&#125;</span><span class=\"variable\">$&#123;cpu_occu&#125;</span> <span class=\"variable\">$&#123;cpu_temp_info&#125;</span>\"</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>\n<p>准备知识</p>\n<ol>\n<li>\n<p><code>/proc</code>文件系统是一个伪文件系统，该文件系统中存储着内核控制相关信息，通俗点说就是这个目录是虚拟的，它受内核直接控制，存储与内核控制相关的数据，与其他目录不同的是<code>/proc</code>目录不是真实存储在硬盘中的，它的数据存储在内存中，但是由于它和其他目录一样把自己注册到虚拟文件系统层了，所以我们还是能看到这个目录相关信息，然而只有虚拟文件系统层调用它的时候，他才会建立相关文件和目录并与内核沟通获取相关信息。</p>\n</li>\n<li>\n<p>上面我们说道<code>/proc</code> 文件系统存储着内核控制相关信息的目录，该目录下的<code>/proc/stat</code>文件存储的是<code>CPU</code>相关信息，我们想要获取<code>CPU</code>相关信息最直接和最快速的方式就是读取该文件，其实<code>Linux下</code>很多的工具都是读取的这个文件。在这个文件中包含了所有的<code>CPU</code>活动信息，并且该文件中所有值都是从系统启动算起直到访问文件的这一刻的数据。如下就是某一刻<code>/proc/stat</code>文件中的数据：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpu  499312 1086 227835 10498412 3803 0 10904 0 0 0</span><br><span class=\"line\">cpu0 125361 278 56675 2626355 450 0 2242 0 0 0</span><br><span class=\"line\">cpu1 124704 288 57768 2627741 350 0 2168 0 0 0</span><br><span class=\"line\">cpu2 130284 261 55543 2620559 2442 0 1762 0 0 0</span><br><span class=\"line\">cpu3 118961 258 57848 2623755 560 0 4731 0 0 0</span><br><span class=\"line\">intr 46393945 9 924 0 0 0 0 0 0 1 14751 0 0 215 0 0 0 139800 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4476 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 408029 0 283839 7963609 40 945 1535489 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class=\"line\">ctxt 124171702</span><br><span class=\"line\">btime 1539737966</span><br><span class=\"line\">processes 626819</span><br><span class=\"line\">procs_running 4</span><br><span class=\"line\">procs_blocked 0</span><br><span class=\"line\">softirq 27922585 9163685 6158929 26 485 278010 0 160301 6495615 0 5665534</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>数据单位：jiffies</p>\n</blockquote>\n<ul>\n<li>\n<p>如上数据中从cpu到cpu3五行（从左到右按顺序）每一列的含义如下：</p>\n<ol>\n<li><code>user</code>：如上<strong>499312</strong>、<strong>125361</strong>、<strong>124704</strong>等，用户态时间。</li>\n<li><code>nice</code>：如上<strong>1086</strong>等第二列数据，<code>nice</code>值为负数的进程所占时间。</li>\n<li><code>system</code>：如上第三列数据，核心时间。</li>\n<li><code>idle</code>：如上第四列数据，除硬盘IO等待时间之外的时间。</li>\n<li><code>iowait</code>：如上第五列数据，硬盘IO等待时间。</li>\n<li><code>irq</code>：如上第六列数据，硬中断时间。</li>\n<li><code>softirq</code>如上第七列数据，软中断时间。</li>\n</ol>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>C</mi><mi>P</mi><msub><mi>U</mi><mrow><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow></msub><mo>=</mo><mi>u</mi><mi>s</mi><mi>e</mi><msub><mi>r</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>:</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>n</mi><mi>i</mi><mi>c</mi><msub><mi>e</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>:</mo><mn>2</mn></mrow></msub><mo>+</mo><mi>s</mi><mi>y</mi><mi>s</mi><mi>t</mi><mi>e</mi><msub><mi>m</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>:</mo><mn>3</mn></mrow></msub><mo>+</mo><mi>i</mi><mi>d</mi><mi>l</mi><msub><mi>e</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>:</mo><mn>4</mn></mrow></msub><mo>+</mo><mi>i</mi><mi>o</mi><mi>w</mi><mi>a</mi><mi>i</mi><msub><mi>t</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>:</mo><mn>5</mn></mrow></msub><mo>+</mo><mi>i</mi><mi>r</mi><msub><mi>q</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>:</mo><mn>6</mn></mrow></msub><mo>+</mo><mi>s</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>i</mi><mi>r</mi><msub><mi>q</mi><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>:</mo><mn>7</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">CPU_{time}=user_{line:1} +nice_{line:2} + system_{line:3} + idle_{line:4} + iowait_{line:5} + irq_{line:6} + sortirq_{line:7}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.10903em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\">t</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">m</span><span class=\"mord mathit\">e</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mrel\">=</span><span class=\"mord mathit\">u</span><span class=\"mord mathit\">s</span><span class=\"mord mathit\">e</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.02778em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">e</span><span class=\"mrel\">:</span><span class=\"mord mathrm\">1</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">c</span><span class=\"mord\"><span class=\"mord mathit\">e</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">e</span><span class=\"mrel\">:</span><span class=\"mord mathrm\">2</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathit\">s</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathit\">s</span><span class=\"mord mathit\">t</span><span class=\"mord mathit\">e</span><span class=\"mord\"><span class=\"mord mathit\">m</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">e</span><span class=\"mrel\">:</span><span class=\"mord mathrm\">3</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\"><span class=\"mord mathit\">e</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">e</span><span class=\"mrel\">:</span><span class=\"mord mathrm\">4</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">o</span><span class=\"mord mathit\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathit\">a</span><span class=\"mord mathit\">i</span><span class=\"mord\"><span class=\"mord mathit\">t</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:0em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">e</span><span class=\"mrel\">:</span><span class=\"mord mathrm\">5</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">q</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.03588em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">e</span><span class=\"mrel\">:</span><span class=\"mord mathrm\">6</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mbin\">+</span><span class=\"mord mathit\">s</span><span class=\"mord mathit\">o</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathit\">t</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">q</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.03588em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">e</span><span class=\"mrel\">:</span><span class=\"mord mathrm\">7</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span></span></span></p>\n</li>\n<li>\n<p>剩下的几行：</p>\n<ol>\n<li><code>initr</code>：中断次数</li>\n<li><code>ctxt</code>：交换次数</li>\n<li><code>btime</code>:从系统启动到访问文件为止的时间。</li>\n<li><code>processes</code>：任务数。</li>\n<li><code>procs_runing</code>：当前运行队列的任务数。</li>\n<li><code>procs_blocked</code>：当前被阻塞的任务数。</li>\n</ol>\n</li>\n<li>\n<p><code>CPU</code>利用率计算可以采用两点采样取差值的方式：</p>\nCPU_{usage} = (idle_{第二次采样} - idle_{第一次采样}) / (CPU_{time第二次采样} - CPU_{time第一次采样}) * 100\n\n</li>\n</ul>\n</li>\n<li>\n<p>CPU温度的获取：</p>\n<p>cpu温度存储在<code>/sys/class/thermal/thermal_zone0/temp</code>中，读取出的数值需要除以1000。</p>\n</li>\n<li>\n<p>bash 工具：</p>\n<ol>\n<li><code>cat</code>：工具用来强制读取一个文件。</li>\n<li><code>gerp</code>：工具用来筛选数据。</li>\n<li><code>awk</code>：用来处理数据。</li>\n<li><code>uptime</code>：获取cpu负载信息</li>\n</ol>\n</li>\n<li>\n<p>bash 数值计算：</p>\n<p>bash中的数值计算比较方便的方式是双小括号：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num=0</span><br><span class=\"line\">((num++)) <span class=\"comment\"># 在双小括号中可以正常使用C语言的数值计算语法</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;num&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结果输出---------------</span></span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p>代码</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">time_and_load=`date +<span class=\"string\">\"%Y-%m-%d__%H:%M:%S \"</span>``uptime | tr -s <span class=\"string\">\" \"</span> <span class=\"string\">\"\\n\"</span> | tr -s <span class=\"string\">\",\"</span> <span class=\"string\">\" \"</span> | awk NF | tail -3 | tr -s <span class=\"string\">\"\\n\"</span> <span class=\"string\">\" \"</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0.5s 前</span></span><br><span class=\"line\"><span class=\"comment\"># 开机后总时间</span></span><br><span class=\"line\">cpu_local1=`cat /proc/<span class=\"built_in\">stat</span> | grep  -w <span class=\"string\">\"cpu\"</span> | awk <span class=\"string\">'&#123;printf(\"%d\", $2 + $3 + $4 + $5 + $6 + $7 + 8);&#125;'</span>`</span><br><span class=\"line\"><span class=\"comment\"># 开机后累计空闲</span></span><br><span class=\"line\">cpu_idle1=`cat /proc/<span class=\"built_in\">stat</span> | grep  -w <span class=\"string\">\"cpu\"</span> | awk <span class=\"string\">'&#123;printf(\"%d\", $5);&#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">sleep 0.5s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0.5s 后</span></span><br><span class=\"line\"><span class=\"comment\"># 开机后总时间</span></span><br><span class=\"line\">cpu_local2=`cat /proc/<span class=\"built_in\">stat</span> | grep  -w <span class=\"string\">\"cpu\"</span> | awk <span class=\"string\">'&#123;printf(\"%d\", $2 + $3 + $4 + $5 + $6 + $7 + 8);&#125;'</span>`</span><br><span class=\"line\"><span class=\"comment\"># 开机后累计空闲</span></span><br><span class=\"line\">cpu_idle2=`cat /proc/<span class=\"built_in\">stat</span> | grep  -w <span class=\"string\">\"cpu\"</span> | awk <span class=\"string\">'&#123;printf(\"%d\", $5);&#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0.5s 内</span></span><br><span class=\"line\">((cpu_local = <span class=\"variable\">$cpu_local2</span> - <span class=\"variable\">$cpu_local1</span>))</span><br><span class=\"line\">((cpu_idle = <span class=\"variable\">$cpu_idle2</span> - <span class=\"variable\">$cpu_idle1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算cpu占用率</span></span><br><span class=\"line\">cpu_occu=`<span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$cpu_local</span> <span class=\"variable\">$cpu_idle</span>\"</span> | awk <span class=\"string\">'&#123;printf(\"%.2f%%\", (1 - $2 / $1) * 100);&#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CPU温度</span></span><br><span class=\"line\">cpu_temp_info=`cat /sys/class/thermal/thermal_zone0/temp | awk <span class=\"string\">'&#123;</span></span><br><span class=\"line\"><span class=\"string\">        if ($1 &gt;= 1000 &amp;&amp; $1 &lt; 50000) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            printf(\"%.2f normal\", $1 / 1000);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        else if ($1 &gt;= 50000 &amp;&amp; $1 &lt;= 70000) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            printf(\"%.2f note\", $1 / 1000);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        else &#123;</span></span><br><span class=\"line\"><span class=\"string\">            printf(\"%.2f warning\", $1 / 1000);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$&#123;time_and_load&#125;</span><span class=\"variable\">$&#123;cpu_occu&#125;</span> <span class=\"variable\">$&#123;cpu_temp_info&#125;</span>\"</span></span><br></pre></td></tr></table></figure>\n"},{"title":"HDU - 2072","date":"2019-09-02T08:31:16.000Z","cover":"title.jpg","_content":"\n> [题目传送](http://acm.hdu.edu.cn/showproblem.php?pid=2072)\n\n\n* Sample Input\n\n  ```txt\n  you are my friend #\n  ```\n\n* Sample Output\n  ```txt\n  4\n  ```\n\n\n* 思路：\n\n  利用STL的set,但是需要注意字符串的处理，利用set的特性，建立一个中间字符串变量tmp，把当前单词暂时存在tmp中，根据判断条件（输入的字符串是否为空格或者到了末尾）来判断把tmp存入set中。\n\n  另一个需要注意的就是遍历的for需要从0到字符串最后的后面一个，为了防止什么都没有的情况。\n\n* 代码：\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nset<string> se;\n\nvoid word(string str){\n    se.clear();\n    string tmp=\"\";\n    for(int i=0;i<=str.size();i++){\n        if(str[i]==' '||i==str.size()){\n            if(tmp==\"\")  continue;\n            se.insert(tmp);\n            tmp=\"\";\n        }\n        else  tmp+=str[i];\n    }\n    cout<<se.size()<<endl;\n}\n\nint main(){\n    string str;\n    while(getline(cin,str)&&str[0]!='#')\n        word(str);\n    return 0;\n}\n```\n\n---\n该代码来源于杭电讨论区的朋友（ 喜欢你的笑声）。\n","source":"_posts/HDU-2072.md","raw":"---\ntitle: HDU - 2072\ndate: 2019-09-02 16:31:16\ncover: title.jpg\ntags: \n- 题解\n- HDU\n---\n\n> [题目传送](http://acm.hdu.edu.cn/showproblem.php?pid=2072)\n\n\n* Sample Input\n\n  ```txt\n  you are my friend #\n  ```\n\n* Sample Output\n  ```txt\n  4\n  ```\n\n\n* 思路：\n\n  利用STL的set,但是需要注意字符串的处理，利用set的特性，建立一个中间字符串变量tmp，把当前单词暂时存在tmp中，根据判断条件（输入的字符串是否为空格或者到了末尾）来判断把tmp存入set中。\n\n  另一个需要注意的就是遍历的for需要从0到字符串最后的后面一个，为了防止什么都没有的情况。\n\n* 代码：\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nset<string> se;\n\nvoid word(string str){\n    se.clear();\n    string tmp=\"\";\n    for(int i=0;i<=str.size();i++){\n        if(str[i]==' '||i==str.size()){\n            if(tmp==\"\")  continue;\n            se.insert(tmp);\n            tmp=\"\";\n        }\n        else  tmp+=str[i];\n    }\n    cout<<se.size()<<endl;\n}\n\nint main(){\n    string str;\n    while(getline(cin,str)&&str[0]!='#')\n        word(str);\n    return 0;\n}\n```\n\n---\n该代码来源于杭电讨论区的朋友（ 喜欢你的笑声）。\n","slug":"HDU-2072","published":1,"updated":"2020-04-08T03:32:56.200Z","_id":"ck8qr69d5000a5d3ar8hvyt0c","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2072\" target=\"_blank\" rel=\"noopener\">题目传送</a></p>\n</blockquote>\n<ul>\n<li>\n<p>Sample Input</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">you are my friend #</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>Sample Output</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>思路：</p>\n<p>利用STL的set,但是需要注意字符串的处理，利用set的特性，建立一个中间字符串变量tmp，把当前单词暂时存在tmp中，根据判断条件（输入的字符串是否为空格或者到了末尾）来判断把tmp存入set中。</p>\n<p>另一个需要注意的就是遍历的for需要从0到字符串最后的后面一个，为了防止什么都没有的情况。</p>\n</li>\n<li>\n<p>代码：</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; se;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">word</span><span class=\"params\">(<span class=\"built_in\">string</span> str)</span></span>&#123;</span><br><span class=\"line\">    se.clear();</span><br><span class=\"line\">    <span class=\"built_in\">string</span> tmp=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=str.size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[i]==<span class=\"string\">' '</span>||i==str.size())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp==<span class=\"string\">\"\"</span>)  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            se.insert(tmp);</span><br><span class=\"line\">            tmp=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  tmp+=str[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;se.size()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(getline(<span class=\"built_in\">cin</span>,str)&amp;&amp;str[<span class=\"number\">0</span>]!=<span class=\"string\">'#'</span>)</span><br><span class=\"line\">        word(str);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>该代码来源于杭电讨论区的朋友（ 喜欢你的笑声）。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2072\" target=\"_blank\" rel=\"noopener\">题目传送</a></p>\n</blockquote>\n<ul>\n<li>\n<p>Sample Input</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">you are my friend #</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>Sample Output</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>思路：</p>\n<p>利用STL的set,但是需要注意字符串的处理，利用set的特性，建立一个中间字符串变量tmp，把当前单词暂时存在tmp中，根据判断条件（输入的字符串是否为空格或者到了末尾）来判断把tmp存入set中。</p>\n<p>另一个需要注意的就是遍历的for需要从0到字符串最后的后面一个，为了防止什么都没有的情况。</p>\n</li>\n<li>\n<p>代码：</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"built_in\">string</span>&gt; se;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">word</span><span class=\"params\">(<span class=\"built_in\">string</span> str)</span></span>&#123;</span><br><span class=\"line\">    se.clear();</span><br><span class=\"line\">    <span class=\"built_in\">string</span> tmp=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=str.size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[i]==<span class=\"string\">' '</span>||i==str.size())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp==<span class=\"string\">\"\"</span>)  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            se.insert(tmp);</span><br><span class=\"line\">            tmp=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  tmp+=str[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;se.size()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(getline(<span class=\"built_in\">cin</span>,str)&amp;&amp;str[<span class=\"number\">0</span>]!=<span class=\"string\">'#'</span>)</span><br><span class=\"line\">        word(str);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>该代码来源于杭电讨论区的朋友（ 喜欢你的笑声）。</p>\n"},{"title":"MYSQL-笔记1","date":"2019-09-02T08:32:55.000Z","cover":"title.jpg","_content":"\n>   在MYSQL中查询操作涉及内容\n\n\n\n[TOC]\n\n## function\n\n>   对待查询字段在待查找表中出现的若干记录中的函数参数中指定的字段进行某些操作。\n\n*   `COUNT` ： 统计\n*   `SUM` ： 求和\n*   `AVG` ： 平均数\n\n[more about info](https://www.runoob.com/mysql/mysql-functions.html)\n\n\n\n\n\n## sentence\n\n>   各个语句执行顺序：select –>where –> group by–> having–>order by。\n\n\n\n### 常用语句\n\n* `limit` \n\n   限定查找记录的条数。\n\n* `offset`\n\n   查找偏移量，即前n条跳过，从n+1开始查询。\n\n* `with rollup` \n\n   进一步得到`group by`信息的汇总信息。\n\n* `having` \n\n   功能类似`where`，不同的是，`where`是筛选已存在的数据，`having`用来对前面的筛选进行进一步筛选。\n\n  例：\n\n  ```mysql\n  select \n  \tname,\n  \tSUM(sign), \n  \tSUM(score) \n  from \n  \tgames \n  group by \n  \tname \n  having \n  \tSUM(score) > 80\n  ;\n  -- SUM(score)在games表中不存在，是待筛数据。\n  -- 通过having可以对其进行进一步筛选。\n  ```\n\n  \n\n* `link`\n\n  常与`where配合使用`，使用`link`子句匹配模式串，可以将`link`看作`=`。\n\n  可以使用正则表达式中的`%`来匹配任意字符。\n\n  例：\n\n  ```mysql\n  select \n  \t* \n  from \n  \tComputer \n  where \n  \tModel link 'Mac%'\n  ;\n  \n  -- 查找Computer表中Model字段中含有'Mac'的记录。\n  ```\n\n  \n\n* `order by`\n\n  排序子句，给查找出来的记录排序，可以选择按照一个或多个字段为记录排序，\n\n  当然也可以设置升序(asc)还是降序(desc)，默认是升序。\n\n  当然也可以添加`where...link...`来设置更加复杂的排序规则。\n\n  例：\n\n  ```mysql\n  select \n  \t*\n  from \n  \tComputer\n  order by \n  \tSales_volume\n  ;\n  \n  -- 按照Sales_volume字段排序输出Computer表。\n  ```\n\n  \n\n* `select ... into outfile 'filename'`\n\n  导出查询结果到文件。\n\n* `union`\n\n  用来连接多个`select`语句，将结果合并输出，可选是(all)否(默认删除重复数据)删除重复数据。\n\n  例：\n\n  ```mysql\n  select \n  \tSales_volume\n  from \n  \tComputer\n  union all\n  select \n  \tSales_volume\n  from \n  \tMobile_Phone\n  order by \n  \tSales_volume\n  ;\n  \n  -- 查找Computer表和Mobile_Phone表中的Sales_volume字段数据，\n  -- 按照Sales_volume以默认方式排序，\n  -- 而且不删除重复数据。\n  ```\n\n\n\n\n\n### JOIN\n\n>   用于连接两个或多个表，从多个表中查询数据。\n>\n>   ...  tableA [join语句] tableB ...  on [条件]\n\n*   `inner join`：语句两端的两个表的交集。\n*   `left join`：读取左边表中所有的匹配数据，即使右侧表中无匹配数据。\n*   `righe join `：与`lefr join`正好相反。\n\n\n\n### NULL\n\n在MYSQL中判断空值使用`=`和`!=`是无效的，\n\n`NULL`与任何其他值的比较结果一定是`false`，需要使用`NULL`和`IS NULL`。\n\n在创建表的时候使用`NULL`和`NOT NULL`来设置完整性约束。\n\n\n\n### 正则表达式\n\n>   MYSQL也是支持正则表达式匹配的，例如`link`子句中可以使用`%`来匹配任意字符。\n\n在MYSQL中使用正则表达式需要使用` REGEXP`子句来连接待查找字段和模式串。\n\n常用模式：\n\n| 模式       | 描述                                                         |\n| :--------- | :----------------------------------------------------------- |\n| ^          | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\\n' 或 '\\r' 之后的位置。 |\n| $          | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\\n' 或 '\\r' 之前的位置。 |\n| .          | 匹配除 \"\\n\" 之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用象 '[.\\n]' 的模式。 |\n| [...]      | 字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 \"plain\" 中的 'a'。 |\n| [^...]     | 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 \"plain\" 中的'p'。 |\n| p1\\|p2\\|p3 | 匹配 p1 或 p2 或 p3。例如，'z\\|food' 能匹配 \"z\" 或 \"food\"。'(z\\|f)ood' 则匹配 \"zood\" 或 \"food\"。 |\n| *          | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于{0,}。 |\n| +          | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 |\n| {n}        | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。 |\n| {n,m}      | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。 |\n\n[上表引自RUNOOB](https://www.runoob.com/mysql/mysql-regexp.html)\n\n\n\n### 临时表\n\n临时表的生命周期与当前账号登陆时间等同，退出登陆时，该表空间释放。\n\n创建临时表需要使用`TEMPORARY`子句修饰`table`。\n\n手动删除使用`drop`子句。\n\n\n\n### 复制表\n\n当需要完全的克隆一个已存在的表，只需要找出建表记录，使用该建表记录创建新表，然后将数据 拷贝拷贝进入即可。\n\n1. 找出建表记录\n\n   `show create table 表名`\n\n2. 更改表名创建科隆表\n\n3. 克隆数据\n\n   `insert into ... select...`\n\n\n\n### 重复数据处理\n\n* 创建表时设置约束\n\n  使用`primary key`将不可重复字段设置为主键。\n\n  1.  在设置了主键或者唯一索引后使用通常的`insert into`插入重复数据将会报错\n  2.  使用`insert ignore into`插入重复数据将仅仅是警告，然后忽略重复数据不执行插入。\n  3.  使用`replace into`插入重复数据将使用带插入数据更新旧的数据。\n\n* 筛选\n\n  1.  在`select`的时候使用`distinct`筛掉重复数据。\n  2.  使用`group by` 对不需要重复的字段进行读取不重复的字段。\n\n\n\n\n\n---\n\n参考：\n\n[RUNOOB.COM](https://www.runoob.com/mysql/mysql-tutorial.html)\n[CSDN Blog ](https://blog.csdn.net/jiangnan2014/article/details/17229713)\t\n[CSDN Blog](https://blog.csdn.net/AinUser/article/details/72803175)\n[CSDN Blog](https://blog.csdn.net/love_xsq/article/details/42417917)\n","source":"_posts/MYSQL-笔记1.md","raw":"---\ntitle: MYSQL-笔记1\ndate: 2019-09-02 16:32:55\ncover: title.jpg\ntags: note\n---\n\n>   在MYSQL中查询操作涉及内容\n\n\n\n[TOC]\n\n## function\n\n>   对待查询字段在待查找表中出现的若干记录中的函数参数中指定的字段进行某些操作。\n\n*   `COUNT` ： 统计\n*   `SUM` ： 求和\n*   `AVG` ： 平均数\n\n[more about info](https://www.runoob.com/mysql/mysql-functions.html)\n\n\n\n\n\n## sentence\n\n>   各个语句执行顺序：select –>where –> group by–> having–>order by。\n\n\n\n### 常用语句\n\n* `limit` \n\n   限定查找记录的条数。\n\n* `offset`\n\n   查找偏移量，即前n条跳过，从n+1开始查询。\n\n* `with rollup` \n\n   进一步得到`group by`信息的汇总信息。\n\n* `having` \n\n   功能类似`where`，不同的是，`where`是筛选已存在的数据，`having`用来对前面的筛选进行进一步筛选。\n\n  例：\n\n  ```mysql\n  select \n  \tname,\n  \tSUM(sign), \n  \tSUM(score) \n  from \n  \tgames \n  group by \n  \tname \n  having \n  \tSUM(score) > 80\n  ;\n  -- SUM(score)在games表中不存在，是待筛数据。\n  -- 通过having可以对其进行进一步筛选。\n  ```\n\n  \n\n* `link`\n\n  常与`where配合使用`，使用`link`子句匹配模式串，可以将`link`看作`=`。\n\n  可以使用正则表达式中的`%`来匹配任意字符。\n\n  例：\n\n  ```mysql\n  select \n  \t* \n  from \n  \tComputer \n  where \n  \tModel link 'Mac%'\n  ;\n  \n  -- 查找Computer表中Model字段中含有'Mac'的记录。\n  ```\n\n  \n\n* `order by`\n\n  排序子句，给查找出来的记录排序，可以选择按照一个或多个字段为记录排序，\n\n  当然也可以设置升序(asc)还是降序(desc)，默认是升序。\n\n  当然也可以添加`where...link...`来设置更加复杂的排序规则。\n\n  例：\n\n  ```mysql\n  select \n  \t*\n  from \n  \tComputer\n  order by \n  \tSales_volume\n  ;\n  \n  -- 按照Sales_volume字段排序输出Computer表。\n  ```\n\n  \n\n* `select ... into outfile 'filename'`\n\n  导出查询结果到文件。\n\n* `union`\n\n  用来连接多个`select`语句，将结果合并输出，可选是(all)否(默认删除重复数据)删除重复数据。\n\n  例：\n\n  ```mysql\n  select \n  \tSales_volume\n  from \n  \tComputer\n  union all\n  select \n  \tSales_volume\n  from \n  \tMobile_Phone\n  order by \n  \tSales_volume\n  ;\n  \n  -- 查找Computer表和Mobile_Phone表中的Sales_volume字段数据，\n  -- 按照Sales_volume以默认方式排序，\n  -- 而且不删除重复数据。\n  ```\n\n\n\n\n\n### JOIN\n\n>   用于连接两个或多个表，从多个表中查询数据。\n>\n>   ...  tableA [join语句] tableB ...  on [条件]\n\n*   `inner join`：语句两端的两个表的交集。\n*   `left join`：读取左边表中所有的匹配数据，即使右侧表中无匹配数据。\n*   `righe join `：与`lefr join`正好相反。\n\n\n\n### NULL\n\n在MYSQL中判断空值使用`=`和`!=`是无效的，\n\n`NULL`与任何其他值的比较结果一定是`false`，需要使用`NULL`和`IS NULL`。\n\n在创建表的时候使用`NULL`和`NOT NULL`来设置完整性约束。\n\n\n\n### 正则表达式\n\n>   MYSQL也是支持正则表达式匹配的，例如`link`子句中可以使用`%`来匹配任意字符。\n\n在MYSQL中使用正则表达式需要使用` REGEXP`子句来连接待查找字段和模式串。\n\n常用模式：\n\n| 模式       | 描述                                                         |\n| :--------- | :----------------------------------------------------------- |\n| ^          | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\\n' 或 '\\r' 之后的位置。 |\n| $          | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\\n' 或 '\\r' 之前的位置。 |\n| .          | 匹配除 \"\\n\" 之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用象 '[.\\n]' 的模式。 |\n| [...]      | 字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 \"plain\" 中的 'a'。 |\n| [^...]     | 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 \"plain\" 中的'p'。 |\n| p1\\|p2\\|p3 | 匹配 p1 或 p2 或 p3。例如，'z\\|food' 能匹配 \"z\" 或 \"food\"。'(z\\|f)ood' 则匹配 \"zood\" 或 \"food\"。 |\n| *          | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于{0,}。 |\n| +          | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 |\n| {n}        | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。 |\n| {n,m}      | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。 |\n\n[上表引自RUNOOB](https://www.runoob.com/mysql/mysql-regexp.html)\n\n\n\n### 临时表\n\n临时表的生命周期与当前账号登陆时间等同，退出登陆时，该表空间释放。\n\n创建临时表需要使用`TEMPORARY`子句修饰`table`。\n\n手动删除使用`drop`子句。\n\n\n\n### 复制表\n\n当需要完全的克隆一个已存在的表，只需要找出建表记录，使用该建表记录创建新表，然后将数据 拷贝拷贝进入即可。\n\n1. 找出建表记录\n\n   `show create table 表名`\n\n2. 更改表名创建科隆表\n\n3. 克隆数据\n\n   `insert into ... select...`\n\n\n\n### 重复数据处理\n\n* 创建表时设置约束\n\n  使用`primary key`将不可重复字段设置为主键。\n\n  1.  在设置了主键或者唯一索引后使用通常的`insert into`插入重复数据将会报错\n  2.  使用`insert ignore into`插入重复数据将仅仅是警告，然后忽略重复数据不执行插入。\n  3.  使用`replace into`插入重复数据将使用带插入数据更新旧的数据。\n\n* 筛选\n\n  1.  在`select`的时候使用`distinct`筛掉重复数据。\n  2.  使用`group by` 对不需要重复的字段进行读取不重复的字段。\n\n\n\n\n\n---\n\n参考：\n\n[RUNOOB.COM](https://www.runoob.com/mysql/mysql-tutorial.html)\n[CSDN Blog ](https://blog.csdn.net/jiangnan2014/article/details/17229713)\t\n[CSDN Blog](https://blog.csdn.net/AinUser/article/details/72803175)\n[CSDN Blog](https://blog.csdn.net/love_xsq/article/details/42417917)\n","slug":"MYSQL-笔记1","published":1,"updated":"2020-04-08T03:38:57.746Z","_id":"ck8qr69d8000d5d3ar1n8iiy3","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>在MYSQL中查询操作涉及内容</p>\n</blockquote>\n<p>[TOC]</p>\n<h2 id=\"function\"><a class=\"markdownIt-Anchor\" href=\"#function\"></a> function</h2>\n<blockquote>\n<p>对待查询字段在待查找表中出现的若干记录中的函数参数中指定的字段进行某些操作。</p>\n</blockquote>\n<ul>\n<li><code>COUNT</code> ： 统计</li>\n<li><code>SUM</code> ： 求和</li>\n<li><code>AVG</code> ： 平均数</li>\n</ul>\n<p><a href=\"https://www.runoob.com/mysql/mysql-functions.html\" target=\"_blank\" rel=\"noopener\">more about info</a></p>\n<h2 id=\"sentence\"><a class=\"markdownIt-Anchor\" href=\"#sentence\"></a> sentence</h2>\n<blockquote>\n<p>各个语句执行顺序：select –&gt;where –&gt; group by–&gt; having–&gt;order by。</p>\n</blockquote>\n<h3 id=\"常用语句\"><a class=\"markdownIt-Anchor\" href=\"#常用语句\"></a> 常用语句</h3>\n<ul>\n<li>\n<p><code>limit</code></p>\n<p>限定查找记录的条数。</p>\n</li>\n<li>\n<p><code>offset</code></p>\n<p>查找偏移量，即前n条跳过，从n+1开始查询。</p>\n</li>\n<li>\n<p><code>with rollup</code></p>\n<p>进一步得到<code>group by</code>信息的汇总信息。</p>\n</li>\n<li>\n<p><code>having</code></p>\n<p>功能类似<code>where</code>，不同的是，<code>where</code>是筛选已存在的数据，<code>having</code>用来对前面的筛选进行进一步筛选。</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select </span><br><span class=\"line\">\tname,</span><br><span class=\"line\">\tSUM(sign), </span><br><span class=\"line\">\tSUM(score) </span><br><span class=\"line\">from </span><br><span class=\"line\">\tgames </span><br><span class=\"line\">group by </span><br><span class=\"line\">\tname </span><br><span class=\"line\">having </span><br><span class=\"line\">\tSUM(score) &gt; 80</span><br><span class=\"line\">;</span><br><span class=\"line\">-- SUM(score)在games表中不存在，是待筛数据。</span><br><span class=\"line\">-- 通过having可以对其进行进一步筛选。</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>link</code></p>\n<p>常与<code>where配合使用</code>，使用<code>link</code>子句匹配模式串，可以将<code>link</code>看作<code>=</code>。</p>\n<p>可以使用正则表达式中的<code>%</code>来匹配任意字符。</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select </span><br><span class=\"line\">\t* </span><br><span class=\"line\">from </span><br><span class=\"line\">\tComputer </span><br><span class=\"line\">where </span><br><span class=\"line\">\tModel link &apos;Mac%&apos;</span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查找Computer表中Model字段中含有&apos;Mac&apos;的记录。</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>order by</code></p>\n<p>排序子句，给查找出来的记录排序，可以选择按照一个或多个字段为记录排序，</p>\n<p>当然也可以设置升序(asc)还是降序(desc)，默认是升序。</p>\n<p>当然也可以添加<code>where...link...</code>来设置更加复杂的排序规则。</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select </span><br><span class=\"line\">\t*</span><br><span class=\"line\">from </span><br><span class=\"line\">\tComputer</span><br><span class=\"line\">order by </span><br><span class=\"line\">\tSales_volume</span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 按照Sales_volume字段排序输出Computer表。</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>select ... into outfile 'filename'</code></p>\n<p>导出查询结果到文件。</p>\n</li>\n<li>\n<p><code>union</code></p>\n<p>用来连接多个<code>select</code>语句，将结果合并输出，可选是(all)否(默认删除重复数据)删除重复数据。</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select </span><br><span class=\"line\">\tSales_volume</span><br><span class=\"line\">from </span><br><span class=\"line\">\tComputer</span><br><span class=\"line\">union all</span><br><span class=\"line\">select </span><br><span class=\"line\">\tSales_volume</span><br><span class=\"line\">from </span><br><span class=\"line\">\tMobile_Phone</span><br><span class=\"line\">order by </span><br><span class=\"line\">\tSales_volume</span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查找Computer表和Mobile_Phone表中的Sales_volume字段数据，</span><br><span class=\"line\">-- 按照Sales_volume以默认方式排序，</span><br><span class=\"line\">-- 而且不删除重复数据。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"join\"><a class=\"markdownIt-Anchor\" href=\"#join\"></a> JOIN</h3>\n<blockquote>\n<p>用于连接两个或多个表，从多个表中查询数据。</p>\n<p>…  tableA [join语句] tableB …  on [条件]</p>\n</blockquote>\n<ul>\n<li><code>inner join</code>：语句两端的两个表的交集。</li>\n<li><code>left join</code>：读取左边表中所有的匹配数据，即使右侧表中无匹配数据。</li>\n<li><code>righe join</code>：与<code>lefr join</code>正好相反。</li>\n</ul>\n<h3 id=\"null\"><a class=\"markdownIt-Anchor\" href=\"#null\"></a> NULL</h3>\n<p>在MYSQL中判断空值使用<code>=</code>和<code>!=</code>是无效的，</p>\n<p><code>NULL</code>与任何其他值的比较结果一定是<code>false</code>，需要使用<code>NULL</code>和<code>IS NULL</code>。</p>\n<p>在创建表的时候使用<code>NULL</code>和<code>NOT NULL</code>来设置完整性约束。</p>\n<h3 id=\"正则表达式\"><a class=\"markdownIt-Anchor\" href=\"#正则表达式\"></a> 正则表达式</h3>\n<blockquote>\n<p>MYSQL也是支持正则表达式匹配的，例如<code>link</code>子句中可以使用<code>%</code>来匹配任意字符。</p>\n</blockquote>\n<p>在MYSQL中使用正则表达式需要使用<code>REGEXP</code>子句来连接待查找字段和模式串。</p>\n<p>常用模式：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">模式</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">^</td>\n<td style=\"text-align:left\">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$</td>\n<td style=\"text-align:left\">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">.</td>\n<td style=\"text-align:left\">匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[…]</td>\n<td style=\"text-align:left\">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[^…]</td>\n<td style=\"text-align:left\">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">p1|p2|p3</td>\n<td style=\"text-align:left\">匹配 p1 或 p2 或 p3。例如，‘z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">*</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+</td>\n<td style=\"text-align:left\">匹配前面的子表达式一次或多次。例如，‘zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">{n}</td>\n<td style=\"text-align:left\">n 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">{n,m}</td>\n<td style=\"text-align:left\">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://www.runoob.com/mysql/mysql-regexp.html\" target=\"_blank\" rel=\"noopener\">上表引自RUNOOB</a></p>\n<h3 id=\"临时表\"><a class=\"markdownIt-Anchor\" href=\"#临时表\"></a> 临时表</h3>\n<p>临时表的生命周期与当前账号登陆时间等同，退出登陆时，该表空间释放。</p>\n<p>创建临时表需要使用<code>TEMPORARY</code>子句修饰<code>table</code>。</p>\n<p>手动删除使用<code>drop</code>子句。</p>\n<h3 id=\"复制表\"><a class=\"markdownIt-Anchor\" href=\"#复制表\"></a> 复制表</h3>\n<p>当需要完全的克隆一个已存在的表，只需要找出建表记录，使用该建表记录创建新表，然后将数据 拷贝拷贝进入即可。</p>\n<ol>\n<li>\n<p>找出建表记录</p>\n<p><code>show create table 表名</code></p>\n</li>\n<li>\n<p>更改表名创建科隆表</p>\n</li>\n<li>\n<p>克隆数据</p>\n<p><code>insert into ... select...</code></p>\n</li>\n</ol>\n<h3 id=\"重复数据处理\"><a class=\"markdownIt-Anchor\" href=\"#重复数据处理\"></a> 重复数据处理</h3>\n<ul>\n<li>\n<p>创建表时设置约束</p>\n<p>使用<code>primary key</code>将不可重复字段设置为主键。</p>\n<ol>\n<li>在设置了主键或者唯一索引后使用通常的<code>insert into</code>插入重复数据将会报错</li>\n<li>使用<code>insert ignore into</code>插入重复数据将仅仅是警告，然后忽略重复数据不执行插入。</li>\n<li>使用<code>replace into</code>插入重复数据将使用带插入数据更新旧的数据。</li>\n</ol>\n</li>\n<li>\n<p>筛选</p>\n<ol>\n<li>在<code>select</code>的时候使用<code>distinct</code>筛掉重复数据。</li>\n<li>使用<code>group by</code> 对不需要重复的字段进行读取不重复的字段。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<p>参考：</p>\n<p><a href=\"https://www.runoob.com/mysql/mysql-tutorial.html\" target=\"_blank\" rel=\"noopener\">RUNOOB.COM</a><br>\n<a href=\"https://blog.csdn.net/jiangnan2014/article/details/17229713\" target=\"_blank\" rel=\"noopener\">CSDN Blog </a>\t<br>\n<a href=\"https://blog.csdn.net/AinUser/article/details/72803175\" target=\"_blank\" rel=\"noopener\">CSDN Blog</a><br>\n<a href=\"https://blog.csdn.net/love_xsq/article/details/42417917\" target=\"_blank\" rel=\"noopener\">CSDN Blog</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在MYSQL中查询操作涉及内容</p>\n</blockquote>\n<p>[TOC]</p>\n<h2 id=\"function\"><a class=\"markdownIt-Anchor\" href=\"#function\"></a> function</h2>\n<blockquote>\n<p>对待查询字段在待查找表中出现的若干记录中的函数参数中指定的字段进行某些操作。</p>\n</blockquote>\n<ul>\n<li><code>COUNT</code> ： 统计</li>\n<li><code>SUM</code> ： 求和</li>\n<li><code>AVG</code> ： 平均数</li>\n</ul>\n<p><a href=\"https://www.runoob.com/mysql/mysql-functions.html\" target=\"_blank\" rel=\"noopener\">more about info</a></p>\n<h2 id=\"sentence\"><a class=\"markdownIt-Anchor\" href=\"#sentence\"></a> sentence</h2>\n<blockquote>\n<p>各个语句执行顺序：select –&gt;where –&gt; group by–&gt; having–&gt;order by。</p>\n</blockquote>\n<h3 id=\"常用语句\"><a class=\"markdownIt-Anchor\" href=\"#常用语句\"></a> 常用语句</h3>\n<ul>\n<li>\n<p><code>limit</code></p>\n<p>限定查找记录的条数。</p>\n</li>\n<li>\n<p><code>offset</code></p>\n<p>查找偏移量，即前n条跳过，从n+1开始查询。</p>\n</li>\n<li>\n<p><code>with rollup</code></p>\n<p>进一步得到<code>group by</code>信息的汇总信息。</p>\n</li>\n<li>\n<p><code>having</code></p>\n<p>功能类似<code>where</code>，不同的是，<code>where</code>是筛选已存在的数据，<code>having</code>用来对前面的筛选进行进一步筛选。</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select </span><br><span class=\"line\">\tname,</span><br><span class=\"line\">\tSUM(sign), </span><br><span class=\"line\">\tSUM(score) </span><br><span class=\"line\">from </span><br><span class=\"line\">\tgames </span><br><span class=\"line\">group by </span><br><span class=\"line\">\tname </span><br><span class=\"line\">having </span><br><span class=\"line\">\tSUM(score) &gt; 80</span><br><span class=\"line\">;</span><br><span class=\"line\">-- SUM(score)在games表中不存在，是待筛数据。</span><br><span class=\"line\">-- 通过having可以对其进行进一步筛选。</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>link</code></p>\n<p>常与<code>where配合使用</code>，使用<code>link</code>子句匹配模式串，可以将<code>link</code>看作<code>=</code>。</p>\n<p>可以使用正则表达式中的<code>%</code>来匹配任意字符。</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select </span><br><span class=\"line\">\t* </span><br><span class=\"line\">from </span><br><span class=\"line\">\tComputer </span><br><span class=\"line\">where </span><br><span class=\"line\">\tModel link &apos;Mac%&apos;</span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查找Computer表中Model字段中含有&apos;Mac&apos;的记录。</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>order by</code></p>\n<p>排序子句，给查找出来的记录排序，可以选择按照一个或多个字段为记录排序，</p>\n<p>当然也可以设置升序(asc)还是降序(desc)，默认是升序。</p>\n<p>当然也可以添加<code>where...link...</code>来设置更加复杂的排序规则。</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select </span><br><span class=\"line\">\t*</span><br><span class=\"line\">from </span><br><span class=\"line\">\tComputer</span><br><span class=\"line\">order by </span><br><span class=\"line\">\tSales_volume</span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 按照Sales_volume字段排序输出Computer表。</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>select ... into outfile 'filename'</code></p>\n<p>导出查询结果到文件。</p>\n</li>\n<li>\n<p><code>union</code></p>\n<p>用来连接多个<code>select</code>语句，将结果合并输出，可选是(all)否(默认删除重复数据)删除重复数据。</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select </span><br><span class=\"line\">\tSales_volume</span><br><span class=\"line\">from </span><br><span class=\"line\">\tComputer</span><br><span class=\"line\">union all</span><br><span class=\"line\">select </span><br><span class=\"line\">\tSales_volume</span><br><span class=\"line\">from </span><br><span class=\"line\">\tMobile_Phone</span><br><span class=\"line\">order by </span><br><span class=\"line\">\tSales_volume</span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查找Computer表和Mobile_Phone表中的Sales_volume字段数据，</span><br><span class=\"line\">-- 按照Sales_volume以默认方式排序，</span><br><span class=\"line\">-- 而且不删除重复数据。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"join\"><a class=\"markdownIt-Anchor\" href=\"#join\"></a> JOIN</h3>\n<blockquote>\n<p>用于连接两个或多个表，从多个表中查询数据。</p>\n<p>…  tableA [join语句] tableB …  on [条件]</p>\n</blockquote>\n<ul>\n<li><code>inner join</code>：语句两端的两个表的交集。</li>\n<li><code>left join</code>：读取左边表中所有的匹配数据，即使右侧表中无匹配数据。</li>\n<li><code>righe join</code>：与<code>lefr join</code>正好相反。</li>\n</ul>\n<h3 id=\"null\"><a class=\"markdownIt-Anchor\" href=\"#null\"></a> NULL</h3>\n<p>在MYSQL中判断空值使用<code>=</code>和<code>!=</code>是无效的，</p>\n<p><code>NULL</code>与任何其他值的比较结果一定是<code>false</code>，需要使用<code>NULL</code>和<code>IS NULL</code>。</p>\n<p>在创建表的时候使用<code>NULL</code>和<code>NOT NULL</code>来设置完整性约束。</p>\n<h3 id=\"正则表达式\"><a class=\"markdownIt-Anchor\" href=\"#正则表达式\"></a> 正则表达式</h3>\n<blockquote>\n<p>MYSQL也是支持正则表达式匹配的，例如<code>link</code>子句中可以使用<code>%</code>来匹配任意字符。</p>\n</blockquote>\n<p>在MYSQL中使用正则表达式需要使用<code>REGEXP</code>子句来连接待查找字段和模式串。</p>\n<p>常用模式：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">模式</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">^</td>\n<td style=\"text-align:left\">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$</td>\n<td style=\"text-align:left\">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">.</td>\n<td style=\"text-align:left\">匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[…]</td>\n<td style=\"text-align:left\">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[^…]</td>\n<td style=\"text-align:left\">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">p1|p2|p3</td>\n<td style=\"text-align:left\">匹配 p1 或 p2 或 p3。例如，‘z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">*</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+</td>\n<td style=\"text-align:left\">匹配前面的子表达式一次或多次。例如，‘zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">{n}</td>\n<td style=\"text-align:left\">n 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">{n,m}</td>\n<td style=\"text-align:left\">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://www.runoob.com/mysql/mysql-regexp.html\" target=\"_blank\" rel=\"noopener\">上表引自RUNOOB</a></p>\n<h3 id=\"临时表\"><a class=\"markdownIt-Anchor\" href=\"#临时表\"></a> 临时表</h3>\n<p>临时表的生命周期与当前账号登陆时间等同，退出登陆时，该表空间释放。</p>\n<p>创建临时表需要使用<code>TEMPORARY</code>子句修饰<code>table</code>。</p>\n<p>手动删除使用<code>drop</code>子句。</p>\n<h3 id=\"复制表\"><a class=\"markdownIt-Anchor\" href=\"#复制表\"></a> 复制表</h3>\n<p>当需要完全的克隆一个已存在的表，只需要找出建表记录，使用该建表记录创建新表，然后将数据 拷贝拷贝进入即可。</p>\n<ol>\n<li>\n<p>找出建表记录</p>\n<p><code>show create table 表名</code></p>\n</li>\n<li>\n<p>更改表名创建科隆表</p>\n</li>\n<li>\n<p>克隆数据</p>\n<p><code>insert into ... select...</code></p>\n</li>\n</ol>\n<h3 id=\"重复数据处理\"><a class=\"markdownIt-Anchor\" href=\"#重复数据处理\"></a> 重复数据处理</h3>\n<ul>\n<li>\n<p>创建表时设置约束</p>\n<p>使用<code>primary key</code>将不可重复字段设置为主键。</p>\n<ol>\n<li>在设置了主键或者唯一索引后使用通常的<code>insert into</code>插入重复数据将会报错</li>\n<li>使用<code>insert ignore into</code>插入重复数据将仅仅是警告，然后忽略重复数据不执行插入。</li>\n<li>使用<code>replace into</code>插入重复数据将使用带插入数据更新旧的数据。</li>\n</ol>\n</li>\n<li>\n<p>筛选</p>\n<ol>\n<li>在<code>select</code>的时候使用<code>distinct</code>筛掉重复数据。</li>\n<li>使用<code>group by</code> 对不需要重复的字段进行读取不重复的字段。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<p>参考：</p>\n<p><a href=\"https://www.runoob.com/mysql/mysql-tutorial.html\" target=\"_blank\" rel=\"noopener\">RUNOOB.COM</a><br>\n<a href=\"https://blog.csdn.net/jiangnan2014/article/details/17229713\" target=\"_blank\" rel=\"noopener\">CSDN Blog </a>\t<br>\n<a href=\"https://blog.csdn.net/AinUser/article/details/72803175\" target=\"_blank\" rel=\"noopener\">CSDN Blog</a><br>\n<a href=\"https://blog.csdn.net/love_xsq/article/details/42417917\" target=\"_blank\" rel=\"noopener\">CSDN Blog</a></p>\n"},{"title":"Linux三剑客之awk的使用","date":"2019-09-02T08:35:47.000Z","cover":"title.jpg","_content":"\n> awk 是一款极其强大的文本处理工具，其语言于c语言的语法极其相似，上手很容易\n>  内置变量与运算符数据来自[RUNOOB](https://www.runoob.com/linux/linux-comm-awk.html)\n\n* 简单用法\n  ```bash\n  awk [参数] 'awk代码'\n  awk [参数] -f awk脚本文件 \n  ```\n* 常用参数\n  ```bash\n  cat xxx.txt | awk -F ':' 'BEGIN{}{printf(\"%s %s\", $1, $2);}END{printf(\"OK!\");}'\n  # -F 参数是指定对每行字符串以什么字符为分割，每个被分割的部分存储在变量：$1, $2, $3...中，整行字符串存储在$0中。\n  # BEGIN{}中的代码将在文本处理前执行，同样，END{}会文本处理后执行，{}中的代码用来处理每行的文本。\n  \n  cat xxx.txt | awk -v var1=${tmp} '{printf(\"%d\\n\", $3/var1);}'\n  # -v 参数是引入外部变量，把${tmp}赋值给var1，在awk内部代码中就可以使用var1了。\n  # -v参数可以多次引用，也就是说可以引入多个变量。\n  \n  cat xxx | awk -v var1=${tmp} '{\n  \tif ($1 ~ /eth/) {\n  \t\tprint $0;\n  \t}\n  }'\n  # 通过这种方式可以使用正则表达式进行字符串匹配。\n  # awk支持print，使用print末尾自动加上\\n。\n  ```\n\n* 内置变量\n\n| 变量 | 描述                                |\n| ---- | ----------------------------------- |\n| $n   | 当前记录的第n个字段，字段间由FS分隔 |\n| $0   | 完整的输入记录                      |\n| ARGC | 命令行参数的数目                    |\n|ARGIND\t|命令行中当前文件的位置(从0开始算)\nARGV\t包含命令行参数的数组|\n|CONVFMT|数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组|\n|ERRNO|最后一个系统错误的描述|\n|FIELDWIDTHS|字段宽度列表(用空格键分隔)|\n|FILENAME|当前文件名|\n|FNR|各文件分别计数的行号|\n|FS|字段分隔符(默认是任何空格)|\n|IGNORECASE|如果为真，则进行忽略大小写的匹配|\n|NF|一条记录的字段的数目|\n|NR|已经读出的记录数，就是行号，从1开始|\n|OFMT|数字的输出格式(默认值是%.6g)|\n|OFS|输出记录分隔符（输出换行符），输出时用指定的符号代替换行符|\n|ORS|输出记录分隔符(默认值是一个换行符)|\n|RLENGTH|由match函数所匹配的字符串的长度|\n|RS|记录分隔符(默认是一个换行符)|\n|RSTART|由match函数所匹配的字符串的第一个位置|\n|SUBSEP|数组下标分隔符(默认值是/034)|\n\n* 运算符\n\n| 运算符                  | 描述 |\n| ----------------------- | ---- |\n| = += -= *= /= %= ^= **= | 赋值 |\n|?:|C条件表达式\n| \\|\\||逻辑或|\n|&&|逻辑与|\n|~ 和 !~|匹配正则表达式和不匹配正则表达式|\n|< <= > >= != ==|关系运算符|\n|空格|连接|\n|+ -|加，减|\n|* / %|乘，除与求余|\n|+ - !\t|一元加，减和逻辑非|\n|^ ***|求幂|\n|++ --|增加或减少，作为前缀或后缀|\n|$|字段引用|\n|in|数组成员|\n","source":"_posts/Linux三剑客之awk的使用.md","raw":"---\ntitle: Linux三剑客之awk的使用\ndate: 2019-09-02 16:35:47\ncover: title.jpg\ntags: note\n---\n\n> awk 是一款极其强大的文本处理工具，其语言于c语言的语法极其相似，上手很容易\n>  内置变量与运算符数据来自[RUNOOB](https://www.runoob.com/linux/linux-comm-awk.html)\n\n* 简单用法\n  ```bash\n  awk [参数] 'awk代码'\n  awk [参数] -f awk脚本文件 \n  ```\n* 常用参数\n  ```bash\n  cat xxx.txt | awk -F ':' 'BEGIN{}{printf(\"%s %s\", $1, $2);}END{printf(\"OK!\");}'\n  # -F 参数是指定对每行字符串以什么字符为分割，每个被分割的部分存储在变量：$1, $2, $3...中，整行字符串存储在$0中。\n  # BEGIN{}中的代码将在文本处理前执行，同样，END{}会文本处理后执行，{}中的代码用来处理每行的文本。\n  \n  cat xxx.txt | awk -v var1=${tmp} '{printf(\"%d\\n\", $3/var1);}'\n  # -v 参数是引入外部变量，把${tmp}赋值给var1，在awk内部代码中就可以使用var1了。\n  # -v参数可以多次引用，也就是说可以引入多个变量。\n  \n  cat xxx | awk -v var1=${tmp} '{\n  \tif ($1 ~ /eth/) {\n  \t\tprint $0;\n  \t}\n  }'\n  # 通过这种方式可以使用正则表达式进行字符串匹配。\n  # awk支持print，使用print末尾自动加上\\n。\n  ```\n\n* 内置变量\n\n| 变量 | 描述                                |\n| ---- | ----------------------------------- |\n| $n   | 当前记录的第n个字段，字段间由FS分隔 |\n| $0   | 完整的输入记录                      |\n| ARGC | 命令行参数的数目                    |\n|ARGIND\t|命令行中当前文件的位置(从0开始算)\nARGV\t包含命令行参数的数组|\n|CONVFMT|数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组|\n|ERRNO|最后一个系统错误的描述|\n|FIELDWIDTHS|字段宽度列表(用空格键分隔)|\n|FILENAME|当前文件名|\n|FNR|各文件分别计数的行号|\n|FS|字段分隔符(默认是任何空格)|\n|IGNORECASE|如果为真，则进行忽略大小写的匹配|\n|NF|一条记录的字段的数目|\n|NR|已经读出的记录数，就是行号，从1开始|\n|OFMT|数字的输出格式(默认值是%.6g)|\n|OFS|输出记录分隔符（输出换行符），输出时用指定的符号代替换行符|\n|ORS|输出记录分隔符(默认值是一个换行符)|\n|RLENGTH|由match函数所匹配的字符串的长度|\n|RS|记录分隔符(默认是一个换行符)|\n|RSTART|由match函数所匹配的字符串的第一个位置|\n|SUBSEP|数组下标分隔符(默认值是/034)|\n\n* 运算符\n\n| 运算符                  | 描述 |\n| ----------------------- | ---- |\n| = += -= *= /= %= ^= **= | 赋值 |\n|?:|C条件表达式\n| \\|\\||逻辑或|\n|&&|逻辑与|\n|~ 和 !~|匹配正则表达式和不匹配正则表达式|\n|< <= > >= != ==|关系运算符|\n|空格|连接|\n|+ -|加，减|\n|* / %|乘，除与求余|\n|+ - !\t|一元加，减和逻辑非|\n|^ ***|求幂|\n|++ --|增加或减少，作为前缀或后缀|\n|$|字段引用|\n|in|数组成员|\n","slug":"Linux三剑客之awk的使用","published":1,"updated":"2020-04-08T03:34:32.497Z","_id":"ck8qr69d9000f5d3abzf5hgma","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>awk 是一款极其强大的文本处理工具，其语言于c语言的语法极其相似，上手很容易<br>\n内置变量与运算符数据来自<a href=\"https://www.runoob.com/linux/linux-comm-awk.html\" target=\"_blank\" rel=\"noopener\">RUNOOB</a></p>\n</blockquote>\n<ul>\n<li>\n<p>简单用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk [参数] <span class=\"string\">'awk代码'</span></span><br><span class=\"line\">awk [参数] -f awk脚本文件</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>常用参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat xxx.txt | awk -F <span class=\"string\">':'</span> <span class=\"string\">'BEGIN&#123;&#125;&#123;printf(\"%s %s\", $1, $2);&#125;END&#123;printf(\"OK!\");&#125;'</span></span><br><span class=\"line\"><span class=\"comment\"># -F 参数是指定对每行字符串以什么字符为分割，每个被分割的部分存储在变量：$1, $2, $3...中，整行字符串存储在$0中。</span></span><br><span class=\"line\"><span class=\"comment\"># BEGIN&#123;&#125;中的代码将在文本处理前执行，同样，END&#123;&#125;会文本处理后执行，&#123;&#125;中的代码用来处理每行的文本。</span></span><br><span class=\"line\"></span><br><span class=\"line\">cat xxx.txt | awk -v var1=<span class=\"variable\">$&#123;tmp&#125;</span> <span class=\"string\">'&#123;printf(\"%d\\n\", $3/var1);&#125;'</span></span><br><span class=\"line\"><span class=\"comment\"># -v 参数是引入外部变量，把$&#123;tmp&#125;赋值给var1，在awk内部代码中就可以使用var1了。</span></span><br><span class=\"line\"><span class=\"comment\"># -v参数可以多次引用，也就是说可以引入多个变量。</span></span><br><span class=\"line\"></span><br><span class=\"line\">cat xxx | awk -v var1=<span class=\"variable\">$&#123;tmp&#125;</span> <span class=\"string\">'&#123;</span></span><br><span class=\"line\"><span class=\"string\">\tif ($1 ~ /eth/) &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\tprint $0;</span></span><br><span class=\"line\"><span class=\"string\">\t&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br><span class=\"line\"><span class=\"comment\"># 通过这种方式可以使用正则表达式进行字符串匹配。</span></span><br><span class=\"line\"><span class=\"comment\"># awk支持print，使用print末尾自动加上\\n。</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>内置变量</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$n</td>\n<td>当前记录的第n个字段，字段间由FS分隔</td>\n</tr>\n<tr>\n<td>$0</td>\n<td>完整的输入记录</td>\n</tr>\n<tr>\n<td>ARGC</td>\n<td>命令行参数的数目</td>\n</tr>\n<tr>\n<td>ARGIND</td>\n<td>命令行中当前文件的位置(从0开始算)</td>\n</tr>\n<tr>\n<td>ARGV\t包含命令行参数的数组</td>\n<td></td>\n</tr>\n<tr>\n<td>CONVFMT</td>\n<td>数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</td>\n</tr>\n<tr>\n<td>ERRNO</td>\n<td>最后一个系统错误的描述</td>\n</tr>\n<tr>\n<td>FIELDWIDTHS</td>\n<td>字段宽度列表(用空格键分隔)</td>\n</tr>\n<tr>\n<td>FILENAME</td>\n<td>当前文件名</td>\n</tr>\n<tr>\n<td>FNR</td>\n<td>各文件分别计数的行号</td>\n</tr>\n<tr>\n<td>FS</td>\n<td>字段分隔符(默认是任何空格)</td>\n</tr>\n<tr>\n<td>IGNORECASE</td>\n<td>如果为真，则进行忽略大小写的匹配</td>\n</tr>\n<tr>\n<td>NF</td>\n<td>一条记录的字段的数目</td>\n</tr>\n<tr>\n<td>NR</td>\n<td>已经读出的记录数，就是行号，从1开始</td>\n</tr>\n<tr>\n<td>OFMT</td>\n<td>数字的输出格式(默认值是%.6g)</td>\n</tr>\n<tr>\n<td>OFS</td>\n<td>输出记录分隔符（输出换行符），输出时用指定的符号代替换行符</td>\n</tr>\n<tr>\n<td>ORS</td>\n<td>输出记录分隔符(默认值是一个换行符)</td>\n</tr>\n<tr>\n<td>RLENGTH</td>\n<td>由match函数所匹配的字符串的长度</td>\n</tr>\n<tr>\n<td>RS</td>\n<td>记录分隔符(默认是一个换行符)</td>\n</tr>\n<tr>\n<td>RSTART</td>\n<td>由match函数所匹配的字符串的第一个位置</td>\n</tr>\n<tr>\n<td>SUBSEP</td>\n<td>数组下标分隔符(默认值是/034)</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>运算符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>= += -= *= /= %= ^= **=</td>\n<td>赋值</td>\n</tr>\n<tr>\n<td>?:</td>\n<td>C条件表达式</td>\n</tr>\n<tr>\n<td>||</td>\n<td>逻辑或</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>逻辑与</td>\n</tr>\n<tr>\n<td>~ 和 !~</td>\n<td>匹配正则表达式和不匹配正则表达式</td>\n</tr>\n<tr>\n<td>&lt; &lt;= &gt; &gt;= != ==</td>\n<td>关系运算符</td>\n</tr>\n<tr>\n<td>空格</td>\n<td>连接</td>\n</tr>\n<tr>\n<td>+ -</td>\n<td>加，减</td>\n</tr>\n<tr>\n<td>* / %</td>\n<td>乘，除与求余</td>\n</tr>\n<tr>\n<td>+ - !</td>\n<td>一元加，减和逻辑非</td>\n</tr>\n<tr>\n<td>^ ***</td>\n<td>求幂</td>\n</tr>\n<tr>\n<td>++ –</td>\n<td>增加或减少，作为前缀或后缀</td>\n</tr>\n<tr>\n<td>$</td>\n<td>字段引用</td>\n</tr>\n<tr>\n<td>in</td>\n<td>数组成员</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>awk 是一款极其强大的文本处理工具，其语言于c语言的语法极其相似，上手很容易<br>\n内置变量与运算符数据来自<a href=\"https://www.runoob.com/linux/linux-comm-awk.html\" target=\"_blank\" rel=\"noopener\">RUNOOB</a></p>\n</blockquote>\n<ul>\n<li>\n<p>简单用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk [参数] <span class=\"string\">'awk代码'</span></span><br><span class=\"line\">awk [参数] -f awk脚本文件</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>常用参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat xxx.txt | awk -F <span class=\"string\">':'</span> <span class=\"string\">'BEGIN&#123;&#125;&#123;printf(\"%s %s\", $1, $2);&#125;END&#123;printf(\"OK!\");&#125;'</span></span><br><span class=\"line\"><span class=\"comment\"># -F 参数是指定对每行字符串以什么字符为分割，每个被分割的部分存储在变量：$1, $2, $3...中，整行字符串存储在$0中。</span></span><br><span class=\"line\"><span class=\"comment\"># BEGIN&#123;&#125;中的代码将在文本处理前执行，同样，END&#123;&#125;会文本处理后执行，&#123;&#125;中的代码用来处理每行的文本。</span></span><br><span class=\"line\"></span><br><span class=\"line\">cat xxx.txt | awk -v var1=<span class=\"variable\">$&#123;tmp&#125;</span> <span class=\"string\">'&#123;printf(\"%d\\n\", $3/var1);&#125;'</span></span><br><span class=\"line\"><span class=\"comment\"># -v 参数是引入外部变量，把$&#123;tmp&#125;赋值给var1，在awk内部代码中就可以使用var1了。</span></span><br><span class=\"line\"><span class=\"comment\"># -v参数可以多次引用，也就是说可以引入多个变量。</span></span><br><span class=\"line\"></span><br><span class=\"line\">cat xxx | awk -v var1=<span class=\"variable\">$&#123;tmp&#125;</span> <span class=\"string\">'&#123;</span></span><br><span class=\"line\"><span class=\"string\">\tif ($1 ~ /eth/) &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\tprint $0;</span></span><br><span class=\"line\"><span class=\"string\">\t&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br><span class=\"line\"><span class=\"comment\"># 通过这种方式可以使用正则表达式进行字符串匹配。</span></span><br><span class=\"line\"><span class=\"comment\"># awk支持print，使用print末尾自动加上\\n。</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>内置变量</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$n</td>\n<td>当前记录的第n个字段，字段间由FS分隔</td>\n</tr>\n<tr>\n<td>$0</td>\n<td>完整的输入记录</td>\n</tr>\n<tr>\n<td>ARGC</td>\n<td>命令行参数的数目</td>\n</tr>\n<tr>\n<td>ARGIND</td>\n<td>命令行中当前文件的位置(从0开始算)</td>\n</tr>\n<tr>\n<td>ARGV\t包含命令行参数的数组</td>\n<td></td>\n</tr>\n<tr>\n<td>CONVFMT</td>\n<td>数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</td>\n</tr>\n<tr>\n<td>ERRNO</td>\n<td>最后一个系统错误的描述</td>\n</tr>\n<tr>\n<td>FIELDWIDTHS</td>\n<td>字段宽度列表(用空格键分隔)</td>\n</tr>\n<tr>\n<td>FILENAME</td>\n<td>当前文件名</td>\n</tr>\n<tr>\n<td>FNR</td>\n<td>各文件分别计数的行号</td>\n</tr>\n<tr>\n<td>FS</td>\n<td>字段分隔符(默认是任何空格)</td>\n</tr>\n<tr>\n<td>IGNORECASE</td>\n<td>如果为真，则进行忽略大小写的匹配</td>\n</tr>\n<tr>\n<td>NF</td>\n<td>一条记录的字段的数目</td>\n</tr>\n<tr>\n<td>NR</td>\n<td>已经读出的记录数，就是行号，从1开始</td>\n</tr>\n<tr>\n<td>OFMT</td>\n<td>数字的输出格式(默认值是%.6g)</td>\n</tr>\n<tr>\n<td>OFS</td>\n<td>输出记录分隔符（输出换行符），输出时用指定的符号代替换行符</td>\n</tr>\n<tr>\n<td>ORS</td>\n<td>输出记录分隔符(默认值是一个换行符)</td>\n</tr>\n<tr>\n<td>RLENGTH</td>\n<td>由match函数所匹配的字符串的长度</td>\n</tr>\n<tr>\n<td>RS</td>\n<td>记录分隔符(默认是一个换行符)</td>\n</tr>\n<tr>\n<td>RSTART</td>\n<td>由match函数所匹配的字符串的第一个位置</td>\n</tr>\n<tr>\n<td>SUBSEP</td>\n<td>数组下标分隔符(默认值是/034)</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>运算符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>= += -= *= /= %= ^= **=</td>\n<td>赋值</td>\n</tr>\n<tr>\n<td>?:</td>\n<td>C条件表达式</td>\n</tr>\n<tr>\n<td>||</td>\n<td>逻辑或</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>逻辑与</td>\n</tr>\n<tr>\n<td>~ 和 !~</td>\n<td>匹配正则表达式和不匹配正则表达式</td>\n</tr>\n<tr>\n<td>&lt; &lt;= &gt; &gt;= != ==</td>\n<td>关系运算符</td>\n</tr>\n<tr>\n<td>空格</td>\n<td>连接</td>\n</tr>\n<tr>\n<td>+ -</td>\n<td>加，减</td>\n</tr>\n<tr>\n<td>* / %</td>\n<td>乘，除与求余</td>\n</tr>\n<tr>\n<td>+ - !</td>\n<td>一元加，减和逻辑非</td>\n</tr>\n<tr>\n<td>^ ***</td>\n<td>求幂</td>\n</tr>\n<tr>\n<td>++ –</td>\n<td>增加或减少，作为前缀或后缀</td>\n</tr>\n<tr>\n<td>$</td>\n<td>字段引用</td>\n</tr>\n<tr>\n<td>in</td>\n<td>数组成员</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"POJ-1979","date":"2019-09-02T08:49:24.000Z","cover":"title.jpg","_content":"\n* 原题目：\n  Description\n  There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can't move on red tiles, he can move only on black tiles. \n  Write a program to count the number of black tiles which he can reach by repeating the moves described above.\n  Input\n  The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. \n  There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. \n  '.' - a black tile \n  '#' - a red tile \n  '@' - a man on a black tile(appears exactly once in a data set) \n  The end of the input is indicated by a line consisting of two zeros.\n  Output\n  > For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).\n\n  Sample Input\n  ```txt\n  6 9\n  ....#.\n  .....#\n  ......\n  ......\n  ......\n  ......\n  ......\n  #@...#\n  .#..#.\n  11 9\n  .#.........\n  .#.#######.\n  .#.#.....#.\n  .#.#.###.#.\n  .#.#..@#.#.\n  .#.#####.#.\n  .#.......#.\n  .#########.\n  ...........\n  11 6\n  ..#..#..#..\n  ..#..#..#..\n  ..#..#..###\n  ..#..#..#@.\n  ..#..#..#..\n  ..#..#..#..\n  7 7\n  ..#.#..\n  ..#.#..\n  ###.###\n  ...@...\n  ###.###\n  ..#.#..\n  ..#.#..\n  0 0\n  ```\n  Sample Output\n  ```txt\n  45\n  59\n  6\n  13\n  ```\n\n* 题目大意：\n  给出一个w列和h行的方阵，方阵中有'.','#'和'@'。其中'.'是可以移动的地方，'#'是红色的砖，是不可以移动的地\t\t方，'@'是最初人的地点就（图的入口），人可以上下左右移动，以0 0 为结束。\n  要求输出人可以移动的砖的个数。该题利用搜索。\n>注意：\n>先输入w，然后输入h，但是w是列数，h是行数。\n\n* 代码：\n```c++\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nvoid dfs(int x,int y);\nint w,h,tmp=0;\n\nchar ma[100][100];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nint main(){\n\twhile(cin>>h>>w){\n\t\tif(w==0&&h==0)  break;\n\t\tmemset(ma,'0',sizeof(ma));\n\t\tint ax,ay;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tcin>>ma[i][j];\n\t\t\t\tif(ma[i][j]=='@'){\n\t\t\t\t\tax=i;\n\t\t\t\t\tay=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp=0;\n\t\tdfs(ax,ay);\n\t\tcout<<tmp<<endl;\n\t}\n\treturn 0;\n}\n\nvoid dfs(int x,int y){\n\tma[x][y]='#';\n\ttmp++;\n\tfor(int i=0;i<4;i++){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(ma[nx][ny]=='.'&&nx>=0&&nx<w&&ny>=0&&ny<h&&ma[nx][ny]=='.'){\n\t\t\tdfs(nx,ny);\n\t\t}\n\t}\n}\nSelect Code\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nvoid dfs(int x,int y);\nint w,h,tmp=0;\n\nchar ma[100][100];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nint main(){\n\twhile(cin>>h>>w){\n\t\tif(w==0&&h==0)  break;\n\t\tmemset(ma,'0',sizeof(ma));\n\t\tint ax,ay;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tcin>>ma[i][j];\n\t\t\t\tif(ma[i][j]=='@'){\n\t\t\t\t\tax=i;\n\t\t\t\t\tay=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp=0;\n\t\tdfs(ax,ay);\n\t\tcout<<tmp<<endl;\n\t}\n\treturn 0;\n}\n\nvoid dfs(int x,int y){\n\tma[x][y]='#';\n\ttmp++;\n\tfor(int i=0;i<4;i++){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(ma[nx][ny]=='.'&&nx>=0&&nx<w&&ny>=0&&ny<h&&ma[nx][ny]=='.'){\n\t\t\tdfs(nx,ny);\n\t\t}\n\t}\n}\n```\n> POJ上不支持`bits/stdc++`的头文件，很尴尬。\n","source":"_posts/POJ-1979.md","raw":"---\ntitle: POJ-1979\ndate: 2019-09-02 16:49:24\ncover: title.jpg\ntags:\n- 题解\n- POJ\n---\n\n* 原题目：\n  Description\n  There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can't move on red tiles, he can move only on black tiles. \n  Write a program to count the number of black tiles which he can reach by repeating the moves described above.\n  Input\n  The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. \n  There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. \n  '.' - a black tile \n  '#' - a red tile \n  '@' - a man on a black tile(appears exactly once in a data set) \n  The end of the input is indicated by a line consisting of two zeros.\n  Output\n  > For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).\n\n  Sample Input\n  ```txt\n  6 9\n  ....#.\n  .....#\n  ......\n  ......\n  ......\n  ......\n  ......\n  #@...#\n  .#..#.\n  11 9\n  .#.........\n  .#.#######.\n  .#.#.....#.\n  .#.#.###.#.\n  .#.#..@#.#.\n  .#.#####.#.\n  .#.......#.\n  .#########.\n  ...........\n  11 6\n  ..#..#..#..\n  ..#..#..#..\n  ..#..#..###\n  ..#..#..#@.\n  ..#..#..#..\n  ..#..#..#..\n  7 7\n  ..#.#..\n  ..#.#..\n  ###.###\n  ...@...\n  ###.###\n  ..#.#..\n  ..#.#..\n  0 0\n  ```\n  Sample Output\n  ```txt\n  45\n  59\n  6\n  13\n  ```\n\n* 题目大意：\n  给出一个w列和h行的方阵，方阵中有'.','#'和'@'。其中'.'是可以移动的地方，'#'是红色的砖，是不可以移动的地\t\t方，'@'是最初人的地点就（图的入口），人可以上下左右移动，以0 0 为结束。\n  要求输出人可以移动的砖的个数。该题利用搜索。\n>注意：\n>先输入w，然后输入h，但是w是列数，h是行数。\n\n* 代码：\n```c++\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nvoid dfs(int x,int y);\nint w,h,tmp=0;\n\nchar ma[100][100];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nint main(){\n\twhile(cin>>h>>w){\n\t\tif(w==0&&h==0)  break;\n\t\tmemset(ma,'0',sizeof(ma));\n\t\tint ax,ay;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tcin>>ma[i][j];\n\t\t\t\tif(ma[i][j]=='@'){\n\t\t\t\t\tax=i;\n\t\t\t\t\tay=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp=0;\n\t\tdfs(ax,ay);\n\t\tcout<<tmp<<endl;\n\t}\n\treturn 0;\n}\n\nvoid dfs(int x,int y){\n\tma[x][y]='#';\n\ttmp++;\n\tfor(int i=0;i<4;i++){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(ma[nx][ny]=='.'&&nx>=0&&nx<w&&ny>=0&&ny<h&&ma[nx][ny]=='.'){\n\t\t\tdfs(nx,ny);\n\t\t}\n\t}\n}\nSelect Code\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nvoid dfs(int x,int y);\nint w,h,tmp=0;\n\nchar ma[100][100];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nint main(){\n\twhile(cin>>h>>w){\n\t\tif(w==0&&h==0)  break;\n\t\tmemset(ma,'0',sizeof(ma));\n\t\tint ax,ay;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tcin>>ma[i][j];\n\t\t\t\tif(ma[i][j]=='@'){\n\t\t\t\t\tax=i;\n\t\t\t\t\tay=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp=0;\n\t\tdfs(ax,ay);\n\t\tcout<<tmp<<endl;\n\t}\n\treturn 0;\n}\n\nvoid dfs(int x,int y){\n\tma[x][y]='#';\n\ttmp++;\n\tfor(int i=0;i<4;i++){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(ma[nx][ny]=='.'&&nx>=0&&nx<w&&ny>=0&&ny<h&&ma[nx][ny]=='.'){\n\t\t\tdfs(nx,ny);\n\t\t}\n\t}\n}\n```\n> POJ上不支持`bits/stdc++`的头文件，很尴尬。\n","slug":"POJ-1979","published":1,"updated":"2020-04-08T03:39:32.239Z","_id":"ck8qr69da000h5d3avd58szod","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>\n<p>原题目：<br>\nDescription<br>\nThere is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.<br>\nWrite a program to count the number of black tiles which he can reach by repeating the moves described above.<br>\nInput<br>\nThe input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.<br>\nThere are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.<br>\n‘.’ - a black tile<br>\n‘#’ - a red tile<br>\n‘@’ - a man on a black tile(appears exactly once in a data set)<br>\nThe end of the input is indicated by a line consisting of two zeros.<br>\nOutput</p>\n<blockquote>\n<p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).</p>\n</blockquote>\n<p>Sample Input</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 9</span><br><span class=\"line\">....#.</span><br><span class=\"line\">.....#</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br><span class=\"line\">#@...#</span><br><span class=\"line\">.#..#.</span><br><span class=\"line\">11 9</span><br><span class=\"line\">.#.........</span><br><span class=\"line\">.#.#######.</span><br><span class=\"line\">.#.#.....#.</span><br><span class=\"line\">.#.#.###.#.</span><br><span class=\"line\">.#.#..@#.#.</span><br><span class=\"line\">.#.#####.#.</span><br><span class=\"line\">.#.......#.</span><br><span class=\"line\">.#########.</span><br><span class=\"line\">...........</span><br><span class=\"line\">11 6</span><br><span class=\"line\">..#..#..#..</span><br><span class=\"line\">..#..#..#..</span><br><span class=\"line\">..#..#..###</span><br><span class=\"line\">..#..#..#@.</span><br><span class=\"line\">..#..#..#..</span><br><span class=\"line\">..#..#..#..</span><br><span class=\"line\">7 7</span><br><span class=\"line\">..#.#..</span><br><span class=\"line\">..#.#..</span><br><span class=\"line\">###.###</span><br><span class=\"line\">...@...</span><br><span class=\"line\">###.###</span><br><span class=\"line\">..#.#..</span><br><span class=\"line\">..#.#..</span><br><span class=\"line\">0 0</span><br></pre></td></tr></table></figure>\n<p>Sample Output</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">45</span><br><span class=\"line\">59</span><br><span class=\"line\">6</span><br><span class=\"line\">13</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>题目大意：<br>\n给出一个w列和h行的方阵，方阵中有’.’,’#‘和’@’。其中’.‘是可以移动的地方，’#‘是红色的砖，是不可以移动的地\t\t方，’@'是最初人的地点就（图的入口），人可以上下左右移动，以0 0 为结束。<br>\n要求输出人可以移动的砖的个数。该题利用搜索。</p>\n</li>\n</ul>\n<blockquote>\n<p>注意：<br>\n先输入w，然后输入h，但是w是列数，h是行数。</p>\n</blockquote>\n<ul>\n<li>代码：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> w,h,tmp=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> ma[<span class=\"number\">100</span>][<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[<span class=\"number\">4</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[<span class=\"number\">4</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;h&gt;&gt;w)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(w==<span class=\"number\">0</span>&amp;&amp;h==<span class=\"number\">0</span>)  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(ma,<span class=\"string\">'0'</span>,<span class=\"keyword\">sizeof</span>(ma));</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ax,ay;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;w;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;h;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;ma[i][j];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ma[i][j]==<span class=\"string\">'@'</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tax=i;</span><br><span class=\"line\">\t\t\t\t\tay=j;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttmp=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tdfs(ax,ay);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;tmp&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tma[x][y]=<span class=\"string\">'#'</span>;</span><br><span class=\"line\">\ttmp++;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> nx=x+dx[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ny=y+dy[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ma[nx][ny]==<span class=\"string\">'.'</span>&amp;&amp;nx&gt;=<span class=\"number\">0</span>&amp;&amp;nx&lt;w&amp;&amp;ny&gt;=<span class=\"number\">0</span>&amp;&amp;ny&lt;h&amp;&amp;ma[nx][ny]==<span class=\"string\">'.'</span>)&#123;</span><br><span class=\"line\">\t\t\tdfs(nx,ny);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Select Code</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> w,h,tmp=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> ma[<span class=\"number\">100</span>][<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[<span class=\"number\">4</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[<span class=\"number\">4</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;h&gt;&gt;w)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(w==<span class=\"number\">0</span>&amp;&amp;h==<span class=\"number\">0</span>)  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(ma,<span class=\"string\">'0'</span>,<span class=\"keyword\">sizeof</span>(ma));</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ax,ay;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;w;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;h;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;ma[i][j];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ma[i][j]==<span class=\"string\">'@'</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tax=i;</span><br><span class=\"line\">\t\t\t\t\tay=j;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttmp=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tdfs(ax,ay);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;tmp&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tma[x][y]=<span class=\"string\">'#'</span>;</span><br><span class=\"line\">\ttmp++;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> nx=x+dx[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ny=y+dy[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ma[nx][ny]==<span class=\"string\">'.'</span>&amp;&amp;nx&gt;=<span class=\"number\">0</span>&amp;&amp;nx&lt;w&amp;&amp;ny&gt;=<span class=\"number\">0</span>&amp;&amp;ny&lt;h&amp;&amp;ma[nx][ny]==<span class=\"string\">'.'</span>)&#123;</span><br><span class=\"line\">\t\t\tdfs(nx,ny);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>POJ上不支持<code>bits/stdc++</code>的头文件，很尴尬。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>\n<p>原题目：<br>\nDescription<br>\nThere is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.<br>\nWrite a program to count the number of black tiles which he can reach by repeating the moves described above.<br>\nInput<br>\nThe input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.<br>\nThere are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.<br>\n‘.’ - a black tile<br>\n‘#’ - a red tile<br>\n‘@’ - a man on a black tile(appears exactly once in a data set)<br>\nThe end of the input is indicated by a line consisting of two zeros.<br>\nOutput</p>\n<blockquote>\n<p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).</p>\n</blockquote>\n<p>Sample Input</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 9</span><br><span class=\"line\">....#.</span><br><span class=\"line\">.....#</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br><span class=\"line\">#@...#</span><br><span class=\"line\">.#..#.</span><br><span class=\"line\">11 9</span><br><span class=\"line\">.#.........</span><br><span class=\"line\">.#.#######.</span><br><span class=\"line\">.#.#.....#.</span><br><span class=\"line\">.#.#.###.#.</span><br><span class=\"line\">.#.#..@#.#.</span><br><span class=\"line\">.#.#####.#.</span><br><span class=\"line\">.#.......#.</span><br><span class=\"line\">.#########.</span><br><span class=\"line\">...........</span><br><span class=\"line\">11 6</span><br><span class=\"line\">..#..#..#..</span><br><span class=\"line\">..#..#..#..</span><br><span class=\"line\">..#..#..###</span><br><span class=\"line\">..#..#..#@.</span><br><span class=\"line\">..#..#..#..</span><br><span class=\"line\">..#..#..#..</span><br><span class=\"line\">7 7</span><br><span class=\"line\">..#.#..</span><br><span class=\"line\">..#.#..</span><br><span class=\"line\">###.###</span><br><span class=\"line\">...@...</span><br><span class=\"line\">###.###</span><br><span class=\"line\">..#.#..</span><br><span class=\"line\">..#.#..</span><br><span class=\"line\">0 0</span><br></pre></td></tr></table></figure>\n<p>Sample Output</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">45</span><br><span class=\"line\">59</span><br><span class=\"line\">6</span><br><span class=\"line\">13</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>题目大意：<br>\n给出一个w列和h行的方阵，方阵中有’.’,’#‘和’@’。其中’.‘是可以移动的地方，’#‘是红色的砖，是不可以移动的地\t\t方，’@'是最初人的地点就（图的入口），人可以上下左右移动，以0 0 为结束。<br>\n要求输出人可以移动的砖的个数。该题利用搜索。</p>\n</li>\n</ul>\n<blockquote>\n<p>注意：<br>\n先输入w，然后输入h，但是w是列数，h是行数。</p>\n</blockquote>\n<ul>\n<li>代码：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> w,h,tmp=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> ma[<span class=\"number\">100</span>][<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[<span class=\"number\">4</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[<span class=\"number\">4</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;h&gt;&gt;w)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(w==<span class=\"number\">0</span>&amp;&amp;h==<span class=\"number\">0</span>)  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(ma,<span class=\"string\">'0'</span>,<span class=\"keyword\">sizeof</span>(ma));</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ax,ay;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;w;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;h;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;ma[i][j];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ma[i][j]==<span class=\"string\">'@'</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tax=i;</span><br><span class=\"line\">\t\t\t\t\tay=j;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttmp=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tdfs(ax,ay);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;tmp&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tma[x][y]=<span class=\"string\">'#'</span>;</span><br><span class=\"line\">\ttmp++;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> nx=x+dx[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ny=y+dy[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ma[nx][ny]==<span class=\"string\">'.'</span>&amp;&amp;nx&gt;=<span class=\"number\">0</span>&amp;&amp;nx&lt;w&amp;&amp;ny&gt;=<span class=\"number\">0</span>&amp;&amp;ny&lt;h&amp;&amp;ma[nx][ny]==<span class=\"string\">'.'</span>)&#123;</span><br><span class=\"line\">\t\t\tdfs(nx,ny);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Select Code</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> w,h,tmp=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> ma[<span class=\"number\">100</span>][<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[<span class=\"number\">4</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[<span class=\"number\">4</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;h&gt;&gt;w)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(w==<span class=\"number\">0</span>&amp;&amp;h==<span class=\"number\">0</span>)  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(ma,<span class=\"string\">'0'</span>,<span class=\"keyword\">sizeof</span>(ma));</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ax,ay;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;w;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;h;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;ma[i][j];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ma[i][j]==<span class=\"string\">'@'</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tax=i;</span><br><span class=\"line\">\t\t\t\t\tay=j;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttmp=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tdfs(ax,ay);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;tmp&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tma[x][y]=<span class=\"string\">'#'</span>;</span><br><span class=\"line\">\ttmp++;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> nx=x+dx[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ny=y+dy[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ma[nx][ny]==<span class=\"string\">'.'</span>&amp;&amp;nx&gt;=<span class=\"number\">0</span>&amp;&amp;nx&lt;w&amp;&amp;ny&gt;=<span class=\"number\">0</span>&amp;&amp;ny&lt;h&amp;&amp;ma[nx][ny]==<span class=\"string\">'.'</span>)&#123;</span><br><span class=\"line\">\t\t\tdfs(nx,ny);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>POJ上不支持<code>bits/stdc++</code>的头文件，很尴尬。</p>\n</blockquote>\n"},{"title":"linux三剑客之grep的使用","date":"2019-09-02T08:34:08.000Z","cover":"title.jpg","_content":"\n> 部分内容源自网络和grep帮助信息。\n\n## 用法\n\n```bash\ngrep [参数选项] [模式串] [文件或目录]\n```\n\n\n\n## 常用参数选项说明\n\n* `-o`只显示与模式串匹配的内容。\n\n* `-E` 使用扩展正则表达式。\n\n  栗子：\n\n  ```\n  cat index.html | grep -Eo '<img\\ [^>]*'\n  ```\n\n  \n\n* `-v`显示与模式串不匹配内容所在的整行内容。\n\n* `-w`只匹配整个单词，也就说只有独立的整个单词斗鱼模式串匹配才算。\n\n* `-x`只匹配整行，也就说只有整行都与模式串匹配才算。\n\n* `-i`忽略大小写。\n\n* `-H`显示每个符合样式字符串所在行所属的文件名。\n\n* `-n`显示行号。\n\n* `-I`忽略二进制文件。\n\n\n\n---\n\n更多用法请查看man手册或`grep --help` \n","source":"_posts/linux三剑客之grep的使用.md","raw":"---\ntitle: linux三剑客之grep的使用\ndate: 2019-09-02 16:34:08\ncover: title.jpg\ntags: note\n---\n\n> 部分内容源自网络和grep帮助信息。\n\n## 用法\n\n```bash\ngrep [参数选项] [模式串] [文件或目录]\n```\n\n\n\n## 常用参数选项说明\n\n* `-o`只显示与模式串匹配的内容。\n\n* `-E` 使用扩展正则表达式。\n\n  栗子：\n\n  ```\n  cat index.html | grep -Eo '<img\\ [^>]*'\n  ```\n\n  \n\n* `-v`显示与模式串不匹配内容所在的整行内容。\n\n* `-w`只匹配整个单词，也就说只有独立的整个单词斗鱼模式串匹配才算。\n\n* `-x`只匹配整行，也就说只有整行都与模式串匹配才算。\n\n* `-i`忽略大小写。\n\n* `-H`显示每个符合样式字符串所在行所属的文件名。\n\n* `-n`显示行号。\n\n* `-I`忽略二进制文件。\n\n\n\n---\n\n更多用法请查看man手册或`grep --help` \n","slug":"linux三剑客之grep的使用","published":1,"updated":"2020-04-08T03:36:12.116Z","_id":"ck8qr69db000j5d3acz0ms85e","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>部分内容源自网络和grep帮助信息。</p>\n</blockquote>\n<h2 id=\"用法\"><a class=\"markdownIt-Anchor\" href=\"#用法\"></a> 用法</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [参数选项] [模式串] [文件或目录]</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用参数选项说明\"><a class=\"markdownIt-Anchor\" href=\"#常用参数选项说明\"></a> 常用参数选项说明</h2>\n<ul>\n<li>\n<p><code>-o</code>只显示与模式串匹配的内容。</p>\n</li>\n<li>\n<p><code>-E</code> 使用扩展正则表达式。</p>\n<p>栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat index.html | grep -Eo &apos;&lt;img\\ [^&gt;]*&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>-v</code>显示与模式串不匹配内容所在的整行内容。</p>\n</li>\n<li>\n<p><code>-w</code>只匹配整个单词，也就说只有独立的整个单词斗鱼模式串匹配才算。</p>\n</li>\n<li>\n<p><code>-x</code>只匹配整行，也就说只有整行都与模式串匹配才算。</p>\n</li>\n<li>\n<p><code>-i</code>忽略大小写。</p>\n</li>\n<li>\n<p><code>-H</code>显示每个符合样式字符串所在行所属的文件名。</p>\n</li>\n<li>\n<p><code>-n</code>显示行号。</p>\n</li>\n<li>\n<p><code>-I</code>忽略二进制文件。</p>\n</li>\n</ul>\n<hr>\n<p>更多用法请查看man手册或<code>grep --help</code></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>部分内容源自网络和grep帮助信息。</p>\n</blockquote>\n<h2 id=\"用法\"><a class=\"markdownIt-Anchor\" href=\"#用法\"></a> 用法</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [参数选项] [模式串] [文件或目录]</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用参数选项说明\"><a class=\"markdownIt-Anchor\" href=\"#常用参数选项说明\"></a> 常用参数选项说明</h2>\n<ul>\n<li>\n<p><code>-o</code>只显示与模式串匹配的内容。</p>\n</li>\n<li>\n<p><code>-E</code> 使用扩展正则表达式。</p>\n<p>栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat index.html | grep -Eo &apos;&lt;img\\ [^&gt;]*&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>-v</code>显示与模式串不匹配内容所在的整行内容。</p>\n</li>\n<li>\n<p><code>-w</code>只匹配整个单词，也就说只有独立的整个单词斗鱼模式串匹配才算。</p>\n</li>\n<li>\n<p><code>-x</code>只匹配整行，也就说只有整行都与模式串匹配才算。</p>\n</li>\n<li>\n<p><code>-i</code>忽略大小写。</p>\n</li>\n<li>\n<p><code>-H</code>显示每个符合样式字符串所在行所属的文件名。</p>\n</li>\n<li>\n<p><code>-n</code>显示行号。</p>\n</li>\n<li>\n<p><code>-I</code>忽略二进制文件。</p>\n</li>\n</ul>\n<hr>\n<p>更多用法请查看man手册或<code>grep --help</code></p>\n"},{"title":"hexo低成本搭建静态网页博客","date":"2019-09-16T04:01:15.000Z","cover":"title.jpg","_content":"\n\n\n\n\n## 引言\n好多同学有写博客的习惯，也有各大例如csd*、简*等博客平台。\n但是这些平台毕竟是盈利平台，无法做到对自己的博客完全掌控，有一丝丝的不爽快。想要DIY一下几乎不可能。在这里推荐同学们自己动手丰衣足食。\n## 准备知识\n1. github最基本的使用（拥有账号，会建立仓库，与本地电脑进行远程代码推送）。\n2. git最基本的使用（推送代码到远程例如github这种托管平台）。\n3. linux最基本的常用的命令（推荐linux平台）。\n## 原理解析\n* 托管与访问\n  github为每一个用户提供了免费的500M（貌似是）的空间，建立名称为`username.github.io`的仓库，可以把我们做好的博客静态网页放到该仓库中，然后使用`username.github.io`就可以访问我们的博客了。\n* 博客代码生成\n  使用hexo可以一行命令轻松生成可以高度定制的现成的博客代码，hexo官网还提供了大量的插件和主题供使用者DIY。\n## 搭建步骤\n> 此处忽略本地git与github绑定相关知识以及代码推送相关知识。\n> 这里本机环境使用linux（debian系）\n1. 在github平台上登录账号，新建名称为`username.github.io`的仓库备用。例如`sunowsir.github.io`（username是github用户名）\n2. 安装nodejs与npm环境（自行百度），确保`npm -v`正常显示。\n3. 安装hexo：`sudo npm install -g hexo-cli。\n4. 新建一个hexo项目：`hexo init 项目名称`。例如`hexo init MYclub`。\n5. 进入项目目录：`cd MYclub`。\n6. 创建新文章：`hexo new 文章标题`，生成一个markdown文件，在`source/_posts/`下。\n7. 配置文件：_config.yml\n8. 生成博客代码：`hexo g`，生成的博客代码在项目目录下的public目录中。\n9. 将public中所有的内容都push到之前创建的仓库中。\n10. 打开浏览器访问`username.github.io`看看。\n\n\n\n## 经验\n- npm报错\n  错误提示\n  ```bash\n  npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.0.7: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"linux\",\"arch\":\"x64\"})\n  ```\n  解决方案\n  ```bash\n  # 在博客根目录下\n  npm i -f\n  ```\n- 无法使用`hexo d`部署\n  1. _config.yml文件中，找到如下内容，替换`yourname`为你的github的名字，\n  ```bash\n  deploy:\n  type: git\n  repo: https://github.com/yourname/yourname.github.io.git\n  branch: master\n  message: 推送原因（例如：update some page ）\n  ```\n  2. 执行`npm install`，安装缺少的模块\n  3. 执行`npm clean`，清理缓存\n  4. 执行`hexo g`，重新构建\n  5. 执行`hexo d`，部署\n- markdown无序列表渲染异常\n　https://github.com/viosey/hexo-theme-material/issues/588\n\n  \n\n\n\n---\n[更多hexo相关参考](https://hexo.io/zh-cn/docs/)：https://hexo.io/zh-cn/docs/\n","source":"_posts/hexo低成本搭建静态网页博客.md","raw":"---\ntitle: hexo低成本搭建静态网页博客\ndate: 2019-09-16 12:01:15\ntags: note\ncover: title.jpg\n---\n\n\n\n\n\n## 引言\n好多同学有写博客的习惯，也有各大例如csd*、简*等博客平台。\n但是这些平台毕竟是盈利平台，无法做到对自己的博客完全掌控，有一丝丝的不爽快。想要DIY一下几乎不可能。在这里推荐同学们自己动手丰衣足食。\n## 准备知识\n1. github最基本的使用（拥有账号，会建立仓库，与本地电脑进行远程代码推送）。\n2. git最基本的使用（推送代码到远程例如github这种托管平台）。\n3. linux最基本的常用的命令（推荐linux平台）。\n## 原理解析\n* 托管与访问\n  github为每一个用户提供了免费的500M（貌似是）的空间，建立名称为`username.github.io`的仓库，可以把我们做好的博客静态网页放到该仓库中，然后使用`username.github.io`就可以访问我们的博客了。\n* 博客代码生成\n  使用hexo可以一行命令轻松生成可以高度定制的现成的博客代码，hexo官网还提供了大量的插件和主题供使用者DIY。\n## 搭建步骤\n> 此处忽略本地git与github绑定相关知识以及代码推送相关知识。\n> 这里本机环境使用linux（debian系）\n1. 在github平台上登录账号，新建名称为`username.github.io`的仓库备用。例如`sunowsir.github.io`（username是github用户名）\n2. 安装nodejs与npm环境（自行百度），确保`npm -v`正常显示。\n3. 安装hexo：`sudo npm install -g hexo-cli。\n4. 新建一个hexo项目：`hexo init 项目名称`。例如`hexo init MYclub`。\n5. 进入项目目录：`cd MYclub`。\n6. 创建新文章：`hexo new 文章标题`，生成一个markdown文件，在`source/_posts/`下。\n7. 配置文件：_config.yml\n8. 生成博客代码：`hexo g`，生成的博客代码在项目目录下的public目录中。\n9. 将public中所有的内容都push到之前创建的仓库中。\n10. 打开浏览器访问`username.github.io`看看。\n\n\n\n## 经验\n- npm报错\n  错误提示\n  ```bash\n  npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.0.7: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"linux\",\"arch\":\"x64\"})\n  ```\n  解决方案\n  ```bash\n  # 在博客根目录下\n  npm i -f\n  ```\n- 无法使用`hexo d`部署\n  1. _config.yml文件中，找到如下内容，替换`yourname`为你的github的名字，\n  ```bash\n  deploy:\n  type: git\n  repo: https://github.com/yourname/yourname.github.io.git\n  branch: master\n  message: 推送原因（例如：update some page ）\n  ```\n  2. 执行`npm install`，安装缺少的模块\n  3. 执行`npm clean`，清理缓存\n  4. 执行`hexo g`，重新构建\n  5. 执行`hexo d`，部署\n- markdown无序列表渲染异常\n　https://github.com/viosey/hexo-theme-material/issues/588\n\n  \n\n\n\n---\n[更多hexo相关参考](https://hexo.io/zh-cn/docs/)：https://hexo.io/zh-cn/docs/\n","slug":"hexo低成本搭建静态网页博客","published":1,"updated":"2020-04-08T03:33:35.430Z","_id":"ck8qr69dd000m5d3adydx0myt","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"引言\"><a class=\"markdownIt-Anchor\" href=\"#引言\"></a> 引言</h2>\n<p>好多同学有写博客的习惯，也有各大例如csd*、简*等博客平台。<br>\n但是这些平台毕竟是盈利平台，无法做到对自己的博客完全掌控，有一丝丝的不爽快。想要DIY一下几乎不可能。在这里推荐同学们自己动手丰衣足食。</p>\n<h2 id=\"准备知识\"><a class=\"markdownIt-Anchor\" href=\"#准备知识\"></a> 准备知识</h2>\n<ol>\n<li>github最基本的使用（拥有账号，会建立仓库，与本地电脑进行远程代码推送）。</li>\n<li>git最基本的使用（推送代码到远程例如github这种托管平台）。</li>\n<li>linux最基本的常用的命令（推荐linux平台）。</li>\n</ol>\n<h2 id=\"原理解析\"><a class=\"markdownIt-Anchor\" href=\"#原理解析\"></a> 原理解析</h2>\n<ul>\n<li>托管与访问<br>\ngithub为每一个用户提供了免费的500M（貌似是）的空间，建立名称为<code>username.github.io</code>的仓库，可以把我们做好的博客静态网页放到该仓库中，然后使用<code>username.github.io</code>就可以访问我们的博客了。</li>\n<li>博客代码生成<br>\n使用hexo可以一行命令轻松生成可以高度定制的现成的博客代码，hexo官网还提供了大量的插件和主题供使用者DIY。</li>\n</ul>\n<h2 id=\"搭建步骤\"><a class=\"markdownIt-Anchor\" href=\"#搭建步骤\"></a> 搭建步骤</h2>\n<blockquote>\n<p>此处忽略本地git与github绑定相关知识以及代码推送相关知识。<br>\n这里本机环境使用linux（debian系）</p>\n</blockquote>\n<ol>\n<li>在github平台上登录账号，新建名称为<code>username.github.io</code>的仓库备用。例如<code>sunowsir.github.io</code>（username是github用户名）</li>\n<li>安装nodejs与npm环境（自行百度），确保<code>npm -v</code>正常显示。</li>\n<li>安装hexo：`sudo npm install -g hexo-cli。</li>\n<li>新建一个hexo项目：<code>hexo init 项目名称</code>。例如<code>hexo init MYclub</code>。</li>\n<li>进入项目目录：<code>cd MYclub</code>。</li>\n<li>创建新文章：<code>hexo new 文章标题</code>，生成一个markdown文件，在<code>source/_posts/</code>下。</li>\n<li>配置文件：_config.yml</li>\n<li>生成博客代码：<code>hexo g</code>，生成的博客代码在项目目录下的public目录中。</li>\n<li>将public中所有的内容都push到之前创建的仓库中。</li>\n<li>打开浏览器访问<code>username.github.io</code>看看。</li>\n</ol>\n<h2 id=\"经验\"><a class=\"markdownIt-Anchor\" href=\"#经验\"></a> 经验</h2>\n<ul>\n<li>\n<p>npm报错<br>\n错误提示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform <span class=\"keyword\">for</span> fsevents@2.0.7: wanted &#123;<span class=\"string\">\"os\"</span>:<span class=\"string\">\"darwin\"</span>,<span class=\"string\">\"arch\"</span>:<span class=\"string\">\"any\"</span>&#125; (current: &#123;<span class=\"string\">\"os\"</span>:<span class=\"string\">\"linux\"</span>,<span class=\"string\">\"arch\"</span>:<span class=\"string\">\"x64\"</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>解决方案</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在博客根目录下</span></span><br><span class=\"line\">npm i -f</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>无法使用<code>hexo d</code>部署</p>\n<ol>\n<li>_config.yml文件中，找到如下内容，替换<code>yourname</code>为你的github的名字，</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\"><span class=\"built_in\">type</span>: git</span><br><span class=\"line\">repo: https://github.com/yourname/yourname.github.io.git</span><br><span class=\"line\">branch: master</span><br><span class=\"line\">message: 推送原因（例如：update some page ）</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>执行<code>npm install</code>，安装缺少的模块</li>\n<li>执行<code>npm clean</code>，清理缓存</li>\n<li>执行<code>hexo g</code>，重新构建</li>\n<li>执行<code>hexo d</code>，部署</li>\n</ol>\n</li>\n<li>\n<p>markdown无序列表渲染异常<br>\n　<a href=\"https://github.com/viosey/hexo-theme-material/issues/588\" target=\"_blank\" rel=\"noopener\">https://github.com/viosey/hexo-theme-material/issues/588</a></p>\n</li>\n</ul>\n<hr>\n<p><a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">更多hexo相关参考</a>：<a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a class=\"markdownIt-Anchor\" href=\"#引言\"></a> 引言</h2>\n<p>好多同学有写博客的习惯，也有各大例如csd*、简*等博客平台。<br>\n但是这些平台毕竟是盈利平台，无法做到对自己的博客完全掌控，有一丝丝的不爽快。想要DIY一下几乎不可能。在这里推荐同学们自己动手丰衣足食。</p>\n<h2 id=\"准备知识\"><a class=\"markdownIt-Anchor\" href=\"#准备知识\"></a> 准备知识</h2>\n<ol>\n<li>github最基本的使用（拥有账号，会建立仓库，与本地电脑进行远程代码推送）。</li>\n<li>git最基本的使用（推送代码到远程例如github这种托管平台）。</li>\n<li>linux最基本的常用的命令（推荐linux平台）。</li>\n</ol>\n<h2 id=\"原理解析\"><a class=\"markdownIt-Anchor\" href=\"#原理解析\"></a> 原理解析</h2>\n<ul>\n<li>托管与访问<br>\ngithub为每一个用户提供了免费的500M（貌似是）的空间，建立名称为<code>username.github.io</code>的仓库，可以把我们做好的博客静态网页放到该仓库中，然后使用<code>username.github.io</code>就可以访问我们的博客了。</li>\n<li>博客代码生成<br>\n使用hexo可以一行命令轻松生成可以高度定制的现成的博客代码，hexo官网还提供了大量的插件和主题供使用者DIY。</li>\n</ul>\n<h2 id=\"搭建步骤\"><a class=\"markdownIt-Anchor\" href=\"#搭建步骤\"></a> 搭建步骤</h2>\n<blockquote>\n<p>此处忽略本地git与github绑定相关知识以及代码推送相关知识。<br>\n这里本机环境使用linux（debian系）</p>\n</blockquote>\n<ol>\n<li>在github平台上登录账号，新建名称为<code>username.github.io</code>的仓库备用。例如<code>sunowsir.github.io</code>（username是github用户名）</li>\n<li>安装nodejs与npm环境（自行百度），确保<code>npm -v</code>正常显示。</li>\n<li>安装hexo：`sudo npm install -g hexo-cli。</li>\n<li>新建一个hexo项目：<code>hexo init 项目名称</code>。例如<code>hexo init MYclub</code>。</li>\n<li>进入项目目录：<code>cd MYclub</code>。</li>\n<li>创建新文章：<code>hexo new 文章标题</code>，生成一个markdown文件，在<code>source/_posts/</code>下。</li>\n<li>配置文件：_config.yml</li>\n<li>生成博客代码：<code>hexo g</code>，生成的博客代码在项目目录下的public目录中。</li>\n<li>将public中所有的内容都push到之前创建的仓库中。</li>\n<li>打开浏览器访问<code>username.github.io</code>看看。</li>\n</ol>\n<h2 id=\"经验\"><a class=\"markdownIt-Anchor\" href=\"#经验\"></a> 经验</h2>\n<ul>\n<li>\n<p>npm报错<br>\n错误提示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform <span class=\"keyword\">for</span> fsevents@2.0.7: wanted &#123;<span class=\"string\">\"os\"</span>:<span class=\"string\">\"darwin\"</span>,<span class=\"string\">\"arch\"</span>:<span class=\"string\">\"any\"</span>&#125; (current: &#123;<span class=\"string\">\"os\"</span>:<span class=\"string\">\"linux\"</span>,<span class=\"string\">\"arch\"</span>:<span class=\"string\">\"x64\"</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>解决方案</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在博客根目录下</span></span><br><span class=\"line\">npm i -f</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>无法使用<code>hexo d</code>部署</p>\n<ol>\n<li>_config.yml文件中，找到如下内容，替换<code>yourname</code>为你的github的名字，</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\"><span class=\"built_in\">type</span>: git</span><br><span class=\"line\">repo: https://github.com/yourname/yourname.github.io.git</span><br><span class=\"line\">branch: master</span><br><span class=\"line\">message: 推送原因（例如：update some page ）</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>执行<code>npm install</code>，安装缺少的模块</li>\n<li>执行<code>npm clean</code>，清理缓存</li>\n<li>执行<code>hexo g</code>，重新构建</li>\n<li>执行<code>hexo d</code>，部署</li>\n</ol>\n</li>\n<li>\n<p>markdown无序列表渲染异常<br>\n　<a href=\"https://github.com/viosey/hexo-theme-material/issues/588\" target=\"_blank\" rel=\"noopener\">https://github.com/viosey/hexo-theme-material/issues/588</a></p>\n</li>\n</ul>\n<hr>\n<p><a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">更多hexo相关参考</a>：<a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/</a></p>\n"},{"title":"deepin系统使用笔记","date":"2019-09-02T08:39:06.000Z","cover":"title.jpg","_content":"\n> 1. 如果你是小白用户并且没有人在旁边指导，那么建议不要自行更改本文给出的命令。\n> 2. 图形界面相关的东西自行探索。\n\n\n\n##  deepin系统安装后推荐配置\n`sudo apt-get install -y git wget curl openssh-server manpages-* graphviz`\n\n\n##  zsh配置（linux高级用户推荐）\n  1. 安装：`sudo apt-get install zsh`\n    \n  2. 设置为默认SHELL(不要加sudo)：`chsh -s /bin/zsh`\n  3. 安装oh-my-zsh\n```bash\nsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n  4. 手动配置oh-my-zsh\n       1. 安装自动跳转插件：\n           1.` sudo apt-get install autojump`\n           \t2. 打开~/.zshrc，在文件末尾，另起一行添加：`source   /usr/share/autojump/autojump.sh`\n           2. 安装zsh-syntax-highlighting语法高亮插件：\n             1. `cd ~/ && git clone https://github.com/zsh-users/zsh-syntax-highlighting.git`\n             2. `cd ~/ &&echo \"source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\" >> ${ZDOTDIR:-$HOME}/.zshrc`\n           3. 安装zsh-autosuggestions语法历史记录插件:\n             1. `git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions`\n             2. 打开~/.zshrc，在文件末尾，另起一行添加：`source $ZSH_CUSTOM/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh`\n        2. 打开~/.zshrc:\n            1. 找到：plugins=(git)这个位置，在括号里面添加，每个单词单独一行，如果已经有了，就不用添加了：\n                ```shell\n                \tgit\n                \textract\n                \tz\n                \tweb-search\n                \tzsh-autosuggestions\n                \tcp\n                \tcommand-not-found\n                ```\n\n                2. 在文件末尾，另起一行添加：\n                ```shell\n                export EDITOR=vim\n                setopt HIST_IGNORE_DUPS\n                setopt no_nomatch\n                ```\n  5. 自动配置oh-my-zsh\n\n```shell\n\n         #!/bin/bash\n         \n         \n         if [[ ${?} -eq 1 ]];\n         then\n             exit 1;\n         fi\n         \n         \n         sudo apt-get install autojump\n         git clone https://github.com/zsh-users/zsh-syntax-highlighting.git\n         git clone git://github.com/zsh-users/zsh-autosuggestions  ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions\n         \n         \n         echo '\n         \n         \n         \n         #########################################\n         \n         alias ls=\"ls --color=auto\"\n         alias dir=\"dir --color=auto\"\n         alias la=\"ls -a --color=auto\"\n         alias ll=\"ls -al --color=auto\"\n         alias vdir=\"vdir --color=auto\"\n         \n         alias grep=\"grep --color=auto\"\n         alias egrep=\"egrep --color=auto\"\n         alias fgrep=\"fgrep --color=auto\"\n         \n         alias cls=\"clear\"\n         \n         export EDITOR=vim\n         setopt no_nomatch\n         setopt HIST_IGNORE_DUPS\n         \n         source /usr/share/autojump/autojump.sh\n         source ~/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\n         \n         ' >>  ~/.zshrc\n         \n         \n         sed -i 's/^plugins=(git)/plugin=\\(extract \\n  z \\n web-search \\n  zsh-autosuggestions \\n cp \\n command-no-found\\)/g' ~/.zshrc\n         \n         \n         \n```\n\n6. 通过手动或自动配置，zsh就彻底配置完成。\n\n   ​     \n## 常见文件\n- 搜狗输入法皮肤所在路径：~/.config/sogou-qimpanel/skin\n- desktop软件图标路径集合：\n  - ~/.local/share/applications : AppImage应用生成的图标。\n  - /usr/share/applications/ :  常用应用图标所在。\n  - /etc/xdg/autostart/ : 系统级别自启动应用图标。\n  - /opt/deepinwine/apps/ : deepin-wine应用图标。\n  - /var/lib/flatpak/app/ : flatpak应用图标。\n    以上所给路径仅为常见路径，并非所有。\n- \n- \n## 常用命令（linux入门用户推荐）：\n  - ls : 列出当前路径文件。\n\n  - pwd : 查看当前所在路径（绝对路径）。\n  - cd : 路径跳转。\n\n  - mv : 文件及目录移动以及更改名字。\n  - cp : 拷贝。\n  - mkdir : 创建目录。\n  - touch : 创建空白文件。\n- 桌面设置壁纸的内置壁纸保存位置：\n  如图：\n\n  这些壁纸保存在：/usr/share/wallpapers/deepin下。\n- vim 配置文件：~/.vimrc（用户级别配置文件，只针文件所在用户生效，其他用户不生效）\n- bash配置文件：~/.bashrc（用户级别配置文件，只针文件所在用户生效，其他用户不生效）\n\n\n\n##  vim 入门操作\n  *  vim配置:\n     1. vim的配置我们选择ma6174的配置，\n         终端命令：wget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -x\n         配置完成后会重新回到终端命令行（建议在网络较好的环境下配置）\n     2. 配置完成后打开python文件会发现报错，解决方案：\n        点击这里下载python.zip文件，将压缩包下载到本地解压，得到一个名称为python的文件夹，将其复制（覆盖并替换）到～/.vim/ftplugin/路径下即可。\n  *  三种模式：\n     - \t插入模式：\n    1. 普通模式下按i直接进入插入模式。\n    2. 普通模式下按I光标前一个位置进入插入模式。\n    3. 普通模式下按O光标的下一行进入插入模式。\n    4. 普通模式下按o光标的上一行进入插入模式。\n  - 普通模式：\n    - 在任何模式下按ESC进入普通模式。\n    - 在普通模式下：\n      - dd : 剪切当前行（可以当删除用）（只在普通模式和选择模式生效）。\n      - yy：复制当前行（只在普通模式和选择模式生效）。\n      - p ： 粘贴（只在普通模式生效）。\n  - 选择模式：\n    - c : 进入块选择模式。\n    - C:  进入行选择模式。\n    - CTRL + c : 进入列选择模式。\n","source":"_posts/deepin系统使用笔记.md","raw":"---\ntitle: deepin系统使用笔记\ndate: 2019-09-02 16:39:06\ncover: title.jpg\ntags: note\n---\n\n> 1. 如果你是小白用户并且没有人在旁边指导，那么建议不要自行更改本文给出的命令。\n> 2. 图形界面相关的东西自行探索。\n\n\n\n##  deepin系统安装后推荐配置\n`sudo apt-get install -y git wget curl openssh-server manpages-* graphviz`\n\n\n##  zsh配置（linux高级用户推荐）\n  1. 安装：`sudo apt-get install zsh`\n    \n  2. 设置为默认SHELL(不要加sudo)：`chsh -s /bin/zsh`\n  3. 安装oh-my-zsh\n```bash\nsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n  4. 手动配置oh-my-zsh\n       1. 安装自动跳转插件：\n           1.` sudo apt-get install autojump`\n           \t2. 打开~/.zshrc，在文件末尾，另起一行添加：`source   /usr/share/autojump/autojump.sh`\n           2. 安装zsh-syntax-highlighting语法高亮插件：\n             1. `cd ~/ && git clone https://github.com/zsh-users/zsh-syntax-highlighting.git`\n             2. `cd ~/ &&echo \"source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\" >> ${ZDOTDIR:-$HOME}/.zshrc`\n           3. 安装zsh-autosuggestions语法历史记录插件:\n             1. `git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions`\n             2. 打开~/.zshrc，在文件末尾，另起一行添加：`source $ZSH_CUSTOM/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh`\n        2. 打开~/.zshrc:\n            1. 找到：plugins=(git)这个位置，在括号里面添加，每个单词单独一行，如果已经有了，就不用添加了：\n                ```shell\n                \tgit\n                \textract\n                \tz\n                \tweb-search\n                \tzsh-autosuggestions\n                \tcp\n                \tcommand-not-found\n                ```\n\n                2. 在文件末尾，另起一行添加：\n                ```shell\n                export EDITOR=vim\n                setopt HIST_IGNORE_DUPS\n                setopt no_nomatch\n                ```\n  5. 自动配置oh-my-zsh\n\n```shell\n\n         #!/bin/bash\n         \n         \n         if [[ ${?} -eq 1 ]];\n         then\n             exit 1;\n         fi\n         \n         \n         sudo apt-get install autojump\n         git clone https://github.com/zsh-users/zsh-syntax-highlighting.git\n         git clone git://github.com/zsh-users/zsh-autosuggestions  ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions\n         \n         \n         echo '\n         \n         \n         \n         #########################################\n         \n         alias ls=\"ls --color=auto\"\n         alias dir=\"dir --color=auto\"\n         alias la=\"ls -a --color=auto\"\n         alias ll=\"ls -al --color=auto\"\n         alias vdir=\"vdir --color=auto\"\n         \n         alias grep=\"grep --color=auto\"\n         alias egrep=\"egrep --color=auto\"\n         alias fgrep=\"fgrep --color=auto\"\n         \n         alias cls=\"clear\"\n         \n         export EDITOR=vim\n         setopt no_nomatch\n         setopt HIST_IGNORE_DUPS\n         \n         source /usr/share/autojump/autojump.sh\n         source ~/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\n         \n         ' >>  ~/.zshrc\n         \n         \n         sed -i 's/^plugins=(git)/plugin=\\(extract \\n  z \\n web-search \\n  zsh-autosuggestions \\n cp \\n command-no-found\\)/g' ~/.zshrc\n         \n         \n         \n```\n\n6. 通过手动或自动配置，zsh就彻底配置完成。\n\n   ​     \n## 常见文件\n- 搜狗输入法皮肤所在路径：~/.config/sogou-qimpanel/skin\n- desktop软件图标路径集合：\n  - ~/.local/share/applications : AppImage应用生成的图标。\n  - /usr/share/applications/ :  常用应用图标所在。\n  - /etc/xdg/autostart/ : 系统级别自启动应用图标。\n  - /opt/deepinwine/apps/ : deepin-wine应用图标。\n  - /var/lib/flatpak/app/ : flatpak应用图标。\n    以上所给路径仅为常见路径，并非所有。\n- \n- \n## 常用命令（linux入门用户推荐）：\n  - ls : 列出当前路径文件。\n\n  - pwd : 查看当前所在路径（绝对路径）。\n  - cd : 路径跳转。\n\n  - mv : 文件及目录移动以及更改名字。\n  - cp : 拷贝。\n  - mkdir : 创建目录。\n  - touch : 创建空白文件。\n- 桌面设置壁纸的内置壁纸保存位置：\n  如图：\n\n  这些壁纸保存在：/usr/share/wallpapers/deepin下。\n- vim 配置文件：~/.vimrc（用户级别配置文件，只针文件所在用户生效，其他用户不生效）\n- bash配置文件：~/.bashrc（用户级别配置文件，只针文件所在用户生效，其他用户不生效）\n\n\n\n##  vim 入门操作\n  *  vim配置:\n     1. vim的配置我们选择ma6174的配置，\n         终端命令：wget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -x\n         配置完成后会重新回到终端命令行（建议在网络较好的环境下配置）\n     2. 配置完成后打开python文件会发现报错，解决方案：\n        点击这里下载python.zip文件，将压缩包下载到本地解压，得到一个名称为python的文件夹，将其复制（覆盖并替换）到～/.vim/ftplugin/路径下即可。\n  *  三种模式：\n     - \t插入模式：\n    1. 普通模式下按i直接进入插入模式。\n    2. 普通模式下按I光标前一个位置进入插入模式。\n    3. 普通模式下按O光标的下一行进入插入模式。\n    4. 普通模式下按o光标的上一行进入插入模式。\n  - 普通模式：\n    - 在任何模式下按ESC进入普通模式。\n    - 在普通模式下：\n      - dd : 剪切当前行（可以当删除用）（只在普通模式和选择模式生效）。\n      - yy：复制当前行（只在普通模式和选择模式生效）。\n      - p ： 粘贴（只在普通模式生效）。\n  - 选择模式：\n    - c : 进入块选择模式。\n    - C:  进入行选择模式。\n    - CTRL + c : 进入列选择模式。\n","slug":"deepin系统使用笔记","published":1,"updated":"2020-04-08T03:30:00.829Z","_id":"ck8qr69de000o5d3a4w2l96lg","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<ol>\n<li>如果你是小白用户并且没有人在旁边指导，那么建议不要自行更改本文给出的命令。</li>\n<li>图形界面相关的东西自行探索。</li>\n</ol>\n</blockquote>\n<h2 id=\"deepin系统安装后推荐配置\"><a class=\"markdownIt-Anchor\" href=\"#deepin系统安装后推荐配置\"></a> deepin系统安装后推荐配置</h2>\n<p><code>sudo apt-get install -y git wget curl openssh-server manpages-* graphviz</code></p>\n<h2 id=\"zsh配置linux高级用户推荐\"><a class=\"markdownIt-Anchor\" href=\"#zsh配置linux高级用户推荐\"></a> zsh配置（linux高级用户推荐）</h2>\n<ol>\n<li>\n<p>安装：<code>sudo apt-get install zsh</code></p>\n</li>\n<li>\n<p>设置为默认SHELL(不要加sudo)：<code>chsh -s /bin/zsh</code></p>\n</li>\n<li>\n<p>安装oh-my-zsh</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>\"</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>\n<p>手动配置oh-my-zsh</p>\n<ol>\n<li>安装自动跳转插件：<br>\n1.<code>sudo apt-get install autojump</code><br>\n2. 打开~/.zshrc，在文件末尾，另起一行添加：<code>source /usr/share/autojump/autojump.sh</code><br>\n2. 安装zsh-syntax-highlighting语法高亮插件：\n<ol>\n<li><code>cd ~/ &amp;&amp; git clone https://github.com/zsh-users/zsh-syntax-highlighting.git</code></li>\n<li><code>cd ~/ &amp;&amp;echo &quot;source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; ${ZDOTDIR:-$HOME}/.zshrc</code></li>\n<li>安装zsh-autosuggestions语法历史记录插件:</li>\n<li><code>git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code></li>\n<li>打开~/.zshrc，在文件末尾，另起一行添加：<code>source $ZSH_CUSTOM/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh</code></li>\n</ol>\n</li>\n<li>打开~/.zshrc:\n<ol>\n<li>\n<p>找到：plugins=(git)这个位置，在括号里面添加，每个单词单独一行，如果已经有了，就不用添加了：</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git</span><br><span class=\"line\">extract</span><br><span class=\"line\">z</span><br><span class=\"line\">web-search</span><br><span class=\"line\">zsh-autosuggestions</span><br><span class=\"line\">cp</span><br><span class=\"line\">command-not-found</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在文件末尾，另起一行添加：</li>\n</ol>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export EDITOR=vim</span><br><span class=\"line\">setopt HIST_IGNORE_DUPS</span><br><span class=\"line\">setopt no_nomatch</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>自动配置oh-my-zsh</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if [[ $&#123;?&#125; -eq 1 ]];</span><br><span class=\"line\">then</span><br><span class=\"line\">    exit 1;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install autojump</span><br><span class=\"line\">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br><span class=\"line\">git clone git://github.com/zsh-users/zsh-autosuggestions  ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">echo '</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">########################################</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">alias ls=\"ls --color=auto\"</span><br><span class=\"line\">alias dir=\"dir --color=auto\"</span><br><span class=\"line\">alias la=\"ls -a --color=auto\"</span><br><span class=\"line\">alias ll=\"ls -al --color=auto\"</span><br><span class=\"line\">alias vdir=\"vdir --color=auto\"</span><br><span class=\"line\"></span><br><span class=\"line\">alias grep=\"grep --color=auto\"</span><br><span class=\"line\">alias egrep=\"egrep --color=auto\"</span><br><span class=\"line\">alias fgrep=\"fgrep --color=auto\"</span><br><span class=\"line\"></span><br><span class=\"line\">alias cls=\"clear\"</span><br><span class=\"line\"></span><br><span class=\"line\">export EDITOR=vim</span><br><span class=\"line\">setopt no_nomatch</span><br><span class=\"line\">setopt HIST_IGNORE_DUPS</span><br><span class=\"line\"></span><br><span class=\"line\">source /usr/share/autojump/autojump.sh</span><br><span class=\"line\">source ~/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class=\"line\"></span><br><span class=\"line\">' &gt;&gt;  ~/.zshrc</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sed -i 's/^plugins=(git)/plugin=\\(extract \\n  z \\n web-search \\n  zsh-autosuggestions \\n cp \\n command-no-found\\)/g' ~/.zshrc</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>\n<p>通过手动或自动配置，zsh就彻底配置完成。</p>\n<p>​</p>\n</li>\n</ol>\n<h2 id=\"常见文件\"><a class=\"markdownIt-Anchor\" href=\"#常见文件\"></a> 常见文件</h2>\n<ul>\n<li>搜狗输入法皮肤所在路径：~/.config/sogou-qimpanel/skin</li>\n<li>desktop软件图标路径集合：\n<ul>\n<li>~/.local/share/applications : AppImage应用生成的图标。</li>\n<li>/usr/share/applications/ :  常用应用图标所在。</li>\n<li>/etc/xdg/autostart/ : 系统级别自启动应用图标。</li>\n<li>/opt/deepinwine/apps/ : deepin-wine应用图标。</li>\n<li>/var/lib/flatpak/app/ : flatpak应用图标。<br>\n以上所给路径仅为常见路径，并非所有。</li>\n</ul>\n</li>\n<li></li>\n<li></li>\n</ul>\n<h2 id=\"常用命令linux入门用户推荐\"><a class=\"markdownIt-Anchor\" href=\"#常用命令linux入门用户推荐\"></a> 常用命令（linux入门用户推荐）：</h2>\n<ul>\n<li>\n<p>ls : 列出当前路径文件。</p>\n</li>\n<li>\n<p>pwd : 查看当前所在路径（绝对路径）。</p>\n</li>\n<li>\n<p>cd : 路径跳转。</p>\n</li>\n<li>\n<p>mv : 文件及目录移动以及更改名字。</p>\n</li>\n<li>\n<p>cp : 拷贝。</p>\n</li>\n<li>\n<p>mkdir : 创建目录。</p>\n</li>\n<li>\n<p>touch : 创建空白文件。</p>\n</li>\n<li>\n<p>桌面设置壁纸的内置壁纸保存位置：<br>\n如图：</p>\n<p>这些壁纸保存在：/usr/share/wallpapers/deepin下。</p>\n</li>\n<li>\n<p>vim 配置文件：~/.vimrc（用户级别配置文件，只针文件所在用户生效，其他用户不生效）</p>\n</li>\n<li>\n<p>bash配置文件：~/.bashrc（用户级别配置文件，只针文件所在用户生效，其他用户不生效）</p>\n</li>\n</ul>\n<h2 id=\"vim-入门操作\"><a class=\"markdownIt-Anchor\" href=\"#vim-入门操作\"></a> vim 入门操作</h2>\n<ul>\n<li>vim配置:\n<ol>\n<li>vim的配置我们选择ma6174的配置，<br>\n终端命令：wget -qO- <a href=\"https://raw.github.com/ma6174/vim/master/setup.sh\" target=\"_blank\" rel=\"noopener\">https://raw.github.com/ma6174/vim/master/setup.sh</a> | sh -x<br>\n配置完成后会重新回到终端命令行（建议在网络较好的环境下配置）</li>\n<li>配置完成后打开python文件会发现报错，解决方案：<br>\n点击这里下载python.zip文件，将压缩包下载到本地解压，得到一个名称为python的文件夹，将其复制（覆盖并替换）到～/.vim/ftplugin/路径下即可。</li>\n</ol>\n</li>\n<li>三种模式：\n<ul>\n<li>插入模式：</li>\n</ul>\n</li>\n</ul>\n<pre><code>1. 普通模式下按i直接进入插入模式。\n2. 普通模式下按I光标前一个位置进入插入模式。\n3. 普通模式下按O光标的下一行进入插入模式。\n4. 普通模式下按o光标的上一行进入插入模式。\n</code></pre>\n<ul>\n<li>普通模式：\n<ul>\n<li>在任何模式下按ESC进入普通模式。</li>\n<li>在普通模式下：\n<ul>\n<li>dd : 剪切当前行（可以当删除用）（只在普通模式和选择模式生效）。</li>\n<li>yy：复制当前行（只在普通模式和选择模式生效）。</li>\n<li>p ： 粘贴（只在普通模式生效）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>选择模式：\n<ul>\n<li>c : 进入块选择模式。</li>\n<li>C:  进入行选择模式。</li>\n<li>CTRL + c : 进入列选择模式。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ol>\n<li>如果你是小白用户并且没有人在旁边指导，那么建议不要自行更改本文给出的命令。</li>\n<li>图形界面相关的东西自行探索。</li>\n</ol>\n</blockquote>\n<h2 id=\"deepin系统安装后推荐配置\"><a class=\"markdownIt-Anchor\" href=\"#deepin系统安装后推荐配置\"></a> deepin系统安装后推荐配置</h2>\n<p><code>sudo apt-get install -y git wget curl openssh-server manpages-* graphviz</code></p>\n<h2 id=\"zsh配置linux高级用户推荐\"><a class=\"markdownIt-Anchor\" href=\"#zsh配置linux高级用户推荐\"></a> zsh配置（linux高级用户推荐）</h2>\n<ol>\n<li>\n<p>安装：<code>sudo apt-get install zsh</code></p>\n</li>\n<li>\n<p>设置为默认SHELL(不要加sudo)：<code>chsh -s /bin/zsh</code></p>\n</li>\n<li>\n<p>安装oh-my-zsh</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>\"</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>\n<p>手动配置oh-my-zsh</p>\n<ol>\n<li>安装自动跳转插件：<br>\n1.<code>sudo apt-get install autojump</code><br>\n2. 打开~/.zshrc，在文件末尾，另起一行添加：<code>source /usr/share/autojump/autojump.sh</code><br>\n2. 安装zsh-syntax-highlighting语法高亮插件：\n<ol>\n<li><code>cd ~/ &amp;&amp; git clone https://github.com/zsh-users/zsh-syntax-highlighting.git</code></li>\n<li><code>cd ~/ &amp;&amp;echo &quot;source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; ${ZDOTDIR:-$HOME}/.zshrc</code></li>\n<li>安装zsh-autosuggestions语法历史记录插件:</li>\n<li><code>git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code></li>\n<li>打开~/.zshrc，在文件末尾，另起一行添加：<code>source $ZSH_CUSTOM/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh</code></li>\n</ol>\n</li>\n<li>打开~/.zshrc:\n<ol>\n<li>\n<p>找到：plugins=(git)这个位置，在括号里面添加，每个单词单独一行，如果已经有了，就不用添加了：</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git</span><br><span class=\"line\">extract</span><br><span class=\"line\">z</span><br><span class=\"line\">web-search</span><br><span class=\"line\">zsh-autosuggestions</span><br><span class=\"line\">cp</span><br><span class=\"line\">command-not-found</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在文件末尾，另起一行添加：</li>\n</ol>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export EDITOR=vim</span><br><span class=\"line\">setopt HIST_IGNORE_DUPS</span><br><span class=\"line\">setopt no_nomatch</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>自动配置oh-my-zsh</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if [[ $&#123;?&#125; -eq 1 ]];</span><br><span class=\"line\">then</span><br><span class=\"line\">    exit 1;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install autojump</span><br><span class=\"line\">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br><span class=\"line\">git clone git://github.com/zsh-users/zsh-autosuggestions  ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">echo '</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">########################################</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">alias ls=\"ls --color=auto\"</span><br><span class=\"line\">alias dir=\"dir --color=auto\"</span><br><span class=\"line\">alias la=\"ls -a --color=auto\"</span><br><span class=\"line\">alias ll=\"ls -al --color=auto\"</span><br><span class=\"line\">alias vdir=\"vdir --color=auto\"</span><br><span class=\"line\"></span><br><span class=\"line\">alias grep=\"grep --color=auto\"</span><br><span class=\"line\">alias egrep=\"egrep --color=auto\"</span><br><span class=\"line\">alias fgrep=\"fgrep --color=auto\"</span><br><span class=\"line\"></span><br><span class=\"line\">alias cls=\"clear\"</span><br><span class=\"line\"></span><br><span class=\"line\">export EDITOR=vim</span><br><span class=\"line\">setopt no_nomatch</span><br><span class=\"line\">setopt HIST_IGNORE_DUPS</span><br><span class=\"line\"></span><br><span class=\"line\">source /usr/share/autojump/autojump.sh</span><br><span class=\"line\">source ~/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class=\"line\"></span><br><span class=\"line\">' &gt;&gt;  ~/.zshrc</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sed -i 's/^plugins=(git)/plugin=\\(extract \\n  z \\n web-search \\n  zsh-autosuggestions \\n cp \\n command-no-found\\)/g' ~/.zshrc</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>\n<p>通过手动或自动配置，zsh就彻底配置完成。</p>\n<p>​</p>\n</li>\n</ol>\n<h2 id=\"常见文件\"><a class=\"markdownIt-Anchor\" href=\"#常见文件\"></a> 常见文件</h2>\n<ul>\n<li>搜狗输入法皮肤所在路径：~/.config/sogou-qimpanel/skin</li>\n<li>desktop软件图标路径集合：\n<ul>\n<li>~/.local/share/applications : AppImage应用生成的图标。</li>\n<li>/usr/share/applications/ :  常用应用图标所在。</li>\n<li>/etc/xdg/autostart/ : 系统级别自启动应用图标。</li>\n<li>/opt/deepinwine/apps/ : deepin-wine应用图标。</li>\n<li>/var/lib/flatpak/app/ : flatpak应用图标。<br>\n以上所给路径仅为常见路径，并非所有。</li>\n</ul>\n</li>\n<li></li>\n<li></li>\n</ul>\n<h2 id=\"常用命令linux入门用户推荐\"><a class=\"markdownIt-Anchor\" href=\"#常用命令linux入门用户推荐\"></a> 常用命令（linux入门用户推荐）：</h2>\n<ul>\n<li>\n<p>ls : 列出当前路径文件。</p>\n</li>\n<li>\n<p>pwd : 查看当前所在路径（绝对路径）。</p>\n</li>\n<li>\n<p>cd : 路径跳转。</p>\n</li>\n<li>\n<p>mv : 文件及目录移动以及更改名字。</p>\n</li>\n<li>\n<p>cp : 拷贝。</p>\n</li>\n<li>\n<p>mkdir : 创建目录。</p>\n</li>\n<li>\n<p>touch : 创建空白文件。</p>\n</li>\n<li>\n<p>桌面设置壁纸的内置壁纸保存位置：<br>\n如图：</p>\n<p>这些壁纸保存在：/usr/share/wallpapers/deepin下。</p>\n</li>\n<li>\n<p>vim 配置文件：~/.vimrc（用户级别配置文件，只针文件所在用户生效，其他用户不生效）</p>\n</li>\n<li>\n<p>bash配置文件：~/.bashrc（用户级别配置文件，只针文件所在用户生效，其他用户不生效）</p>\n</li>\n</ul>\n<h2 id=\"vim-入门操作\"><a class=\"markdownIt-Anchor\" href=\"#vim-入门操作\"></a> vim 入门操作</h2>\n<ul>\n<li>vim配置:\n<ol>\n<li>vim的配置我们选择ma6174的配置，<br>\n终端命令：wget -qO- <a href=\"https://raw.github.com/ma6174/vim/master/setup.sh\" target=\"_blank\" rel=\"noopener\">https://raw.github.com/ma6174/vim/master/setup.sh</a> | sh -x<br>\n配置完成后会重新回到终端命令行（建议在网络较好的环境下配置）</li>\n<li>配置完成后打开python文件会发现报错，解决方案：<br>\n点击这里下载python.zip文件，将压缩包下载到本地解压，得到一个名称为python的文件夹，将其复制（覆盖并替换）到～/.vim/ftplugin/路径下即可。</li>\n</ol>\n</li>\n<li>三种模式：\n<ul>\n<li>插入模式：</li>\n</ul>\n</li>\n</ul>\n<pre><code>1. 普通模式下按i直接进入插入模式。\n2. 普通模式下按I光标前一个位置进入插入模式。\n3. 普通模式下按O光标的下一行进入插入模式。\n4. 普通模式下按o光标的上一行进入插入模式。\n</code></pre>\n<ul>\n<li>普通模式：\n<ul>\n<li>在任何模式下按ESC进入普通模式。</li>\n<li>在普通模式下：\n<ul>\n<li>dd : 剪切当前行（可以当删除用）（只在普通模式和选择模式生效）。</li>\n<li>yy：复制当前行（只在普通模式和选择模式生效）。</li>\n<li>p ： 粘贴（只在普通模式生效）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>选择模式：\n<ul>\n<li>c : 进入块选择模式。</li>\n<li>C:  进入行选择模式。</li>\n<li>CTRL + c : 进入列选择模式。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Linux常见配置文件","date":"2019-09-02T08:40:04.000Z","cover":"title.jpg","_content":"\n> 转载自[CoderZhuang](https://www.cnblogs.com/zxj015/p/4457868.html)，对[CoderZhuang](https://www.cnblogs.com/zxj015/p/4457868.html)先生的博客进行补充和整理。\n\n1. `/etc` 配置文件\n    * `/etc/passwd` 用户数据库，其中的域给出了用户名、真实姓名、家目录、加密口令和用户的其他信息 \n      * `/etc/group` 类似`/etc/passwd` ，但说明的不是用户而是组。\n      * `/etc/inittab` init 的配置文件\n      * `/etc/issue` 在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。内容由系统管理员确定。\n      * `/etc/motd` 成功登录后自动输出，内容由系统管理员确定，经常用于通告信息，如计划关时间的警告。\n      * `/etc/mtab` 当前安装的文件系统列表。由`scripts` 初始化，并由`mount` 命令自动更新。需要一个当前\n        安装的文件系统的列表时使用，例如df 命令，当`df –a` 时，查看到的信息应和其一致。\n      * `/etc/shadow` 在安装了影子口令软件的系统上的影子口令文件。影子口令文件将`/etc/passwd` 文件中的\n        加密口令移动到`/etc/shadow` 中，而后者只对**root** 可读。这使破译口令更困难。\n    * `/etc/login.defs` login 命令的配置文件\n      * `/etc/profile` , `/etc/csh.login` , `/etc/csh.cshrc` 登录或启动（cshell）时读取的文件（shell不同，文件名称不同，具体查看man手册）。\n      * `/etc/printcap` 类似`/etc/termcap` ，但针对打印机。语法不同。\n      * `/etc/securetty` 确认安全终端，即哪个终端允许**root**登录。一般只列出虚拟控制台，这样就不可能\n        (至少很困难)通过modem 或网络闯入系统并得到超级用户特权。\n      * `/etc/shells` 列出可信任的shell。chsh命令允许用户在本文件指定范围内改变登录shell。提供一\n        台机器FTP 服务的服务进程ftpd 检查用户shell 是否列在 `/etc/shells` \n        文件中，如果不是将不允许该用户登录。\n      * `/etc/termcap`终端性能数据库。说明不同的终端用什么\"转义序列\"控制。写程序时不直接输出转义序列(这样\n        只能工作于特定品牌的终端)，而是从`/etc/termcap`中查找要做的工作的正确序列。这样，多数的\n        程序可以在多数终端上运行。\n      * `/etc/inputrc` 输入设备配置文件\n      * `/etc/default/useradd` 添加用户的默认信息的文件\n      * `/etc/login.defs` 是用户密码信息的默认属性\n      * `/etc/skel` 用户信息的骨架\n      * `/sbin/nologin` 不能登陆的用户\n      * `/var/log/message` 系统的日志文件\n      * `/etc/profile`全局配置文件可以在添加一行`PATH=$PATH：/usr/local/mysql/bin`即可以软件的命令可以使用\n      * `/root/bashrc` 命令的别名\n      * `/etc/yum.repos.d` 配置本地yun源(红帽系)\n      * `/etc/apt/sources.list.d` 配置本地apt源(debian系)\n      * `/etc/httpd/conf/httpd.conf` 配置http服务的配置文件\n      * `/etc/fstab` 系统启动时自动加载的设备，（用于配置自动挂载设备）\n      * `/etc/selinux` 安全Linux设定\n      * `/etc/sysconfig/network` 可以更改`hostname`（主机名）以及网卡工作状态\n      * `/etc/hosts` 更改主机名和IP 地址的对应关系，请注意其格式为`hostname.domain` `hostname` `localhost`\n        `localhost.domian`，当修改主机名后必须修改该文件\n      * `/etc/resolv.conf` 可配置DNS 地址，即第一DNS，第二DNS 以及DNS 的默认搜索路径\n      * `/etc/sysconfig/networking/profiles/default` 内含数个文件，可配置hosts、网卡、DNS 地址及\n        DNS 搜索路径等\n      * `/etc/sysconfig/network-scripts/ifcfg-eth0` 配置网卡eth0(具体名称请使用`ifconfig`查看)\n      * `/etc/rc.d/init.d/network restart` 重启网络\n      * `/etc/rc.d/init.d` 用于放置几乎所有服务的启动脚本\n      * `/etc/sysctl.conf` 内核参数配置文件\n         `/etc/sysconfig/i18n`\t设置系统语言和字符类型\n      * `/etc/crontab` 系统定义的任务计划\n      * `/etc/anacrontab` 实现检查过期和未完成的crontab的任务的配置文件\n      * `/etc/rc.d/init.d/functions` 定义功能的配置文件\n      * `/etc/rc.d/rc.sysinit` 系统启动设置配置文件\n      * `/etc/sysconfig/system-config-firewall`配置防火墙的信任端口，以及防火墙的工作状态。图形化配置防火\n        墙的存档文件，具体讲只保存图形界面的otherport里面设置的项目，如果主配置\n        文件存在相应的配置条目，那么它里面的配置条目存在与否并不重要。\n      * `/etc/sysconfig/iptables` 防火墙主配置文件\n      * `/etc/sysconfig/system-config-securitylevel` 系统安全等级文件，在防火墙配置中不会涉及\n      * `/etc/xinetd.conf xinetd` 的主配置文件\n      * `/etc/hosts.allow` TCP的一个许可表\n      * `/etc/host.deny` TCP的一个拒绝表\n      * `/etc/squid/squid.conf` 代理服务器（SQUID）配置文件\n      * `/etc/sysconfig/vncservers` VNC服务配置文件\n      * `/etc/vsftpd/ftpusers` 用于保存不允许进行FTP 登录的本地用户账号（黑名单）\n      * `/etc/vsftpd/user_list` 更灵活的用户访问控制，但需要在主配置文件中进行声明\n      * `/etc/inetd.conf` swat 配置\n      * `/etc/dhcpd.conf` DHCP 的配置文件\n      * `/etc/rc.d/init.d/dhcpd stop` 停止DHCP\n      * `/etc/access` 可以对sendmail 的邮件流进行控制\n      * `/etc/udev/rules.d` 系统初始化时将硬件探测信息输出成设备配置文件，是一个程序。\n        让用户定义udev的规则，从而实现在创建设备文件使用不同的设备文件名\n      * 注：`/etc/passwd` 存放用户的账号，存放形式 ：\n        `root:x:0:0:root:/root:/bin/bash` : \n        `用户名：密码位：UID：GID：CECOS(注释)：diectory（家目录）:shell`\n      * 注：`/etc/shadow` 存放用户的密码\n        `slaceware:$1$12345678$0ME5N6oDyoEAwUp7b5UDM/:15355:0:99999:7:::`\n        用户名：加密后的密码：时间1：时间2：时间3：时间4：时间5：时间6：预留段`\t\n        加密后的密码：以$分开，第一个$后是1，说明加密算法是md5，第二个$后是加的sail，第三个$后是加的密码。\n        时间1：从1970年1月1日起到最近的修改的天数\n        时间2：密码的最短使用期限\n        时间3：密码最长使用期限\n        时间4：在密码过期之前多少天开始警告\n        时间5：在密码过期多少天用户禁用\n        时间6：自1970年1月1日起多长时间用户被禁用\n      * 注：`/etc/group` 存放组的账号，存放形式： \n        `slackware:x:5000` : `Name：passwd位置：GID：附加组的用户列表`。\n      * 注：\n      * 交互式登陆的用户：\n        `/etc/profile -->/etc/profile.d/* -->~/.bash_profile -->~/.bashrc -->/etc/bashrc`\n    * 非交互式登录：\n      /.bashrc -->/etc/bashrc -->.etc/profile.d/*`\t\n2. `/proc` 配置文件\n    * `/proc/dma` 显示当前使用的DMA 通道。\n      * `/proc/filesystems` 核心配置的文件系统。\n      * `/proc/interrupts` 显示使用的中断，and how many of each there have been.\n      * `/proc/ioports` 当前使用的I/O 端口。\n      * `/proc/kcore` 系统物理内存映象。与物理内存大小完全一样，但不实际占用这么多内存；\n        it is generated on the fly as programs access it. \n        (记住：除非你把它拷贝到什么地方，`/proc` 下没有任何东西占用任何磁盘空间。）\n      * `/proc/kmsg` 核心输出的消息。也被送到syslog\n      * `/proc/ksyms` 核心符号表\n      * `/proc/loadavg` 系统\"平均负载\"；3 个指示器指出系统当前的工作量。\n      * `/proc/meminfo` 存储器使用信息，包括物理内存和swap。\n      * `/proc/modules` 当前加载了哪些核心模块。\n      * `/proc/net` 网络协议状态信息。\n      * `/proc/self` 到查看`/proc` 的程序的进程目录的符号连接。当2 个进程查看`/proc` \n        时，是不同的连接。这主要便于程序得到它自己的进程目录。 \n       * `/proc/stat` 系统的不同状态，such as the number of page faults since the system was booted.\n      * `/proc/uptime` 系统启动的时间长度。 \n      * `/proc/cpuinfo` 处理器信息，如类型、制造商、型号和性能。\n      * `/proc/devices` 当前运行的核心配置的设备驱动的列表。\n      * `/proc/version` 核心版本。\n      * `/proc/mdstat` RAID设备的信息\n      * `/proc/cmdline` ro root=/dev/vol0/root rhgb quiet grub信息\n      * `/proc/cpuinfo` 显示CPU的相关信息\n      * `/proc/cpuset` cpu集合 用于显示当前进程可以应用到哪些cpu上\n      * `/proc/filesystem`当前系统支持的文件系统种类\n      * `/etc/245/vm` 系统进程ID号为245的进程的虚拟内存信息\n      * `/etc/245/kernel` 系统进程ID号为245的进程的内核信息\n      * `/proc/mounts` 挂载的所有文件系统\n      * `/proc/swaps` 交换分区信息 \n      * `/proc/uptime` 启动系统运行时长\n      * `/proc/sys` (具有写权限)定义内核参数的值来定义内核的功能\n         `/proc/sys/kernel/hostname` 主机名的设定\t\n3. `/usr` 配置文件\n    * `/usr/bin` 众多的应用程序\n      * `/usr/doc` linux 文档\n      * `/usr/include` linux 下C 开发和编译应用程序所需要的头文件\n      * `/usr/include/g++` C++编译器的头文\n      * `/usr/lib` 常用的动态链接库和软件包的配置文件\n      * `/usr/src` 系统软件的源代码\n      * `/usr/src/linux` linux 内核的源代码\n      * `/usr/local/bin` 本地增加的命令\n      * `/usr/local/lib` 本地增加的库\n      * `/usr/sbin` 为系统管理员保留的程序\n      * `/usr/share/fonts` 字体文件\n      * `/usr/share/doc` 各种文档文件\n      * `/usr/share/man` 系统手册页\n      * `/usr/local/apache/man` 定义man目录文集\n        其它目录配置文件\t\n      * `/dev/null` 没有用的文件所放的位置，相当于回收站，吞噬设备\n      * `/dev/zero` 初始化磁盘（吐零） \n      * `/dev/random` 随机数生成器，熵池\n      * `/dev/urandom` 伪随机数生成器，熵池。（当熵池耗尽时，用软件生成随机数）\n      * `/var/spool/mail/root` 定义mail设置发送用户为root\n      * `/bin/bash` 系统内置脚本\n      * `/home/USERNAME` 用户配额文件\n      * `/var/spool/cron/USERNAME` 用户定义的任务计划\n4. 目录结构：\n    * `/boot` 用于自举加载程序（LILO 或GRUB）的文件。当计算机启动时（如果有多个操作系统，\n      有可能允许你选择启动哪一个操作系统），这些文件首先被装载。这个目录也会包含LINUX 核（压缩文件\n      vmlinuz），但LINUX 核也可以存在别处，只要配置LILO 并且LILO 知道LINUX 核在哪儿。\n      * `/bin` 系统启动时需要的引导程序(二进制执行文件)，这些文件可以被普通用户使用\n      * `/dev` 代表硬件组件的设备文件目录。LINUX 下设备被当成文件，这样一来硬件被抽象化，便\n        于读写、网络共享以及需要临时装载到文件系统中。正常情况下，设备会有一个独立的子目录。这些设备\n        的内容会出现在独立的子目录下。LINUX 没有所谓的驱动符。\n      * `/etc` 存放各种配置文件\n      * `/etc/rc.d` 启动的配置文件和脚本\n      * `/home` 用户主目录，包含参数设置文件、个性化文件、文档、数据、EMAIL、缓存数据等\n      * `/lib` 标准程序设计库，又叫动态链接共享库，作用类似windows 里的.dll 文件\n      * `/sbin` 为系统管理员保留的用于系统启动时的引导程序(二进制执行文件)，这些文件不打算被\n        普通用户使用(普通用户仍然可以使用它们，但要指定目录)\n      * `/tmp` 公用的临时文件存储点，该目录会被自动清理干净\n      * `/root` 系统管理员的主目录\n      * `/mnt` 系统提供这个目录是让用户临时挂载其他的文件系统。\n      * `/lost+found`这个目录平时是空的，系统非正常关机而留下“无家可归”的文件。\n      * `/proc` 虚拟的目录，是系统内存的映射，可直接访问这个目录来获取系统信息。目录整个包含\n        虚幻的文件。它们实际上并不存在磁盘上，也不占用任何空间。（用`ls –l` 可以显示它们的大小）当查看\n        这些文件时，实际上是在访问存在内存中的信息，这些信息用于访问系统\n      * `/proc/1` 关于进程1 的信息目录。每个进程在`/proc` 下有一个名为其进程号的目录。\n      * `/var` 某些大文件的溢出区，比方说各种服务的日志文件，包含在正常操作中被改变的文件：\n        假脱机文件、记录文件、加锁文件、临时文件和页格式化文件等\n      * `/var/spool mail, news`, 打印队列和其他队列工作的目录。每个不同的spool 在`/var/spool` 下有自己的\n        子目录，例如，用户的邮箱在`/var/spool/mail` 中。\n      * `/opt` 可选的应用程序，譬如，REDHAT 5.2 下的KDE （REDHAT 6.0 下，KDE 放在其它的\n        XWINDOWS 应用程序中，主执行程序在`/usr/bin` 目录下）\n      * `/usr` 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。\n      * `/home /var /usr/local` 经常是单独分区，因为经常会操作，容易产生碎片\n      * `/srv` 该目录存放一些服务启动之后需要提取的数据\n","source":"_posts/Linux常见配置文件.md","raw":"---\ntitle: Linux常见配置文件\ndate: 2019-09-02 16:40:04\ncover: title.jpg\ntags: \n- note \n- 转载\n---\n\n> 转载自[CoderZhuang](https://www.cnblogs.com/zxj015/p/4457868.html)，对[CoderZhuang](https://www.cnblogs.com/zxj015/p/4457868.html)先生的博客进行补充和整理。\n\n1. `/etc` 配置文件\n    * `/etc/passwd` 用户数据库，其中的域给出了用户名、真实姓名、家目录、加密口令和用户的其他信息 \n      * `/etc/group` 类似`/etc/passwd` ，但说明的不是用户而是组。\n      * `/etc/inittab` init 的配置文件\n      * `/etc/issue` 在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。内容由系统管理员确定。\n      * `/etc/motd` 成功登录后自动输出，内容由系统管理员确定，经常用于通告信息，如计划关时间的警告。\n      * `/etc/mtab` 当前安装的文件系统列表。由`scripts` 初始化，并由`mount` 命令自动更新。需要一个当前\n        安装的文件系统的列表时使用，例如df 命令，当`df –a` 时，查看到的信息应和其一致。\n      * `/etc/shadow` 在安装了影子口令软件的系统上的影子口令文件。影子口令文件将`/etc/passwd` 文件中的\n        加密口令移动到`/etc/shadow` 中，而后者只对**root** 可读。这使破译口令更困难。\n    * `/etc/login.defs` login 命令的配置文件\n      * `/etc/profile` , `/etc/csh.login` , `/etc/csh.cshrc` 登录或启动（cshell）时读取的文件（shell不同，文件名称不同，具体查看man手册）。\n      * `/etc/printcap` 类似`/etc/termcap` ，但针对打印机。语法不同。\n      * `/etc/securetty` 确认安全终端，即哪个终端允许**root**登录。一般只列出虚拟控制台，这样就不可能\n        (至少很困难)通过modem 或网络闯入系统并得到超级用户特权。\n      * `/etc/shells` 列出可信任的shell。chsh命令允许用户在本文件指定范围内改变登录shell。提供一\n        台机器FTP 服务的服务进程ftpd 检查用户shell 是否列在 `/etc/shells` \n        文件中，如果不是将不允许该用户登录。\n      * `/etc/termcap`终端性能数据库。说明不同的终端用什么\"转义序列\"控制。写程序时不直接输出转义序列(这样\n        只能工作于特定品牌的终端)，而是从`/etc/termcap`中查找要做的工作的正确序列。这样，多数的\n        程序可以在多数终端上运行。\n      * `/etc/inputrc` 输入设备配置文件\n      * `/etc/default/useradd` 添加用户的默认信息的文件\n      * `/etc/login.defs` 是用户密码信息的默认属性\n      * `/etc/skel` 用户信息的骨架\n      * `/sbin/nologin` 不能登陆的用户\n      * `/var/log/message` 系统的日志文件\n      * `/etc/profile`全局配置文件可以在添加一行`PATH=$PATH：/usr/local/mysql/bin`即可以软件的命令可以使用\n      * `/root/bashrc` 命令的别名\n      * `/etc/yum.repos.d` 配置本地yun源(红帽系)\n      * `/etc/apt/sources.list.d` 配置本地apt源(debian系)\n      * `/etc/httpd/conf/httpd.conf` 配置http服务的配置文件\n      * `/etc/fstab` 系统启动时自动加载的设备，（用于配置自动挂载设备）\n      * `/etc/selinux` 安全Linux设定\n      * `/etc/sysconfig/network` 可以更改`hostname`（主机名）以及网卡工作状态\n      * `/etc/hosts` 更改主机名和IP 地址的对应关系，请注意其格式为`hostname.domain` `hostname` `localhost`\n        `localhost.domian`，当修改主机名后必须修改该文件\n      * `/etc/resolv.conf` 可配置DNS 地址，即第一DNS，第二DNS 以及DNS 的默认搜索路径\n      * `/etc/sysconfig/networking/profiles/default` 内含数个文件，可配置hosts、网卡、DNS 地址及\n        DNS 搜索路径等\n      * `/etc/sysconfig/network-scripts/ifcfg-eth0` 配置网卡eth0(具体名称请使用`ifconfig`查看)\n      * `/etc/rc.d/init.d/network restart` 重启网络\n      * `/etc/rc.d/init.d` 用于放置几乎所有服务的启动脚本\n      * `/etc/sysctl.conf` 内核参数配置文件\n         `/etc/sysconfig/i18n`\t设置系统语言和字符类型\n      * `/etc/crontab` 系统定义的任务计划\n      * `/etc/anacrontab` 实现检查过期和未完成的crontab的任务的配置文件\n      * `/etc/rc.d/init.d/functions` 定义功能的配置文件\n      * `/etc/rc.d/rc.sysinit` 系统启动设置配置文件\n      * `/etc/sysconfig/system-config-firewall`配置防火墙的信任端口，以及防火墙的工作状态。图形化配置防火\n        墙的存档文件，具体讲只保存图形界面的otherport里面设置的项目，如果主配置\n        文件存在相应的配置条目，那么它里面的配置条目存在与否并不重要。\n      * `/etc/sysconfig/iptables` 防火墙主配置文件\n      * `/etc/sysconfig/system-config-securitylevel` 系统安全等级文件，在防火墙配置中不会涉及\n      * `/etc/xinetd.conf xinetd` 的主配置文件\n      * `/etc/hosts.allow` TCP的一个许可表\n      * `/etc/host.deny` TCP的一个拒绝表\n      * `/etc/squid/squid.conf` 代理服务器（SQUID）配置文件\n      * `/etc/sysconfig/vncservers` VNC服务配置文件\n      * `/etc/vsftpd/ftpusers` 用于保存不允许进行FTP 登录的本地用户账号（黑名单）\n      * `/etc/vsftpd/user_list` 更灵活的用户访问控制，但需要在主配置文件中进行声明\n      * `/etc/inetd.conf` swat 配置\n      * `/etc/dhcpd.conf` DHCP 的配置文件\n      * `/etc/rc.d/init.d/dhcpd stop` 停止DHCP\n      * `/etc/access` 可以对sendmail 的邮件流进行控制\n      * `/etc/udev/rules.d` 系统初始化时将硬件探测信息输出成设备配置文件，是一个程序。\n        让用户定义udev的规则，从而实现在创建设备文件使用不同的设备文件名\n      * 注：`/etc/passwd` 存放用户的账号，存放形式 ：\n        `root:x:0:0:root:/root:/bin/bash` : \n        `用户名：密码位：UID：GID：CECOS(注释)：diectory（家目录）:shell`\n      * 注：`/etc/shadow` 存放用户的密码\n        `slaceware:$1$12345678$0ME5N6oDyoEAwUp7b5UDM/:15355:0:99999:7:::`\n        用户名：加密后的密码：时间1：时间2：时间3：时间4：时间5：时间6：预留段`\t\n        加密后的密码：以$分开，第一个$后是1，说明加密算法是md5，第二个$后是加的sail，第三个$后是加的密码。\n        时间1：从1970年1月1日起到最近的修改的天数\n        时间2：密码的最短使用期限\n        时间3：密码最长使用期限\n        时间4：在密码过期之前多少天开始警告\n        时间5：在密码过期多少天用户禁用\n        时间6：自1970年1月1日起多长时间用户被禁用\n      * 注：`/etc/group` 存放组的账号，存放形式： \n        `slackware:x:5000` : `Name：passwd位置：GID：附加组的用户列表`。\n      * 注：\n      * 交互式登陆的用户：\n        `/etc/profile -->/etc/profile.d/* -->~/.bash_profile -->~/.bashrc -->/etc/bashrc`\n    * 非交互式登录：\n      /.bashrc -->/etc/bashrc -->.etc/profile.d/*`\t\n2. `/proc` 配置文件\n    * `/proc/dma` 显示当前使用的DMA 通道。\n      * `/proc/filesystems` 核心配置的文件系统。\n      * `/proc/interrupts` 显示使用的中断，and how many of each there have been.\n      * `/proc/ioports` 当前使用的I/O 端口。\n      * `/proc/kcore` 系统物理内存映象。与物理内存大小完全一样，但不实际占用这么多内存；\n        it is generated on the fly as programs access it. \n        (记住：除非你把它拷贝到什么地方，`/proc` 下没有任何东西占用任何磁盘空间。）\n      * `/proc/kmsg` 核心输出的消息。也被送到syslog\n      * `/proc/ksyms` 核心符号表\n      * `/proc/loadavg` 系统\"平均负载\"；3 个指示器指出系统当前的工作量。\n      * `/proc/meminfo` 存储器使用信息，包括物理内存和swap。\n      * `/proc/modules` 当前加载了哪些核心模块。\n      * `/proc/net` 网络协议状态信息。\n      * `/proc/self` 到查看`/proc` 的程序的进程目录的符号连接。当2 个进程查看`/proc` \n        时，是不同的连接。这主要便于程序得到它自己的进程目录。 \n       * `/proc/stat` 系统的不同状态，such as the number of page faults since the system was booted.\n      * `/proc/uptime` 系统启动的时间长度。 \n      * `/proc/cpuinfo` 处理器信息，如类型、制造商、型号和性能。\n      * `/proc/devices` 当前运行的核心配置的设备驱动的列表。\n      * `/proc/version` 核心版本。\n      * `/proc/mdstat` RAID设备的信息\n      * `/proc/cmdline` ro root=/dev/vol0/root rhgb quiet grub信息\n      * `/proc/cpuinfo` 显示CPU的相关信息\n      * `/proc/cpuset` cpu集合 用于显示当前进程可以应用到哪些cpu上\n      * `/proc/filesystem`当前系统支持的文件系统种类\n      * `/etc/245/vm` 系统进程ID号为245的进程的虚拟内存信息\n      * `/etc/245/kernel` 系统进程ID号为245的进程的内核信息\n      * `/proc/mounts` 挂载的所有文件系统\n      * `/proc/swaps` 交换分区信息 \n      * `/proc/uptime` 启动系统运行时长\n      * `/proc/sys` (具有写权限)定义内核参数的值来定义内核的功能\n         `/proc/sys/kernel/hostname` 主机名的设定\t\n3. `/usr` 配置文件\n    * `/usr/bin` 众多的应用程序\n      * `/usr/doc` linux 文档\n      * `/usr/include` linux 下C 开发和编译应用程序所需要的头文件\n      * `/usr/include/g++` C++编译器的头文\n      * `/usr/lib` 常用的动态链接库和软件包的配置文件\n      * `/usr/src` 系统软件的源代码\n      * `/usr/src/linux` linux 内核的源代码\n      * `/usr/local/bin` 本地增加的命令\n      * `/usr/local/lib` 本地增加的库\n      * `/usr/sbin` 为系统管理员保留的程序\n      * `/usr/share/fonts` 字体文件\n      * `/usr/share/doc` 各种文档文件\n      * `/usr/share/man` 系统手册页\n      * `/usr/local/apache/man` 定义man目录文集\n        其它目录配置文件\t\n      * `/dev/null` 没有用的文件所放的位置，相当于回收站，吞噬设备\n      * `/dev/zero` 初始化磁盘（吐零） \n      * `/dev/random` 随机数生成器，熵池\n      * `/dev/urandom` 伪随机数生成器，熵池。（当熵池耗尽时，用软件生成随机数）\n      * `/var/spool/mail/root` 定义mail设置发送用户为root\n      * `/bin/bash` 系统内置脚本\n      * `/home/USERNAME` 用户配额文件\n      * `/var/spool/cron/USERNAME` 用户定义的任务计划\n4. 目录结构：\n    * `/boot` 用于自举加载程序（LILO 或GRUB）的文件。当计算机启动时（如果有多个操作系统，\n      有可能允许你选择启动哪一个操作系统），这些文件首先被装载。这个目录也会包含LINUX 核（压缩文件\n      vmlinuz），但LINUX 核也可以存在别处，只要配置LILO 并且LILO 知道LINUX 核在哪儿。\n      * `/bin` 系统启动时需要的引导程序(二进制执行文件)，这些文件可以被普通用户使用\n      * `/dev` 代表硬件组件的设备文件目录。LINUX 下设备被当成文件，这样一来硬件被抽象化，便\n        于读写、网络共享以及需要临时装载到文件系统中。正常情况下，设备会有一个独立的子目录。这些设备\n        的内容会出现在独立的子目录下。LINUX 没有所谓的驱动符。\n      * `/etc` 存放各种配置文件\n      * `/etc/rc.d` 启动的配置文件和脚本\n      * `/home` 用户主目录，包含参数设置文件、个性化文件、文档、数据、EMAIL、缓存数据等\n      * `/lib` 标准程序设计库，又叫动态链接共享库，作用类似windows 里的.dll 文件\n      * `/sbin` 为系统管理员保留的用于系统启动时的引导程序(二进制执行文件)，这些文件不打算被\n        普通用户使用(普通用户仍然可以使用它们，但要指定目录)\n      * `/tmp` 公用的临时文件存储点，该目录会被自动清理干净\n      * `/root` 系统管理员的主目录\n      * `/mnt` 系统提供这个目录是让用户临时挂载其他的文件系统。\n      * `/lost+found`这个目录平时是空的，系统非正常关机而留下“无家可归”的文件。\n      * `/proc` 虚拟的目录，是系统内存的映射，可直接访问这个目录来获取系统信息。目录整个包含\n        虚幻的文件。它们实际上并不存在磁盘上，也不占用任何空间。（用`ls –l` 可以显示它们的大小）当查看\n        这些文件时，实际上是在访问存在内存中的信息，这些信息用于访问系统\n      * `/proc/1` 关于进程1 的信息目录。每个进程在`/proc` 下有一个名为其进程号的目录。\n      * `/var` 某些大文件的溢出区，比方说各种服务的日志文件，包含在正常操作中被改变的文件：\n        假脱机文件、记录文件、加锁文件、临时文件和页格式化文件等\n      * `/var/spool mail, news`, 打印队列和其他队列工作的目录。每个不同的spool 在`/var/spool` 下有自己的\n        子目录，例如，用户的邮箱在`/var/spool/mail` 中。\n      * `/opt` 可选的应用程序，譬如，REDHAT 5.2 下的KDE （REDHAT 6.0 下，KDE 放在其它的\n        XWINDOWS 应用程序中，主执行程序在`/usr/bin` 目录下）\n      * `/usr` 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。\n      * `/home /var /usr/local` 经常是单独分区，因为经常会操作，容易产生碎片\n      * `/srv` 该目录存放一些服务启动之后需要提取的数据\n","slug":"Linux常见配置文件","published":1,"updated":"2020-04-08T03:36:55.850Z","_id":"ck8qr69de000p5d3a07s9nc10","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>转载自<a href=\"https://www.cnblogs.com/zxj015/p/4457868.html\" target=\"_blank\" rel=\"noopener\">CoderZhuang</a>，对<a href=\"https://www.cnblogs.com/zxj015/p/4457868.html\" target=\"_blank\" rel=\"noopener\">CoderZhuang</a>先生的博客进行补充和整理。</p>\n</blockquote>\n<ol>\n<li><code>/etc</code> 配置文件\n<ul>\n<li><code>/etc/passwd</code> 用户数据库，其中的域给出了用户名、真实姓名、家目录、加密口令和用户的其他信息\n<ul>\n<li><code>/etc/group</code> 类似<code>/etc/passwd</code> ，但说明的不是用户而是组。</li>\n<li><code>/etc/inittab</code> init 的配置文件</li>\n<li><code>/etc/issue</code> 在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。内容由系统管理员确定。</li>\n<li><code>/etc/motd</code> 成功登录后自动输出，内容由系统管理员确定，经常用于通告信息，如计划关时间的警告。</li>\n<li><code>/etc/mtab</code> 当前安装的文件系统列表。由<code>scripts</code> 初始化，并由<code>mount</code> 命令自动更新。需要一个当前<br>\n安装的文件系统的列表时使用，例如df 命令，当<code>df –a</code> 时，查看到的信息应和其一致。</li>\n<li><code>/etc/shadow</code> 在安装了影子口令软件的系统上的影子口令文件。影子口令文件将<code>/etc/passwd</code> 文件中的<br>\n加密口令移动到<code>/etc/shadow</code> 中，而后者只对<strong>root</strong> 可读。这使破译口令更困难。</li>\n</ul>\n</li>\n<li><code>/etc/login.defs</code> login 命令的配置文件\n<ul>\n<li><code>/etc/profile</code> , <code>/etc/csh.login</code> , <code>/etc/csh.cshrc</code> 登录或启动（cshell）时读取的文件（shell不同，文件名称不同，具体查看man手册）。</li>\n<li><code>/etc/printcap</code> 类似<code>/etc/termcap</code> ，但针对打印机。语法不同。</li>\n<li><code>/etc/securetty</code> 确认安全终端，即哪个终端允许<strong>root</strong>登录。一般只列出虚拟控制台，这样就不可能<br>\n(至少很困难)通过modem 或网络闯入系统并得到超级用户特权。</li>\n<li><code>/etc/shells</code> 列出可信任的shell。chsh命令允许用户在本文件指定范围内改变登录shell。提供一<br>\n台机器FTP 服务的服务进程ftpd 检查用户shell 是否列在 <code>/etc/shells</code><br>\n文件中，如果不是将不允许该用户登录。</li>\n<li><code>/etc/termcap</code>终端性能数据库。说明不同的终端用什么&quot;转义序列&quot;控制。写程序时不直接输出转义序列(这样<br>\n只能工作于特定品牌的终端)，而是从<code>/etc/termcap</code>中查找要做的工作的正确序列。这样，多数的<br>\n程序可以在多数终端上运行。</li>\n<li><code>/etc/inputrc</code> 输入设备配置文件</li>\n<li><code>/etc/default/useradd</code> 添加用户的默认信息的文件</li>\n<li><code>/etc/login.defs</code> 是用户密码信息的默认属性</li>\n<li><code>/etc/skel</code> 用户信息的骨架</li>\n<li><code>/sbin/nologin</code> 不能登陆的用户</li>\n<li><code>/var/log/message</code> 系统的日志文件</li>\n<li><code>/etc/profile</code>全局配置文件可以在添加一行<code>PATH=$PATH：/usr/local/mysql/bin</code>即可以软件的命令可以使用</li>\n<li><code>/root/bashrc</code> 命令的别名</li>\n<li><code>/etc/yum.repos.d</code> 配置本地yun源(红帽系)</li>\n<li><code>/etc/apt/sources.list.d</code> 配置本地apt源(debian系)</li>\n<li><code>/etc/httpd/conf/httpd.conf</code> 配置http服务的配置文件</li>\n<li><code>/etc/fstab</code> 系统启动时自动加载的设备，（用于配置自动挂载设备）</li>\n<li><code>/etc/selinux</code> 安全Linux设定</li>\n<li><code>/etc/sysconfig/network</code> 可以更改<code>hostname</code>（主机名）以及网卡工作状态</li>\n<li><code>/etc/hosts</code> 更改主机名和IP 地址的对应关系，请注意其格式为<code>hostname.domain</code> <code>hostname</code> <code>localhost</code><br>\n<code>localhost.domian</code>，当修改主机名后必须修改该文件</li>\n<li><code>/etc/resolv.conf</code> 可配置DNS 地址，即第一DNS，第二DNS 以及DNS 的默认搜索路径</li>\n<li><code>/etc/sysconfig/networking/profiles/default</code> 内含数个文件，可配置hosts、网卡、DNS 地址及<br>\nDNS 搜索路径等</li>\n<li><code>/etc/sysconfig/network-scripts/ifcfg-eth0</code> 配置网卡eth0(具体名称请使用<code>ifconfig</code>查看)</li>\n<li><code>/etc/rc.d/init.d/network restart</code> 重启网络</li>\n<li><code>/etc/rc.d/init.d</code> 用于放置几乎所有服务的启动脚本</li>\n<li><code>/etc/sysctl.conf</code> 内核参数配置文件<br>\n<code>/etc/sysconfig/i18n</code>\t设置系统语言和字符类型</li>\n<li><code>/etc/crontab</code> 系统定义的任务计划</li>\n<li><code>/etc/anacrontab</code> 实现检查过期和未完成的crontab的任务的配置文件</li>\n<li><code>/etc/rc.d/init.d/functions</code> 定义功能的配置文件</li>\n<li><code>/etc/rc.d/rc.sysinit</code> 系统启动设置配置文件</li>\n<li><code>/etc/sysconfig/system-config-firewall</code>配置防火墙的信任端口，以及防火墙的工作状态。图形化配置防火<br>\n墙的存档文件，具体讲只保存图形界面的otherport里面设置的项目，如果主配置<br>\n文件存在相应的配置条目，那么它里面的配置条目存在与否并不重要。</li>\n<li><code>/etc/sysconfig/iptables</code> 防火墙主配置文件</li>\n<li><code>/etc/sysconfig/system-config-securitylevel</code> 系统安全等级文件，在防火墙配置中不会涉及</li>\n<li><code>/etc/xinetd.conf xinetd</code> 的主配置文件</li>\n<li><code>/etc/hosts.allow</code> TCP的一个许可表</li>\n<li><code>/etc/host.deny</code> TCP的一个拒绝表</li>\n<li><code>/etc/squid/squid.conf</code> 代理服务器（SQUID）配置文件</li>\n<li><code>/etc/sysconfig/vncservers</code> VNC服务配置文件</li>\n<li><code>/etc/vsftpd/ftpusers</code> 用于保存不允许进行FTP 登录的本地用户账号（黑名单）</li>\n<li><code>/etc/vsftpd/user_list</code> 更灵活的用户访问控制，但需要在主配置文件中进行声明</li>\n<li><code>/etc/inetd.conf</code> swat 配置</li>\n<li><code>/etc/dhcpd.conf</code> DHCP 的配置文件</li>\n<li><code>/etc/rc.d/init.d/dhcpd stop</code> 停止DHCP</li>\n<li><code>/etc/access</code> 可以对sendmail 的邮件流进行控制</li>\n<li><code>/etc/udev/rules.d</code> 系统初始化时将硬件探测信息输出成设备配置文件，是一个程序。<br>\n让用户定义udev的规则，从而实现在创建设备文件使用不同的设备文件名</li>\n<li>注：<code>/etc/passwd</code> 存放用户的账号，存放形式 ：<br>\n<code>root:x:0:0:root:/root:/bin/bash</code> :<br>\n<code>用户名：密码位：UID：GID：CECOS(注释)：diectory（家目录）:shell</code></li>\n<li>注：<code>/etc/shadow</code> 存放用户的密码<br>\n<code>slaceware:$1$12345678$0ME5N6oDyoEAwUp7b5UDM/:15355:0:99999:7:::</code><br>\n用户名：加密后的密码：时间1：时间2：时间3：时间4：时间5：时间6：预留段`\t<br>\n加密后的密码：以分开，第一个后是1，说明加密算法是md5，第二个后是加的sail，第三个后是加的密码。<br>\n时间1：从1970年1月1日起到最近的修改的天数<br>\n时间2：密码的最短使用期限<br>\n时间3：密码最长使用期限<br>\n时间4：在密码过期之前多少天开始警告<br>\n时间5：在密码过期多少天用户禁用<br>\n时间6：自1970年1月1日起多长时间用户被禁用</li>\n<li>注：<code>/etc/group</code> 存放组的账号，存放形式：<br>\n<code>slackware:x:5000</code> : <code>Name：passwd位置：GID：附加组的用户列表</code>。</li>\n<li>注：</li>\n<li>交互式登陆的用户：<br>\n<code>/etc/profile --&gt;/etc/profile.d/* --&gt;~/.bash_profile --&gt;~/.bashrc --&gt;/etc/bashrc</code></li>\n</ul>\n</li>\n<li>非交互式登录：<br>\n/.bashrc --&gt;/etc/bashrc --&gt;.etc/profile.d/*`</li>\n</ul>\n</li>\n<li><code>/proc</code> 配置文件\n<ul>\n<li><code>/proc/dma</code> 显示当前使用的DMA 通道。\n<ul>\n<li><code>/proc/filesystems</code> 核心配置的文件系统。</li>\n<li><code>/proc/interrupts</code> 显示使用的中断，and how many of each there have been.</li>\n<li><code>/proc/ioports</code> 当前使用的I/O 端口。</li>\n<li><code>/proc/kcore</code> 系统物理内存映象。与物理内存大小完全一样，但不实际占用这么多内存；<br>\nit is generated on the fly as programs access it.<br>\n(记住：除非你把它拷贝到什么地方，<code>/proc</code> 下没有任何东西占用任何磁盘空间。）</li>\n<li><code>/proc/kmsg</code> 核心输出的消息。也被送到syslog</li>\n<li><code>/proc/ksyms</code> 核心符号表</li>\n<li><code>/proc/loadavg</code> 系统&quot;平均负载&quot;；3 个指示器指出系统当前的工作量。</li>\n<li><code>/proc/meminfo</code> 存储器使用信息，包括物理内存和swap。</li>\n<li><code>/proc/modules</code> 当前加载了哪些核心模块。</li>\n<li><code>/proc/net</code> 网络协议状态信息。</li>\n<li><code>/proc/self</code> 到查看<code>/proc</code> 的程序的进程目录的符号连接。当2 个进程查看<code>/proc</code><br>\n时，是不同的连接。这主要便于程序得到它自己的进程目录。</li>\n<li><code>/proc/stat</code> 系统的不同状态，such as the number of page faults since the system was booted.</li>\n<li><code>/proc/uptime</code> 系统启动的时间长度。</li>\n<li><code>/proc/cpuinfo</code> 处理器信息，如类型、制造商、型号和性能。</li>\n<li><code>/proc/devices</code> 当前运行的核心配置的设备驱动的列表。</li>\n<li><code>/proc/version</code> 核心版本。</li>\n<li><code>/proc/mdstat</code> RAID设备的信息</li>\n<li><code>/proc/cmdline</code> ro root=/dev/vol0/root rhgb quiet grub信息</li>\n<li><code>/proc/cpuinfo</code> 显示CPU的相关信息</li>\n<li><code>/proc/cpuset</code> cpu集合 用于显示当前进程可以应用到哪些cpu上</li>\n<li><code>/proc/filesystem</code>当前系统支持的文件系统种类</li>\n<li><code>/etc/245/vm</code> 系统进程ID号为245的进程的虚拟内存信息</li>\n<li><code>/etc/245/kernel</code> 系统进程ID号为245的进程的内核信息</li>\n<li><code>/proc/mounts</code> 挂载的所有文件系统</li>\n<li><code>/proc/swaps</code> 交换分区信息</li>\n<li><code>/proc/uptime</code> 启动系统运行时长</li>\n<li><code>/proc/sys</code> (具有写权限)定义内核参数的值来定义内核的功能<br>\n<code>/proc/sys/kernel/hostname</code> 主机名的设定</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>/usr</code> 配置文件\n<ul>\n<li><code>/usr/bin</code> 众多的应用程序\n<ul>\n<li><code>/usr/doc</code> linux 文档</li>\n<li><code>/usr/include</code> linux 下C 开发和编译应用程序所需要的头文件</li>\n<li><code>/usr/include/g++</code> C++编译器的头文</li>\n<li><code>/usr/lib</code> 常用的动态链接库和软件包的配置文件</li>\n<li><code>/usr/src</code> 系统软件的源代码</li>\n<li><code>/usr/src/linux</code> linux 内核的源代码</li>\n<li><code>/usr/local/bin</code> 本地增加的命令</li>\n<li><code>/usr/local/lib</code> 本地增加的库</li>\n<li><code>/usr/sbin</code> 为系统管理员保留的程序</li>\n<li><code>/usr/share/fonts</code> 字体文件</li>\n<li><code>/usr/share/doc</code> 各种文档文件</li>\n<li><code>/usr/share/man</code> 系统手册页</li>\n<li><code>/usr/local/apache/man</code> 定义man目录文集<br>\n其它目录配置文件</li>\n<li><code>/dev/null</code> 没有用的文件所放的位置，相当于回收站，吞噬设备</li>\n<li><code>/dev/zero</code> 初始化磁盘（吐零）</li>\n<li><code>/dev/random</code> 随机数生成器，熵池</li>\n<li><code>/dev/urandom</code> 伪随机数生成器，熵池。（当熵池耗尽时，用软件生成随机数）</li>\n<li><code>/var/spool/mail/root</code> 定义mail设置发送用户为root</li>\n<li><code>/bin/bash</code> 系统内置脚本</li>\n<li><code>/home/USERNAME</code> 用户配额文件</li>\n<li><code>/var/spool/cron/USERNAME</code> 用户定义的任务计划</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>目录结构：\n<ul>\n<li><code>/boot</code> 用于自举加载程序（LILO 或GRUB）的文件。当计算机启动时（如果有多个操作系统，<br>\n有可能允许你选择启动哪一个操作系统），这些文件首先被装载。这个目录也会包含LINUX 核（压缩文件<br>\nvmlinuz），但LINUX 核也可以存在别处，只要配置LILO 并且LILO 知道LINUX 核在哪儿。\n<ul>\n<li><code>/bin</code> 系统启动时需要的引导程序(二进制执行文件)，这些文件可以被普通用户使用</li>\n<li><code>/dev</code> 代表硬件组件的设备文件目录。LINUX 下设备被当成文件，这样一来硬件被抽象化，便<br>\n于读写、网络共享以及需要临时装载到文件系统中。正常情况下，设备会有一个独立的子目录。这些设备<br>\n的内容会出现在独立的子目录下。LINUX 没有所谓的驱动符。</li>\n<li><code>/etc</code> 存放各种配置文件</li>\n<li><code>/etc/rc.d</code> 启动的配置文件和脚本</li>\n<li><code>/home</code> 用户主目录，包含参数设置文件、个性化文件、文档、数据、EMAIL、缓存数据等</li>\n<li><code>/lib</code> 标准程序设计库，又叫动态链接共享库，作用类似windows 里的.dll 文件</li>\n<li><code>/sbin</code> 为系统管理员保留的用于系统启动时的引导程序(二进制执行文件)，这些文件不打算被<br>\n普通用户使用(普通用户仍然可以使用它们，但要指定目录)</li>\n<li><code>/tmp</code> 公用的临时文件存储点，该目录会被自动清理干净</li>\n<li><code>/root</code> 系统管理员的主目录</li>\n<li><code>/mnt</code> 系统提供这个目录是让用户临时挂载其他的文件系统。</li>\n<li><code>/lost+found</code>这个目录平时是空的，系统非正常关机而留下“无家可归”的文件。</li>\n<li><code>/proc</code> 虚拟的目录，是系统内存的映射，可直接访问这个目录来获取系统信息。目录整个包含<br>\n虚幻的文件。它们实际上并不存在磁盘上，也不占用任何空间。（用<code>ls –l</code> 可以显示它们的大小）当查看<br>\n这些文件时，实际上是在访问存在内存中的信息，这些信息用于访问系统</li>\n<li><code>/proc/1</code> 关于进程1 的信息目录。每个进程在<code>/proc</code> 下有一个名为其进程号的目录。</li>\n<li><code>/var</code> 某些大文件的溢出区，比方说各种服务的日志文件，包含在正常操作中被改变的文件：<br>\n假脱机文件、记录文件、加锁文件、临时文件和页格式化文件等</li>\n<li><code>/var/spool mail, news</code>, 打印队列和其他队列工作的目录。每个不同的spool 在<code>/var/spool</code> 下有自己的<br>\n子目录，例如，用户的邮箱在<code>/var/spool/mail</code> 中。</li>\n<li><code>/opt</code> 可选的应用程序，譬如，REDHAT 5.2 下的KDE （REDHAT 6.0 下，KDE 放在其它的<br>\nXWINDOWS 应用程序中，主执行程序在<code>/usr/bin</code> 目录下）</li>\n<li><code>/usr</code> 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。</li>\n<li><code>/home /var /usr/local</code> 经常是单独分区，因为经常会操作，容易产生碎片</li>\n<li><code>/srv</code> 该目录存放一些服务启动之后需要提取的数据</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>转载自<a href=\"https://www.cnblogs.com/zxj015/p/4457868.html\" target=\"_blank\" rel=\"noopener\">CoderZhuang</a>，对<a href=\"https://www.cnblogs.com/zxj015/p/4457868.html\" target=\"_blank\" rel=\"noopener\">CoderZhuang</a>先生的博客进行补充和整理。</p>\n</blockquote>\n<ol>\n<li><code>/etc</code> 配置文件\n<ul>\n<li><code>/etc/passwd</code> 用户数据库，其中的域给出了用户名、真实姓名、家目录、加密口令和用户的其他信息\n<ul>\n<li><code>/etc/group</code> 类似<code>/etc/passwd</code> ，但说明的不是用户而是组。</li>\n<li><code>/etc/inittab</code> init 的配置文件</li>\n<li><code>/etc/issue</code> 在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。内容由系统管理员确定。</li>\n<li><code>/etc/motd</code> 成功登录后自动输出，内容由系统管理员确定，经常用于通告信息，如计划关时间的警告。</li>\n<li><code>/etc/mtab</code> 当前安装的文件系统列表。由<code>scripts</code> 初始化，并由<code>mount</code> 命令自动更新。需要一个当前<br>\n安装的文件系统的列表时使用，例如df 命令，当<code>df –a</code> 时，查看到的信息应和其一致。</li>\n<li><code>/etc/shadow</code> 在安装了影子口令软件的系统上的影子口令文件。影子口令文件将<code>/etc/passwd</code> 文件中的<br>\n加密口令移动到<code>/etc/shadow</code> 中，而后者只对<strong>root</strong> 可读。这使破译口令更困难。</li>\n</ul>\n</li>\n<li><code>/etc/login.defs</code> login 命令的配置文件\n<ul>\n<li><code>/etc/profile</code> , <code>/etc/csh.login</code> , <code>/etc/csh.cshrc</code> 登录或启动（cshell）时读取的文件（shell不同，文件名称不同，具体查看man手册）。</li>\n<li><code>/etc/printcap</code> 类似<code>/etc/termcap</code> ，但针对打印机。语法不同。</li>\n<li><code>/etc/securetty</code> 确认安全终端，即哪个终端允许<strong>root</strong>登录。一般只列出虚拟控制台，这样就不可能<br>\n(至少很困难)通过modem 或网络闯入系统并得到超级用户特权。</li>\n<li><code>/etc/shells</code> 列出可信任的shell。chsh命令允许用户在本文件指定范围内改变登录shell。提供一<br>\n台机器FTP 服务的服务进程ftpd 检查用户shell 是否列在 <code>/etc/shells</code><br>\n文件中，如果不是将不允许该用户登录。</li>\n<li><code>/etc/termcap</code>终端性能数据库。说明不同的终端用什么&quot;转义序列&quot;控制。写程序时不直接输出转义序列(这样<br>\n只能工作于特定品牌的终端)，而是从<code>/etc/termcap</code>中查找要做的工作的正确序列。这样，多数的<br>\n程序可以在多数终端上运行。</li>\n<li><code>/etc/inputrc</code> 输入设备配置文件</li>\n<li><code>/etc/default/useradd</code> 添加用户的默认信息的文件</li>\n<li><code>/etc/login.defs</code> 是用户密码信息的默认属性</li>\n<li><code>/etc/skel</code> 用户信息的骨架</li>\n<li><code>/sbin/nologin</code> 不能登陆的用户</li>\n<li><code>/var/log/message</code> 系统的日志文件</li>\n<li><code>/etc/profile</code>全局配置文件可以在添加一行<code>PATH=$PATH：/usr/local/mysql/bin</code>即可以软件的命令可以使用</li>\n<li><code>/root/bashrc</code> 命令的别名</li>\n<li><code>/etc/yum.repos.d</code> 配置本地yun源(红帽系)</li>\n<li><code>/etc/apt/sources.list.d</code> 配置本地apt源(debian系)</li>\n<li><code>/etc/httpd/conf/httpd.conf</code> 配置http服务的配置文件</li>\n<li><code>/etc/fstab</code> 系统启动时自动加载的设备，（用于配置自动挂载设备）</li>\n<li><code>/etc/selinux</code> 安全Linux设定</li>\n<li><code>/etc/sysconfig/network</code> 可以更改<code>hostname</code>（主机名）以及网卡工作状态</li>\n<li><code>/etc/hosts</code> 更改主机名和IP 地址的对应关系，请注意其格式为<code>hostname.domain</code> <code>hostname</code> <code>localhost</code><br>\n<code>localhost.domian</code>，当修改主机名后必须修改该文件</li>\n<li><code>/etc/resolv.conf</code> 可配置DNS 地址，即第一DNS，第二DNS 以及DNS 的默认搜索路径</li>\n<li><code>/etc/sysconfig/networking/profiles/default</code> 内含数个文件，可配置hosts、网卡、DNS 地址及<br>\nDNS 搜索路径等</li>\n<li><code>/etc/sysconfig/network-scripts/ifcfg-eth0</code> 配置网卡eth0(具体名称请使用<code>ifconfig</code>查看)</li>\n<li><code>/etc/rc.d/init.d/network restart</code> 重启网络</li>\n<li><code>/etc/rc.d/init.d</code> 用于放置几乎所有服务的启动脚本</li>\n<li><code>/etc/sysctl.conf</code> 内核参数配置文件<br>\n<code>/etc/sysconfig/i18n</code>\t设置系统语言和字符类型</li>\n<li><code>/etc/crontab</code> 系统定义的任务计划</li>\n<li><code>/etc/anacrontab</code> 实现检查过期和未完成的crontab的任务的配置文件</li>\n<li><code>/etc/rc.d/init.d/functions</code> 定义功能的配置文件</li>\n<li><code>/etc/rc.d/rc.sysinit</code> 系统启动设置配置文件</li>\n<li><code>/etc/sysconfig/system-config-firewall</code>配置防火墙的信任端口，以及防火墙的工作状态。图形化配置防火<br>\n墙的存档文件，具体讲只保存图形界面的otherport里面设置的项目，如果主配置<br>\n文件存在相应的配置条目，那么它里面的配置条目存在与否并不重要。</li>\n<li><code>/etc/sysconfig/iptables</code> 防火墙主配置文件</li>\n<li><code>/etc/sysconfig/system-config-securitylevel</code> 系统安全等级文件，在防火墙配置中不会涉及</li>\n<li><code>/etc/xinetd.conf xinetd</code> 的主配置文件</li>\n<li><code>/etc/hosts.allow</code> TCP的一个许可表</li>\n<li><code>/etc/host.deny</code> TCP的一个拒绝表</li>\n<li><code>/etc/squid/squid.conf</code> 代理服务器（SQUID）配置文件</li>\n<li><code>/etc/sysconfig/vncservers</code> VNC服务配置文件</li>\n<li><code>/etc/vsftpd/ftpusers</code> 用于保存不允许进行FTP 登录的本地用户账号（黑名单）</li>\n<li><code>/etc/vsftpd/user_list</code> 更灵活的用户访问控制，但需要在主配置文件中进行声明</li>\n<li><code>/etc/inetd.conf</code> swat 配置</li>\n<li><code>/etc/dhcpd.conf</code> DHCP 的配置文件</li>\n<li><code>/etc/rc.d/init.d/dhcpd stop</code> 停止DHCP</li>\n<li><code>/etc/access</code> 可以对sendmail 的邮件流进行控制</li>\n<li><code>/etc/udev/rules.d</code> 系统初始化时将硬件探测信息输出成设备配置文件，是一个程序。<br>\n让用户定义udev的规则，从而实现在创建设备文件使用不同的设备文件名</li>\n<li>注：<code>/etc/passwd</code> 存放用户的账号，存放形式 ：<br>\n<code>root:x:0:0:root:/root:/bin/bash</code> :<br>\n<code>用户名：密码位：UID：GID：CECOS(注释)：diectory（家目录）:shell</code></li>\n<li>注：<code>/etc/shadow</code> 存放用户的密码<br>\n<code>slaceware:$1$12345678$0ME5N6oDyoEAwUp7b5UDM/:15355:0:99999:7:::</code><br>\n用户名：加密后的密码：时间1：时间2：时间3：时间4：时间5：时间6：预留段`\t<br>\n加密后的密码：以分开，第一个后是1，说明加密算法是md5，第二个后是加的sail，第三个后是加的密码。<br>\n时间1：从1970年1月1日起到最近的修改的天数<br>\n时间2：密码的最短使用期限<br>\n时间3：密码最长使用期限<br>\n时间4：在密码过期之前多少天开始警告<br>\n时间5：在密码过期多少天用户禁用<br>\n时间6：自1970年1月1日起多长时间用户被禁用</li>\n<li>注：<code>/etc/group</code> 存放组的账号，存放形式：<br>\n<code>slackware:x:5000</code> : <code>Name：passwd位置：GID：附加组的用户列表</code>。</li>\n<li>注：</li>\n<li>交互式登陆的用户：<br>\n<code>/etc/profile --&gt;/etc/profile.d/* --&gt;~/.bash_profile --&gt;~/.bashrc --&gt;/etc/bashrc</code></li>\n</ul>\n</li>\n<li>非交互式登录：<br>\n/.bashrc --&gt;/etc/bashrc --&gt;.etc/profile.d/*`</li>\n</ul>\n</li>\n<li><code>/proc</code> 配置文件\n<ul>\n<li><code>/proc/dma</code> 显示当前使用的DMA 通道。\n<ul>\n<li><code>/proc/filesystems</code> 核心配置的文件系统。</li>\n<li><code>/proc/interrupts</code> 显示使用的中断，and how many of each there have been.</li>\n<li><code>/proc/ioports</code> 当前使用的I/O 端口。</li>\n<li><code>/proc/kcore</code> 系统物理内存映象。与物理内存大小完全一样，但不实际占用这么多内存；<br>\nit is generated on the fly as programs access it.<br>\n(记住：除非你把它拷贝到什么地方，<code>/proc</code> 下没有任何东西占用任何磁盘空间。）</li>\n<li><code>/proc/kmsg</code> 核心输出的消息。也被送到syslog</li>\n<li><code>/proc/ksyms</code> 核心符号表</li>\n<li><code>/proc/loadavg</code> 系统&quot;平均负载&quot;；3 个指示器指出系统当前的工作量。</li>\n<li><code>/proc/meminfo</code> 存储器使用信息，包括物理内存和swap。</li>\n<li><code>/proc/modules</code> 当前加载了哪些核心模块。</li>\n<li><code>/proc/net</code> 网络协议状态信息。</li>\n<li><code>/proc/self</code> 到查看<code>/proc</code> 的程序的进程目录的符号连接。当2 个进程查看<code>/proc</code><br>\n时，是不同的连接。这主要便于程序得到它自己的进程目录。</li>\n<li><code>/proc/stat</code> 系统的不同状态，such as the number of page faults since the system was booted.</li>\n<li><code>/proc/uptime</code> 系统启动的时间长度。</li>\n<li><code>/proc/cpuinfo</code> 处理器信息，如类型、制造商、型号和性能。</li>\n<li><code>/proc/devices</code> 当前运行的核心配置的设备驱动的列表。</li>\n<li><code>/proc/version</code> 核心版本。</li>\n<li><code>/proc/mdstat</code> RAID设备的信息</li>\n<li><code>/proc/cmdline</code> ro root=/dev/vol0/root rhgb quiet grub信息</li>\n<li><code>/proc/cpuinfo</code> 显示CPU的相关信息</li>\n<li><code>/proc/cpuset</code> cpu集合 用于显示当前进程可以应用到哪些cpu上</li>\n<li><code>/proc/filesystem</code>当前系统支持的文件系统种类</li>\n<li><code>/etc/245/vm</code> 系统进程ID号为245的进程的虚拟内存信息</li>\n<li><code>/etc/245/kernel</code> 系统进程ID号为245的进程的内核信息</li>\n<li><code>/proc/mounts</code> 挂载的所有文件系统</li>\n<li><code>/proc/swaps</code> 交换分区信息</li>\n<li><code>/proc/uptime</code> 启动系统运行时长</li>\n<li><code>/proc/sys</code> (具有写权限)定义内核参数的值来定义内核的功能<br>\n<code>/proc/sys/kernel/hostname</code> 主机名的设定</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>/usr</code> 配置文件\n<ul>\n<li><code>/usr/bin</code> 众多的应用程序\n<ul>\n<li><code>/usr/doc</code> linux 文档</li>\n<li><code>/usr/include</code> linux 下C 开发和编译应用程序所需要的头文件</li>\n<li><code>/usr/include/g++</code> C++编译器的头文</li>\n<li><code>/usr/lib</code> 常用的动态链接库和软件包的配置文件</li>\n<li><code>/usr/src</code> 系统软件的源代码</li>\n<li><code>/usr/src/linux</code> linux 内核的源代码</li>\n<li><code>/usr/local/bin</code> 本地增加的命令</li>\n<li><code>/usr/local/lib</code> 本地增加的库</li>\n<li><code>/usr/sbin</code> 为系统管理员保留的程序</li>\n<li><code>/usr/share/fonts</code> 字体文件</li>\n<li><code>/usr/share/doc</code> 各种文档文件</li>\n<li><code>/usr/share/man</code> 系统手册页</li>\n<li><code>/usr/local/apache/man</code> 定义man目录文集<br>\n其它目录配置文件</li>\n<li><code>/dev/null</code> 没有用的文件所放的位置，相当于回收站，吞噬设备</li>\n<li><code>/dev/zero</code> 初始化磁盘（吐零）</li>\n<li><code>/dev/random</code> 随机数生成器，熵池</li>\n<li><code>/dev/urandom</code> 伪随机数生成器，熵池。（当熵池耗尽时，用软件生成随机数）</li>\n<li><code>/var/spool/mail/root</code> 定义mail设置发送用户为root</li>\n<li><code>/bin/bash</code> 系统内置脚本</li>\n<li><code>/home/USERNAME</code> 用户配额文件</li>\n<li><code>/var/spool/cron/USERNAME</code> 用户定义的任务计划</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>目录结构：\n<ul>\n<li><code>/boot</code> 用于自举加载程序（LILO 或GRUB）的文件。当计算机启动时（如果有多个操作系统，<br>\n有可能允许你选择启动哪一个操作系统），这些文件首先被装载。这个目录也会包含LINUX 核（压缩文件<br>\nvmlinuz），但LINUX 核也可以存在别处，只要配置LILO 并且LILO 知道LINUX 核在哪儿。\n<ul>\n<li><code>/bin</code> 系统启动时需要的引导程序(二进制执行文件)，这些文件可以被普通用户使用</li>\n<li><code>/dev</code> 代表硬件组件的设备文件目录。LINUX 下设备被当成文件，这样一来硬件被抽象化，便<br>\n于读写、网络共享以及需要临时装载到文件系统中。正常情况下，设备会有一个独立的子目录。这些设备<br>\n的内容会出现在独立的子目录下。LINUX 没有所谓的驱动符。</li>\n<li><code>/etc</code> 存放各种配置文件</li>\n<li><code>/etc/rc.d</code> 启动的配置文件和脚本</li>\n<li><code>/home</code> 用户主目录，包含参数设置文件、个性化文件、文档、数据、EMAIL、缓存数据等</li>\n<li><code>/lib</code> 标准程序设计库，又叫动态链接共享库，作用类似windows 里的.dll 文件</li>\n<li><code>/sbin</code> 为系统管理员保留的用于系统启动时的引导程序(二进制执行文件)，这些文件不打算被<br>\n普通用户使用(普通用户仍然可以使用它们，但要指定目录)</li>\n<li><code>/tmp</code> 公用的临时文件存储点，该目录会被自动清理干净</li>\n<li><code>/root</code> 系统管理员的主目录</li>\n<li><code>/mnt</code> 系统提供这个目录是让用户临时挂载其他的文件系统。</li>\n<li><code>/lost+found</code>这个目录平时是空的，系统非正常关机而留下“无家可归”的文件。</li>\n<li><code>/proc</code> 虚拟的目录，是系统内存的映射，可直接访问这个目录来获取系统信息。目录整个包含<br>\n虚幻的文件。它们实际上并不存在磁盘上，也不占用任何空间。（用<code>ls –l</code> 可以显示它们的大小）当查看<br>\n这些文件时，实际上是在访问存在内存中的信息，这些信息用于访问系统</li>\n<li><code>/proc/1</code> 关于进程1 的信息目录。每个进程在<code>/proc</code> 下有一个名为其进程号的目录。</li>\n<li><code>/var</code> 某些大文件的溢出区，比方说各种服务的日志文件，包含在正常操作中被改变的文件：<br>\n假脱机文件、记录文件、加锁文件、临时文件和页格式化文件等</li>\n<li><code>/var/spool mail, news</code>, 打印队列和其他队列工作的目录。每个不同的spool 在<code>/var/spool</code> 下有自己的<br>\n子目录，例如，用户的邮箱在<code>/var/spool/mail</code> 中。</li>\n<li><code>/opt</code> 可选的应用程序，譬如，REDHAT 5.2 下的KDE （REDHAT 6.0 下，KDE 放在其它的<br>\nXWINDOWS 应用程序中，主执行程序在<code>/usr/bin</code> 目录下）</li>\n<li><code>/usr</code> 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。</li>\n<li><code>/home /var /usr/local</code> 经常是单独分区，因为经常会操作，容易产生碎片</li>\n<li><code>/srv</code> 该目录存放一些服务启动之后需要提取的数据</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n"},{"title":"内存信息获取","date":"2019-09-02T08:43:25.000Z","cover":"title.jpg","_content":"\n* `free`：该工具用来获取内存信息\n\n* `grep`：该工具用来筛选数据\n\n* `awk'`：该工具用来处理数据\n\n* 代码：\n\n  ```bash\n  #!/bin/bash\n  \n  free -m | grep \"^Mem\" | awk -v last_per=$1 -v nowdate=$(date +\"%Y-%m-%d_%H:%M:%S\") '\n  {\n      printf(\"%s %sM %sM %.1f%% %.1f%%\\n\", nowdate, $2, $7, $3 / $2 * 100, 0.3 * last_per + 0.7 * ($3 / $2 * 100));\n  }'\n  \n  ```\n\n  \n","source":"_posts/内存信息获取.md","raw":"---\ntitle: 内存信息获取\ndate: 2019-09-02 16:43:25\ncover: title.jpg\ntags:\n- script\n- linux\n---\n\n* `free`：该工具用来获取内存信息\n\n* `grep`：该工具用来筛选数据\n\n* `awk'`：该工具用来处理数据\n\n* 代码：\n\n  ```bash\n  #!/bin/bash\n  \n  free -m | grep \"^Mem\" | awk -v last_per=$1 -v nowdate=$(date +\"%Y-%m-%d_%H:%M:%S\") '\n  {\n      printf(\"%s %sM %sM %.1f%% %.1f%%\\n\", nowdate, $2, $7, $3 / $2 * 100, 0.3 * last_per + 0.7 * ($3 / $2 * 100));\n  }'\n  \n  ```\n\n  \n","slug":"内存信息获取","published":1,"updated":"2020-04-08T03:41:35.950Z","_id":"ck8qr69dg000s5d3affd9qkt0","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>\n<p><code>free</code>：该工具用来获取内存信息</p>\n</li>\n<li>\n<p><code>grep</code>：该工具用来筛选数据</p>\n</li>\n<li>\n<p><code>awk'</code>：该工具用来处理数据</p>\n</li>\n<li>\n<p>代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">free -m | grep <span class=\"string\">\"^Mem\"</span> | awk -v last_per=<span class=\"variable\">$1</span> -v nowdate=$(date +<span class=\"string\">\"%Y-%m-%d_%H:%M:%S\"</span>) <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">    printf(\"%s %sM %sM %.1f%% %.1f%%\\n\", nowdate, $2, $7, $3 / $2 * 100, 0.3 * last_per + 0.7 * ($3 / $2 * 100));</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>\n<p><code>free</code>：该工具用来获取内存信息</p>\n</li>\n<li>\n<p><code>grep</code>：该工具用来筛选数据</p>\n</li>\n<li>\n<p><code>awk'</code>：该工具用来处理数据</p>\n</li>\n<li>\n<p>代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">free -m | grep <span class=\"string\">\"^Mem\"</span> | awk -v last_per=<span class=\"variable\">$1</span> -v nowdate=$(date +<span class=\"string\">\"%Y-%m-%d_%H:%M:%S\"</span>) <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">    printf(\"%s %sM %sM %.1f%% %.1f%%\\n\", nowdate, $2, $7, $3 / $2 * 100, 0.3 * last_per + 0.7 * ($3 / $2 * 100));</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"用户信息获取","date":"2019-09-02T08:41:40.000Z","cover":"title.jpg","_content":"\n> 欢迎大家转载，转载请注明出处，谢谢！\n* 知识准备\n\n  1. `w`：获取当前登录信息\n  2. `grep`：对数据进行筛选\n  3. `cut`：对字符串进行剪切\n  4. `sort`：排序\n  5. `uniq`：统计每个字符串个数\n  6. `head`：显示开头几行\n  7. `awk`：文本处理工具\n\n* 代码\n\n  ```bash\n  #!/bin/bash\n  \n  nowtime=`date +\"%Y-%m-%d_%H:%M:%S\"`\n  usernum=`awk -F \":\" 'BEGIN {num = 0;}{if ($3 >= 1000) {num++;}}END {printf(\"%d\\n\", num);}' /etc/passwd`\n  \n  active_user=`last | awk NF | grep  -v \"system\" | grep -v \"wtmp\" | cut -d \" \" -f1 | sort | uniq -c | sort -n -r | head -3 | awk 'BEGIN{num = 0}{if(num > 0) {printf(\",\")};printf(\"%s\", $2);num++}'`\n  \n  all_have_root=`cat /etc/group | grep \"^sudo\" | cut -d \":\" -f4`\n  \n  now_login=`w | awk 'BEGIN{num=0} {if (NR > 2){if(num > 0) {printf(\",\");} printf(\"%s_%s_%s\", $1, $3, $2);num++}}'`\n  \n  echo \"$nowtime $usernum [$active_user] [$all_have_root] [$now_login]\"\n  \n  ```\n\n  \n","source":"_posts/用户信息获取.md","raw":"---\ntitle: 用户信息获取\ndate: 2019-09-02 16:41:40\ncover: title.jpg\ntags: \n- script\n- linux\n---\n\n> 欢迎大家转载，转载请注明出处，谢谢！\n* 知识准备\n\n  1. `w`：获取当前登录信息\n  2. `grep`：对数据进行筛选\n  3. `cut`：对字符串进行剪切\n  4. `sort`：排序\n  5. `uniq`：统计每个字符串个数\n  6. `head`：显示开头几行\n  7. `awk`：文本处理工具\n\n* 代码\n\n  ```bash\n  #!/bin/bash\n  \n  nowtime=`date +\"%Y-%m-%d_%H:%M:%S\"`\n  usernum=`awk -F \":\" 'BEGIN {num = 0;}{if ($3 >= 1000) {num++;}}END {printf(\"%d\\n\", num);}' /etc/passwd`\n  \n  active_user=`last | awk NF | grep  -v \"system\" | grep -v \"wtmp\" | cut -d \" \" -f1 | sort | uniq -c | sort -n -r | head -3 | awk 'BEGIN{num = 0}{if(num > 0) {printf(\",\")};printf(\"%s\", $2);num++}'`\n  \n  all_have_root=`cat /etc/group | grep \"^sudo\" | cut -d \":\" -f4`\n  \n  now_login=`w | awk 'BEGIN{num=0} {if (NR > 2){if(num > 0) {printf(\",\");} printf(\"%s_%s_%s\", $1, $3, $2);num++}}'`\n  \n  echo \"$nowtime $usernum [$active_user] [$all_have_root] [$now_login]\"\n  \n  ```\n\n  \n","slug":"用户信息获取","published":1,"updated":"2020-04-08T03:44:37.986Z","_id":"ck8qr69dh000u5d3anvecixx9","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>欢迎大家转载，转载请注明出处，谢谢！</p>\n</blockquote>\n<ul>\n<li>\n<p>知识准备</p>\n<ol>\n<li><code>w</code>：获取当前登录信息</li>\n<li><code>grep</code>：对数据进行筛选</li>\n<li><code>cut</code>：对字符串进行剪切</li>\n<li><code>sort</code>：排序</li>\n<li><code>uniq</code>：统计每个字符串个数</li>\n<li><code>head</code>：显示开头几行</li>\n<li><code>awk</code>：文本处理工具</li>\n</ol>\n</li>\n<li>\n<p>代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">nowtime=`date +<span class=\"string\">\"%Y-%m-%d_%H:%M:%S\"</span>`</span><br><span class=\"line\">usernum=`awk -F <span class=\"string\">\":\"</span> <span class=\"string\">'BEGIN &#123;num = 0;&#125;&#123;if ($3 &gt;= 1000) &#123;num++;&#125;&#125;END &#123;printf(\"%d\\n\", num);&#125;'</span> /etc/passwd`</span><br><span class=\"line\"></span><br><span class=\"line\">active_user=`last | awk NF | grep  -v <span class=\"string\">\"system\"</span> | grep -v <span class=\"string\">\"wtmp\"</span> | cut -d <span class=\"string\">\" \"</span> -f1 | sort | uniq -c | sort -n -r | head -3 | awk <span class=\"string\">'BEGIN&#123;num = 0&#125;&#123;if(num &gt; 0) &#123;printf(\",\")&#125;;printf(\"%s\", $2);num++&#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">all_have_root=`cat /etc/group | grep <span class=\"string\">\"^sudo\"</span> | cut -d <span class=\"string\">\":\"</span> -f4`</span><br><span class=\"line\"></span><br><span class=\"line\">now_login=`w | awk <span class=\"string\">'BEGIN&#123;num=0&#125; &#123;if (NR &gt; 2)&#123;if(num &gt; 0) &#123;printf(\",\");&#125; printf(\"%s_%s_%s\", $1, $3, $2);num++&#125;&#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$nowtime</span> <span class=\"variable\">$usernum</span> [<span class=\"variable\">$active_user</span>] [<span class=\"variable\">$all_have_root</span>] [<span class=\"variable\">$now_login</span>]\"</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>欢迎大家转载，转载请注明出处，谢谢！</p>\n</blockquote>\n<ul>\n<li>\n<p>知识准备</p>\n<ol>\n<li><code>w</code>：获取当前登录信息</li>\n<li><code>grep</code>：对数据进行筛选</li>\n<li><code>cut</code>：对字符串进行剪切</li>\n<li><code>sort</code>：排序</li>\n<li><code>uniq</code>：统计每个字符串个数</li>\n<li><code>head</code>：显示开头几行</li>\n<li><code>awk</code>：文本处理工具</li>\n</ol>\n</li>\n<li>\n<p>代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">nowtime=`date +<span class=\"string\">\"%Y-%m-%d_%H:%M:%S\"</span>`</span><br><span class=\"line\">usernum=`awk -F <span class=\"string\">\":\"</span> <span class=\"string\">'BEGIN &#123;num = 0;&#125;&#123;if ($3 &gt;= 1000) &#123;num++;&#125;&#125;END &#123;printf(\"%d\\n\", num);&#125;'</span> /etc/passwd`</span><br><span class=\"line\"></span><br><span class=\"line\">active_user=`last | awk NF | grep  -v <span class=\"string\">\"system\"</span> | grep -v <span class=\"string\">\"wtmp\"</span> | cut -d <span class=\"string\">\" \"</span> -f1 | sort | uniq -c | sort -n -r | head -3 | awk <span class=\"string\">'BEGIN&#123;num = 0&#125;&#123;if(num &gt; 0) &#123;printf(\",\")&#125;;printf(\"%s\", $2);num++&#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">all_have_root=`cat /etc/group | grep <span class=\"string\">\"^sudo\"</span> | cut -d <span class=\"string\">\":\"</span> -f4`</span><br><span class=\"line\"></span><br><span class=\"line\">now_login=`w | awk <span class=\"string\">'BEGIN&#123;num=0&#125; &#123;if (NR &gt; 2)&#123;if(num &gt; 0) &#123;printf(\",\");&#125; printf(\"%s_%s_%s\", $1, $3, $2);num++&#125;&#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$nowtime</span> <span class=\"variable\">$usernum</span> [<span class=\"variable\">$active_user</span>] [<span class=\"variable\">$all_have_root</span>] [<span class=\"variable\">$now_login</span>]\"</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"服务器健康监控","date":"2019-09-02T08:36:30.000Z","cover":"title.jpg","_content":"\n> [项目地址](https://github.com/sunowsir/SHMS)\n\n* 简介：\n  使用C语言和bash脚本实现的服务器健康监控系统。服务器端通过执行bash脚本获取健康信息，利用socket即时发送到监控端主机。\n\n* 监测数据类型：\n  > 采用bash脚本获取相关信息\n  * cpu\n  * 内存\n  * 硬盘\n  * 恶意进程\n  * 系统信息\n  * 登录用户信息\n\n* 技术说明：\n\n  * C语言socket编程。\n  * C语言多线程与多进程编程。\n  * 数据结构实现（链表）。\n  * linux的bash脚本编程。\n  * linux systemd 的使用。\n\n* 架构：\n\n  * 监控端（Master）\n\n    * 线程一：\n\n      循环监听：使用socket监听，将收到的连接的套接字存储到长度最短的链表里。\n\n    * 线程二：\n\n      数据接收：通过读取配置文件创建若干数据发送的线程，每个线程分配一个链表。\n\n      从链表读取一个套接字，接收六组数据，然后断开连接，将该套接字从链表中删除。\n\n      保证数据的可靠性：六组数据，每组数据接收前，发送约定好的数据类型标志码，通知服务器本组应该发送的数据的类型。然后接收数据，存储到本地。\n\n    * 线程三：\n\n      紧急连接：单独开启通道，接受服务器连接，发送紧急报警信息。\n\n      该数据单独存放在发送者目录下。\n\n  * 服务器端（Server）:\n\n    * 线程一：\n\n      数据监测：运行监测脚本，将监测数据存储到文件。\n\n    * 线程二：\n\n      数据发送：根据监控端发来的数据类型读取相应监测数据的日志文件，发送给监控端。\n\n      通过分析监测数据判断是否有警报信息，发送警报信息。\n\n      数据获取与警报信息的即时性：无法做到数据发送的实时性，但是可以保证监测数据的实时性。每次只发送每种类型数据日志文件中的最上面一行，一共六组数据发送完成关闭连接。该方式牺牲一定的资源与数据传输的实时性，来保证线程一的一定程度的实时性。若非如此，只能采用文件锁来避免文件指针的冲突，这将会导致线程一阻塞，从而导致既服务法达到信息传输的实时性又无法达到监测数据与警报信息的实时性。\n\n* 相关文件：\n  * 配置文件：\n    * 监控端：`/etc/SHMS-Master/master.conf` \n    * 服务端；`/etc/SHMS-Server/server.conf`\n  * 运行日志文件：\n    * 监控端：`/var/log/SHMS-Master/SHMS-Master.log`\n    * 服务端：`/var/log/SHMS-Server/SHMS-Server.log`\n\n* 编译安装：\n  * 进入目录：`cd ./Server/build/`(服务器端)或`cd ./Master/build/`(监控端)\n  * 清空编译文件：`make clean`\n  * 编译链接生成可执行程序：`make`\n  * 添加到系统服务(使用systemd)：`sudo make install`\n\n* deb包安装：\n  * 下载deb包：[release页面](https://github.com/sunowsir/SHMS/releases) \n  * 安装：`sudo dpkg -i xxx.deb`\n\n* 服务操作：\n  * 服务器端：\n    * 查看服务状态：`sudo systemctl status SHMS-Server.service`\n    * 启动服务：`sudo systemctl start SHMS-Server.service`\n    * 停止服务：`sudo systemctl stop SHMS-Server.service`\n    * 重启服务：`sudo systemctl restart SHMS-Server.service`\n  * 监控端：\n    * 查看服务状态：`sudo systemctl status SHMS-Master.service`\n    * 启动服务：`sudo systemctl start SHMS-Master.service`\n    * 停止服务：`sudo systemctl stop SHMS-Master.service`\n    * 重启服务：`sudo systemctl restart SHMS-Master.service`\n","source":"_posts/服务器健康监控.md","raw":"---\ntitle: 服务器健康监控\ndate: 2019-09-02 16:36:30\ncover: title.jpg\ntags: \n- Project\n- linux\n- C\n---\n\n> [项目地址](https://github.com/sunowsir/SHMS)\n\n* 简介：\n  使用C语言和bash脚本实现的服务器健康监控系统。服务器端通过执行bash脚本获取健康信息，利用socket即时发送到监控端主机。\n\n* 监测数据类型：\n  > 采用bash脚本获取相关信息\n  * cpu\n  * 内存\n  * 硬盘\n  * 恶意进程\n  * 系统信息\n  * 登录用户信息\n\n* 技术说明：\n\n  * C语言socket编程。\n  * C语言多线程与多进程编程。\n  * 数据结构实现（链表）。\n  * linux的bash脚本编程。\n  * linux systemd 的使用。\n\n* 架构：\n\n  * 监控端（Master）\n\n    * 线程一：\n\n      循环监听：使用socket监听，将收到的连接的套接字存储到长度最短的链表里。\n\n    * 线程二：\n\n      数据接收：通过读取配置文件创建若干数据发送的线程，每个线程分配一个链表。\n\n      从链表读取一个套接字，接收六组数据，然后断开连接，将该套接字从链表中删除。\n\n      保证数据的可靠性：六组数据，每组数据接收前，发送约定好的数据类型标志码，通知服务器本组应该发送的数据的类型。然后接收数据，存储到本地。\n\n    * 线程三：\n\n      紧急连接：单独开启通道，接受服务器连接，发送紧急报警信息。\n\n      该数据单独存放在发送者目录下。\n\n  * 服务器端（Server）:\n\n    * 线程一：\n\n      数据监测：运行监测脚本，将监测数据存储到文件。\n\n    * 线程二：\n\n      数据发送：根据监控端发来的数据类型读取相应监测数据的日志文件，发送给监控端。\n\n      通过分析监测数据判断是否有警报信息，发送警报信息。\n\n      数据获取与警报信息的即时性：无法做到数据发送的实时性，但是可以保证监测数据的实时性。每次只发送每种类型数据日志文件中的最上面一行，一共六组数据发送完成关闭连接。该方式牺牲一定的资源与数据传输的实时性，来保证线程一的一定程度的实时性。若非如此，只能采用文件锁来避免文件指针的冲突，这将会导致线程一阻塞，从而导致既服务法达到信息传输的实时性又无法达到监测数据与警报信息的实时性。\n\n* 相关文件：\n  * 配置文件：\n    * 监控端：`/etc/SHMS-Master/master.conf` \n    * 服务端；`/etc/SHMS-Server/server.conf`\n  * 运行日志文件：\n    * 监控端：`/var/log/SHMS-Master/SHMS-Master.log`\n    * 服务端：`/var/log/SHMS-Server/SHMS-Server.log`\n\n* 编译安装：\n  * 进入目录：`cd ./Server/build/`(服务器端)或`cd ./Master/build/`(监控端)\n  * 清空编译文件：`make clean`\n  * 编译链接生成可执行程序：`make`\n  * 添加到系统服务(使用systemd)：`sudo make install`\n\n* deb包安装：\n  * 下载deb包：[release页面](https://github.com/sunowsir/SHMS/releases) \n  * 安装：`sudo dpkg -i xxx.deb`\n\n* 服务操作：\n  * 服务器端：\n    * 查看服务状态：`sudo systemctl status SHMS-Server.service`\n    * 启动服务：`sudo systemctl start SHMS-Server.service`\n    * 停止服务：`sudo systemctl stop SHMS-Server.service`\n    * 重启服务：`sudo systemctl restart SHMS-Server.service`\n  * 监控端：\n    * 查看服务状态：`sudo systemctl status SHMS-Master.service`\n    * 启动服务：`sudo systemctl start SHMS-Master.service`\n    * 停止服务：`sudo systemctl stop SHMS-Master.service`\n    * 重启服务：`sudo systemctl restart SHMS-Master.service`\n","slug":"服务器健康监控","published":1,"updated":"2020-04-08T03:43:57.430Z","_id":"ck8qr69dj000x5d3amatbapx7","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><a href=\"https://github.com/sunowsir/SHMS\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n</blockquote>\n<ul>\n<li>\n<p>简介：<br>\n使用C语言和bash脚本实现的服务器健康监控系统。服务器端通过执行bash脚本获取健康信息，利用socket即时发送到监控端主机。</p>\n</li>\n<li>\n<p>监测数据类型：</p>\n<blockquote>\n<p>采用bash脚本获取相关信息</p>\n</blockquote>\n<ul>\n<li>cpu</li>\n<li>内存</li>\n<li>硬盘</li>\n<li>恶意进程</li>\n<li>系统信息</li>\n<li>登录用户信息</li>\n</ul>\n</li>\n<li>\n<p>技术说明：</p>\n<ul>\n<li>C语言socket编程。</li>\n<li>C语言多线程与多进程编程。</li>\n<li>数据结构实现（链表）。</li>\n<li>linux的bash脚本编程。</li>\n<li>linux systemd 的使用。</li>\n</ul>\n</li>\n<li>\n<p>架构：</p>\n<ul>\n<li>\n<p>监控端（Master）</p>\n<ul>\n<li>\n<p>线程一：</p>\n<p>循环监听：使用socket监听，将收到的连接的套接字存储到长度最短的链表里。</p>\n</li>\n<li>\n<p>线程二：</p>\n<p>数据接收：通过读取配置文件创建若干数据发送的线程，每个线程分配一个链表。</p>\n<p>从链表读取一个套接字，接收六组数据，然后断开连接，将该套接字从链表中删除。</p>\n<p>保证数据的可靠性：六组数据，每组数据接收前，发送约定好的数据类型标志码，通知服务器本组应该发送的数据的类型。然后接收数据，存储到本地。</p>\n</li>\n<li>\n<p>线程三：</p>\n<p>紧急连接：单独开启通道，接受服务器连接，发送紧急报警信息。</p>\n<p>该数据单独存放在发送者目录下。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>服务器端（Server）:</p>\n<ul>\n<li>\n<p>线程一：</p>\n<p>数据监测：运行监测脚本，将监测数据存储到文件。</p>\n</li>\n<li>\n<p>线程二：</p>\n<p>数据发送：根据监控端发来的数据类型读取相应监测数据的日志文件，发送给监控端。</p>\n<p>通过分析监测数据判断是否有警报信息，发送警报信息。</p>\n<p>数据获取与警报信息的即时性：无法做到数据发送的实时性，但是可以保证监测数据的实时性。每次只发送每种类型数据日志文件中的最上面一行，一共六组数据发送完成关闭连接。该方式牺牲一定的资源与数据传输的实时性，来保证线程一的一定程度的实时性。若非如此，只能采用文件锁来避免文件指针的冲突，这将会导致线程一阻塞，从而导致既服务法达到信息传输的实时性又无法达到监测数据与警报信息的实时性。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>相关文件：</p>\n<ul>\n<li>配置文件：\n<ul>\n<li>监控端：<code>/etc/SHMS-Master/master.conf</code></li>\n<li>服务端；<code>/etc/SHMS-Server/server.conf</code></li>\n</ul>\n</li>\n<li>运行日志文件：\n<ul>\n<li>监控端：<code>/var/log/SHMS-Master/SHMS-Master.log</code></li>\n<li>服务端：<code>/var/log/SHMS-Server/SHMS-Server.log</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>编译安装：</p>\n<ul>\n<li>进入目录：<code>cd ./Server/build/</code>(服务器端)或<code>cd ./Master/build/</code>(监控端)</li>\n<li>清空编译文件：<code>make clean</code></li>\n<li>编译链接生成可执行程序：<code>make</code></li>\n<li>添加到系统服务(使用systemd)：<code>sudo make install</code></li>\n</ul>\n</li>\n<li>\n<p>deb包安装：</p>\n<ul>\n<li>下载deb包：<a href=\"https://github.com/sunowsir/SHMS/releases\" target=\"_blank\" rel=\"noopener\">release页面</a></li>\n<li>安装：<code>sudo dpkg -i xxx.deb</code></li>\n</ul>\n</li>\n<li>\n<p>服务操作：</p>\n<ul>\n<li>服务器端：\n<ul>\n<li>查看服务状态：<code>sudo systemctl status SHMS-Server.service</code></li>\n<li>启动服务：<code>sudo systemctl start SHMS-Server.service</code></li>\n<li>停止服务：<code>sudo systemctl stop SHMS-Server.service</code></li>\n<li>重启服务：<code>sudo systemctl restart SHMS-Server.service</code></li>\n</ul>\n</li>\n<li>监控端：\n<ul>\n<li>查看服务状态：<code>sudo systemctl status SHMS-Master.service</code></li>\n<li>启动服务：<code>sudo systemctl start SHMS-Master.service</code></li>\n<li>停止服务：<code>sudo systemctl stop SHMS-Master.service</code></li>\n<li>重启服务：<code>sudo systemctl restart SHMS-Master.service</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://github.com/sunowsir/SHMS\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n</blockquote>\n<ul>\n<li>\n<p>简介：<br>\n使用C语言和bash脚本实现的服务器健康监控系统。服务器端通过执行bash脚本获取健康信息，利用socket即时发送到监控端主机。</p>\n</li>\n<li>\n<p>监测数据类型：</p>\n<blockquote>\n<p>采用bash脚本获取相关信息</p>\n</blockquote>\n<ul>\n<li>cpu</li>\n<li>内存</li>\n<li>硬盘</li>\n<li>恶意进程</li>\n<li>系统信息</li>\n<li>登录用户信息</li>\n</ul>\n</li>\n<li>\n<p>技术说明：</p>\n<ul>\n<li>C语言socket编程。</li>\n<li>C语言多线程与多进程编程。</li>\n<li>数据结构实现（链表）。</li>\n<li>linux的bash脚本编程。</li>\n<li>linux systemd 的使用。</li>\n</ul>\n</li>\n<li>\n<p>架构：</p>\n<ul>\n<li>\n<p>监控端（Master）</p>\n<ul>\n<li>\n<p>线程一：</p>\n<p>循环监听：使用socket监听，将收到的连接的套接字存储到长度最短的链表里。</p>\n</li>\n<li>\n<p>线程二：</p>\n<p>数据接收：通过读取配置文件创建若干数据发送的线程，每个线程分配一个链表。</p>\n<p>从链表读取一个套接字，接收六组数据，然后断开连接，将该套接字从链表中删除。</p>\n<p>保证数据的可靠性：六组数据，每组数据接收前，发送约定好的数据类型标志码，通知服务器本组应该发送的数据的类型。然后接收数据，存储到本地。</p>\n</li>\n<li>\n<p>线程三：</p>\n<p>紧急连接：单独开启通道，接受服务器连接，发送紧急报警信息。</p>\n<p>该数据单独存放在发送者目录下。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>服务器端（Server）:</p>\n<ul>\n<li>\n<p>线程一：</p>\n<p>数据监测：运行监测脚本，将监测数据存储到文件。</p>\n</li>\n<li>\n<p>线程二：</p>\n<p>数据发送：根据监控端发来的数据类型读取相应监测数据的日志文件，发送给监控端。</p>\n<p>通过分析监测数据判断是否有警报信息，发送警报信息。</p>\n<p>数据获取与警报信息的即时性：无法做到数据发送的实时性，但是可以保证监测数据的实时性。每次只发送每种类型数据日志文件中的最上面一行，一共六组数据发送完成关闭连接。该方式牺牲一定的资源与数据传输的实时性，来保证线程一的一定程度的实时性。若非如此，只能采用文件锁来避免文件指针的冲突，这将会导致线程一阻塞，从而导致既服务法达到信息传输的实时性又无法达到监测数据与警报信息的实时性。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>相关文件：</p>\n<ul>\n<li>配置文件：\n<ul>\n<li>监控端：<code>/etc/SHMS-Master/master.conf</code></li>\n<li>服务端；<code>/etc/SHMS-Server/server.conf</code></li>\n</ul>\n</li>\n<li>运行日志文件：\n<ul>\n<li>监控端：<code>/var/log/SHMS-Master/SHMS-Master.log</code></li>\n<li>服务端：<code>/var/log/SHMS-Server/SHMS-Server.log</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>编译安装：</p>\n<ul>\n<li>进入目录：<code>cd ./Server/build/</code>(服务器端)或<code>cd ./Master/build/</code>(监控端)</li>\n<li>清空编译文件：<code>make clean</code></li>\n<li>编译链接生成可执行程序：<code>make</code></li>\n<li>添加到系统服务(使用systemd)：<code>sudo make install</code></li>\n</ul>\n</li>\n<li>\n<p>deb包安装：</p>\n<ul>\n<li>下载deb包：<a href=\"https://github.com/sunowsir/SHMS/releases\" target=\"_blank\" rel=\"noopener\">release页面</a></li>\n<li>安装：<code>sudo dpkg -i xxx.deb</code></li>\n</ul>\n</li>\n<li>\n<p>服务操作：</p>\n<ul>\n<li>服务器端：\n<ul>\n<li>查看服务状态：<code>sudo systemctl status SHMS-Server.service</code></li>\n<li>启动服务：<code>sudo systemctl start SHMS-Server.service</code></li>\n<li>停止服务：<code>sudo systemctl stop SHMS-Server.service</code></li>\n<li>重启服务：<code>sudo systemctl restart SHMS-Server.service</code></li>\n</ul>\n</li>\n<li>监控端：\n<ul>\n<li>查看服务状态：<code>sudo systemctl status SHMS-Master.service</code></li>\n<li>启动服务：<code>sudo systemctl start SHMS-Master.service</code></li>\n<li>停止服务：<code>sudo systemctl stop SHMS-Master.service</code></li>\n<li>重启服务：<code>sudo systemctl restart SHMS-Master.service</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"方便的轻文本处理语言-markdown","date":"2019-09-02T08:05:09.000Z","cover":"title.jpg","_content":"\n>   如果你并不需要word那么复杂的功能，没有极强的专业性需求，那么markdown是你很好的选择。\n>\n>   不同的markdown编辑器对markdown语法的支持与拓展会有一些出入，但是基础语法基本都会支持。\n>\n>   有的效果默认关闭，需要到设置里打开。\n>\n>   本文代码使用typora编辑器。推荐[typora](https://typora.io/)。\n>\n>   一般的markdown编辑器都是可以导出为各种格式的：pdf、html、word以及png等等。\n>\n>   粘贴下面代码框中的代码到你的markdown编辑器中看看效果！\n>\n>   部分高级用法内容资源来自网络其他博客和wiki。\n\n\n\n## 标题\n\n在文字的开头加上若干`#`最后跟上空格，这段文字就变成了相应等级的标题。\n\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n\n\n## 引用\n\n当我们需要加上一段引用文字或者一些声明的时候可以选择使用引用语法\n\n```markdown\n> 这是引用\n>> 这也是引用\n```\n\n\n\n## 列表\n\n当我们需要列举若干项的时候可以选择使用有序、无序列表和任务列表\n\n```markdown\n* 无序列表1\n* 无序列表2\n\n- 无序列表1\n- 无序列表2\n\n1. 有序列表1\n2. 有序列表2\n\n- [ ] 任务列表，未完成项\n- [x] 任务列表，已完成项\n```\n\n\n\n## 插入代码\n\n当我们需要插入一段代码的时候可以使用代码块语法。\n\n1. 文本中插入一段短的代码可以使用键盘中`1`左边的点把代码括起来\n\n2. 长的规范的代码可以适用代码块，使用键盘中`1`左边的点，输入两行这个点，每行三个，第一行行末输入代码的语言。\n\n3. 示例\n\n   C语言中使用`#include<>`引入头文件\n\n   ```c\n   #include <stdio.h>\n   int main () {\n   \treturn 0;\n   }\n   ```\n\n\n\n## 数学公式\n\n当我们需要插入数学公式，并且想要漂亮一些，可以使用数学公式的语法，更多的markdown数学转义符号请自行搜索，很容易搜到的。\n\n```markdown\n在数学中$\\sum$ 是求和符号。\n例如：\n$$\n$\\sum^{k}_{i = 1}{x / i}$\n$$\n```\n\n\n\n## 文字显示控制\n\n我们可能有时候需要对文本加粗、高亮等，这里markdown也提供了支持。\n\n每种效果可以叠加使用。\n\n```markdown\n*斜体*\n**加粗**\n==高亮==\n~~删除~~\n***斜体并加粗***\n==*斜体并高亮*==\n```\n\n\n\n## 表格\n\n当然了， 常用的表格markdown也是支持的。\n\n通过冒号可以控制对齐方式\n\n```markdown\n|first head|second head|third head|\n|:--|:--:|--:|\n|左对齐列|中心对齐列|右侧对齐列|\n|asd|fgh|jkl|\n```\n\n\n\n## 脚注\n\nmarkdown也是支持脚注的。\n\n```markdown\n可以这样使用脚注[^1]\n[^1]:脚注1的内容\n```\n## 分割线\n\n当我们想要分割两段内容的时候可以用分割线\n\n```markdown\n上面的内容\n---\n下面的内容\n```\n\n\n\n## 引入图像与链接\n\n引入图像和链接是必不可少的功能。\n\n```markdown\n![Linux引入图片](/home/UserName/1.jpg)\n![windows引入图片](C:\\Users\\UserName\\Downloads\\2.png)\n[百度](https://www.baidu.com)\n[参考链接]: www.baidu.com\n<www.baidu.com>\n[页内链接](#一级标题)\n```\n\n\n\n## 目录树\n\n当文本过长，需要加上目录树。\n\n```markdown\n文本1\n\n[TOC]\n\n文本2\n```\n\n\n\n## emoji表情\n\n有些markdown编辑器是支持emoji表情插入的。\n\n```markdown\n:smile:\n```\n\n\n\n## 文本折叠\n\n当我们的某个段落太长需要折叠起来，markdown貌似没有原生语法支持折叠，\n\n但是有些markdown编辑器是支持HTML语法的，这里可以使用HTML实现。\n\n```html\n<details>\n    <summary>测试标题</summary>\n测试文本\n</details>\n```\n\n## 注释\n\nmarkdown当然也有像C语言中`//`一样的注释\n\n```markdown\n<!--这是注释-->\n```\n\n\n\n## 流程图\n\nmarkdown当然也可以画流程图\n\n按照上面插入代码的方式，按照下面的例子编写代码插入到代码块中，语言是mermaid\n\n```markdown\nflowchat\nflow\nst=>start: Start\nop=>operation: Your Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n\n\n## 时序图\n\n既然支持流程图，当然也支持时序图，语言也是mermaid。\n\n```markdown\nsequenceDiagram\nX->>Y: 一起去电影院怎么样？\nNote right of Y: 去不去\nY->>X: 好的，我等你！\n```\n\n\n\n## 甘特图\n\n语言也是mermaid。\n\n```markdown\ngantt\ndateFormat  YYYY-MM-DD\ntitle 软件开发甘特图\n    \nsection 设计\n\t需求                      :done,    des1, 2014-01-06,2014-01-08\n\t原型                      :active,  des2, 2014-01-09, 3d\n\tUI设计                    :         des3, after des2, 5d\n\t未来任务                   :         des4, after des3, 5d\n\nsection 开发\n    学习准备理解需求                      :crit, done, 2014-01-06,24h\n    设计框架                             :crit, done, after des2, 2d\n    开发                                 :crit, active, 3d\n    未来任务                              :crit, 5d\n    耍                                   :2d\n\nsection 测试\n    功能测试                              :active, a1, after des3, 3d\n    压力测试                               :after a1  , 20h\n    测试报告                               : 48h\n```\n\n[来自百度经验](https://jingyan.baidu.com/article/48b558e3035d9a7f38c09aeb.html)\n\n","source":"_posts/方便的轻文本处理语言-markdown.md","raw":"---\ntitle: 方便的轻文本处理语言-markdown\ndate: 2019-09-02 16:05:09\ncover: title.jpg\ntags: tools\n---\n\n>   如果你并不需要word那么复杂的功能，没有极强的专业性需求，那么markdown是你很好的选择。\n>\n>   不同的markdown编辑器对markdown语法的支持与拓展会有一些出入，但是基础语法基本都会支持。\n>\n>   有的效果默认关闭，需要到设置里打开。\n>\n>   本文代码使用typora编辑器。推荐[typora](https://typora.io/)。\n>\n>   一般的markdown编辑器都是可以导出为各种格式的：pdf、html、word以及png等等。\n>\n>   粘贴下面代码框中的代码到你的markdown编辑器中看看效果！\n>\n>   部分高级用法内容资源来自网络其他博客和wiki。\n\n\n\n## 标题\n\n在文字的开头加上若干`#`最后跟上空格，这段文字就变成了相应等级的标题。\n\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n\n\n## 引用\n\n当我们需要加上一段引用文字或者一些声明的时候可以选择使用引用语法\n\n```markdown\n> 这是引用\n>> 这也是引用\n```\n\n\n\n## 列表\n\n当我们需要列举若干项的时候可以选择使用有序、无序列表和任务列表\n\n```markdown\n* 无序列表1\n* 无序列表2\n\n- 无序列表1\n- 无序列表2\n\n1. 有序列表1\n2. 有序列表2\n\n- [ ] 任务列表，未完成项\n- [x] 任务列表，已完成项\n```\n\n\n\n## 插入代码\n\n当我们需要插入一段代码的时候可以使用代码块语法。\n\n1. 文本中插入一段短的代码可以使用键盘中`1`左边的点把代码括起来\n\n2. 长的规范的代码可以适用代码块，使用键盘中`1`左边的点，输入两行这个点，每行三个，第一行行末输入代码的语言。\n\n3. 示例\n\n   C语言中使用`#include<>`引入头文件\n\n   ```c\n   #include <stdio.h>\n   int main () {\n   \treturn 0;\n   }\n   ```\n\n\n\n## 数学公式\n\n当我们需要插入数学公式，并且想要漂亮一些，可以使用数学公式的语法，更多的markdown数学转义符号请自行搜索，很容易搜到的。\n\n```markdown\n在数学中$\\sum$ 是求和符号。\n例如：\n$$\n$\\sum^{k}_{i = 1}{x / i}$\n$$\n```\n\n\n\n## 文字显示控制\n\n我们可能有时候需要对文本加粗、高亮等，这里markdown也提供了支持。\n\n每种效果可以叠加使用。\n\n```markdown\n*斜体*\n**加粗**\n==高亮==\n~~删除~~\n***斜体并加粗***\n==*斜体并高亮*==\n```\n\n\n\n## 表格\n\n当然了， 常用的表格markdown也是支持的。\n\n通过冒号可以控制对齐方式\n\n```markdown\n|first head|second head|third head|\n|:--|:--:|--:|\n|左对齐列|中心对齐列|右侧对齐列|\n|asd|fgh|jkl|\n```\n\n\n\n## 脚注\n\nmarkdown也是支持脚注的。\n\n```markdown\n可以这样使用脚注[^1]\n[^1]:脚注1的内容\n```\n## 分割线\n\n当我们想要分割两段内容的时候可以用分割线\n\n```markdown\n上面的内容\n---\n下面的内容\n```\n\n\n\n## 引入图像与链接\n\n引入图像和链接是必不可少的功能。\n\n```markdown\n![Linux引入图片](/home/UserName/1.jpg)\n![windows引入图片](C:\\Users\\UserName\\Downloads\\2.png)\n[百度](https://www.baidu.com)\n[参考链接]: www.baidu.com\n<www.baidu.com>\n[页内链接](#一级标题)\n```\n\n\n\n## 目录树\n\n当文本过长，需要加上目录树。\n\n```markdown\n文本1\n\n[TOC]\n\n文本2\n```\n\n\n\n## emoji表情\n\n有些markdown编辑器是支持emoji表情插入的。\n\n```markdown\n:smile:\n```\n\n\n\n## 文本折叠\n\n当我们的某个段落太长需要折叠起来，markdown貌似没有原生语法支持折叠，\n\n但是有些markdown编辑器是支持HTML语法的，这里可以使用HTML实现。\n\n```html\n<details>\n    <summary>测试标题</summary>\n测试文本\n</details>\n```\n\n## 注释\n\nmarkdown当然也有像C语言中`//`一样的注释\n\n```markdown\n<!--这是注释-->\n```\n\n\n\n## 流程图\n\nmarkdown当然也可以画流程图\n\n按照上面插入代码的方式，按照下面的例子编写代码插入到代码块中，语言是mermaid\n\n```markdown\nflowchat\nflow\nst=>start: Start\nop=>operation: Your Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n\n\n## 时序图\n\n既然支持流程图，当然也支持时序图，语言也是mermaid。\n\n```markdown\nsequenceDiagram\nX->>Y: 一起去电影院怎么样？\nNote right of Y: 去不去\nY->>X: 好的，我等你！\n```\n\n\n\n## 甘特图\n\n语言也是mermaid。\n\n```markdown\ngantt\ndateFormat  YYYY-MM-DD\ntitle 软件开发甘特图\n    \nsection 设计\n\t需求                      :done,    des1, 2014-01-06,2014-01-08\n\t原型                      :active,  des2, 2014-01-09, 3d\n\tUI设计                    :         des3, after des2, 5d\n\t未来任务                   :         des4, after des3, 5d\n\nsection 开发\n    学习准备理解需求                      :crit, done, 2014-01-06,24h\n    设计框架                             :crit, done, after des2, 2d\n    开发                                 :crit, active, 3d\n    未来任务                              :crit, 5d\n    耍                                   :2d\n\nsection 测试\n    功能测试                              :active, a1, after des3, 3d\n    压力测试                               :after a1  , 20h\n    测试报告                               : 48h\n```\n\n[来自百度经验](https://jingyan.baidu.com/article/48b558e3035d9a7f38c09aeb.html)\n\n","slug":"方便的轻文本处理语言-markdown","published":1,"updated":"2020-04-08T03:43:05.223Z","_id":"ck8qr69dk000z5d3a0ndwtz9t","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>如果你并不需要word那么复杂的功能，没有极强的专业性需求，那么markdown是你很好的选择。</p>\n<p>不同的markdown编辑器对markdown语法的支持与拓展会有一些出入，但是基础语法基本都会支持。</p>\n<p>有的效果默认关闭，需要到设置里打开。</p>\n<p>本文代码使用typora编辑器。推荐<a href=\"https://typora.io/\" target=\"_blank\" rel=\"noopener\">typora</a>。</p>\n<p>一般的markdown编辑器都是可以导出为各种格式的：pdf、html、word以及png等等。</p>\n<p>粘贴下面代码框中的代码到你的markdown编辑器中看看效果！</p>\n<p>部分高级用法内容资源来自网络其他博客和wiki。</p>\n</blockquote>\n<h2 id=\"标题\"><a class=\"markdownIt-Anchor\" href=\"#标题\"></a> 标题</h2>\n<p>在文字的开头加上若干<code>#</code>最后跟上空格，这段文字就变成了相应等级的标题。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 一级标题</span></span><br><span class=\"line\"><span class=\"section\">## 二级标题</span></span><br><span class=\"line\"><span class=\"section\">### 三级标题</span></span><br><span class=\"line\"><span class=\"section\">#### 四级标题</span></span><br><span class=\"line\"><span class=\"section\">##### 五级标题</span></span><br><span class=\"line\"><span class=\"section\">###### 六级标题</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"引用\"><a class=\"markdownIt-Anchor\" href=\"#引用\"></a> 引用</h2>\n<p>当我们需要加上一段引用文字或者一些声明的时候可以选择使用引用语法</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"quote\">&gt; 这是引用</span></span><br><span class=\"line\">&gt;&gt; 这也是引用</span><br></pre></td></tr></table></figure>\n<h2 id=\"列表\"><a class=\"markdownIt-Anchor\" href=\"#列表\"></a> 列表</h2>\n<p>当我们需要列举若干项的时候可以选择使用有序、无序列表和任务列表</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">* </span>无序列表1</span><br><span class=\"line\"><span class=\"bullet\">* </span>无序列表2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>无序列表1</span><br><span class=\"line\"><span class=\"bullet\">- </span>无序列表2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">1. </span>有序列表1</span><br><span class=\"line\"><span class=\"bullet\">2. </span>有序列表2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>[ ] 任务列表，未完成项</span><br><span class=\"line\"><span class=\"bullet\">- </span>[x] 任务列表，已完成项</span><br></pre></td></tr></table></figure>\n<h2 id=\"插入代码\"><a class=\"markdownIt-Anchor\" href=\"#插入代码\"></a> 插入代码</h2>\n<p>当我们需要插入一段代码的时候可以使用代码块语法。</p>\n<ol>\n<li>\n<p>文本中插入一段短的代码可以使用键盘中<code>1</code>左边的点把代码括起来</p>\n</li>\n<li>\n<p>长的规范的代码可以适用代码块，使用键盘中<code>1</code>左边的点，输入两行这个点，每行三个，第一行行末输入代码的语言。</p>\n</li>\n<li>\n<p>示例</p>\n<p>C语言中使用<code>#include&lt;&gt;</code>引入头文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"数学公式\"><a class=\"markdownIt-Anchor\" href=\"#数学公式\"></a> 数学公式</h2>\n<p>当我们需要插入数学公式，并且想要漂亮一些，可以使用数学公式的语法，更多的markdown数学转义符号请自行搜索，很容易搜到的。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在数学中$\\sum$ 是求和符号。</span><br><span class=\"line\">例如：</span><br><span class=\"line\">$$</span><br><span class=\"line\">$\\sum^&#123;k&#125;_&#123;i = 1&#125;&#123;x / i&#125;$</span><br><span class=\"line\">$$</span><br></pre></td></tr></table></figure>\n<h2 id=\"文字显示控制\"><a class=\"markdownIt-Anchor\" href=\"#文字显示控制\"></a> 文字显示控制</h2>\n<p>我们可能有时候需要对文本加粗、高亮等，这里markdown也提供了支持。</p>\n<p>每种效果可以叠加使用。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"emphasis\">*斜体*</span></span><br><span class=\"line\"><span class=\"strong\">**加粗**</span></span><br><span class=\"line\">==高亮==</span><br><span class=\"line\">~~删除~~</span><br><span class=\"line\"><span class=\"strong\">***斜体并加粗**</span>*</span><br><span class=\"line\">==<span class=\"emphasis\">*斜体并高亮*</span>==</span><br></pre></td></tr></table></figure>\n<h2 id=\"表格\"><a class=\"markdownIt-Anchor\" href=\"#表格\"></a> 表格</h2>\n<p>当然了， 常用的表格markdown也是支持的。</p>\n<p>通过冒号可以控制对齐方式</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|first head|second head|third head|</span><br><span class=\"line\">|:--|:--:|--:|</span><br><span class=\"line\">|左对齐列|中心对齐列|右侧对齐列|</span><br><span class=\"line\">|asd|fgh|jkl|</span><br></pre></td></tr></table></figure>\n<h2 id=\"脚注\"><a class=\"markdownIt-Anchor\" href=\"#脚注\"></a> 脚注</h2>\n<p>markdown也是支持脚注的。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可以这样使用脚注[^1]</span><br><span class=\"line\">[<span class=\"symbol\">^1</span>]:<span class=\"link\">脚注1的内容</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"分割线\"><a class=\"markdownIt-Anchor\" href=\"#分割线\"></a> 分割线</h2>\n<p>当我们想要分割两段内容的时候可以用分割线</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上面的内容</span><br><span class=\"line\">---</span><br><span class=\"line\">下面的内容</span><br></pre></td></tr></table></figure>\n<h2 id=\"引入图像与链接\"><a class=\"markdownIt-Anchor\" href=\"#引入图像与链接\"></a> 引入图像与链接</h2>\n<p>引入图像和链接是必不可少的功能。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![<span class=\"string\">Linux引入图片</span>](<span class=\"link\">/home/UserName/1.jpg</span>)</span><br><span class=\"line\">![<span class=\"string\">windows引入图片</span>](<span class=\"link\">C:\\Users\\UserName\\Downloads\\2.png</span>)</span><br><span class=\"line\">[<span class=\"string\">百度</span>](<span class=\"link\">https://www.baidu.com</span>)</span><br><span class=\"line\">[<span class=\"symbol\">参考链接</span>]: <span class=\"link\">www.baidu.com</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">www.baidu.com</span>&gt;</span></span></span><br><span class=\"line\">[<span class=\"string\">页内链接</span>](<span class=\"link\">#一级标题</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"目录树\"><a class=\"markdownIt-Anchor\" href=\"#目录树\"></a> 目录树</h2>\n<p>当文本过长，需要加上目录树。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文本1</span><br><span class=\"line\"></span><br><span class=\"line\">[TOC]</span><br><span class=\"line\"></span><br><span class=\"line\">文本2</span><br></pre></td></tr></table></figure>\n<h2 id=\"emoji表情\"><a class=\"markdownIt-Anchor\" href=\"#emoji表情\"></a> emoji表情</h2>\n<p>有些markdown编辑器是支持emoji表情插入的。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:smile:</span><br></pre></td></tr></table></figure>\n<h2 id=\"文本折叠\"><a class=\"markdownIt-Anchor\" href=\"#文本折叠\"></a> 文本折叠</h2>\n<p>当我们的某个段落太长需要折叠起来，markdown貌似没有原生语法支持折叠，</p>\n<p>但是有些markdown编辑器是支持HTML语法的，这里可以使用HTML实现。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">details</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">summary</span>&gt;</span>测试标题<span class=\"tag\">&lt;/<span class=\"name\">summary</span>&gt;</span></span><br><span class=\"line\">测试文本</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">details</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"注释\"><a class=\"markdownIt-Anchor\" href=\"#注释\"></a> 注释</h2>\n<p>markdown当然也有像C语言中<code>//</code>一样的注释</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"comment\">&lt;!--这是注释--&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"流程图\"><a class=\"markdownIt-Anchor\" href=\"#流程图\"></a> 流程图</h2>\n<p>markdown当然也可以画流程图</p>\n<p>按照上面插入代码的方式，按照下面的例子编写代码插入到代码块中，语言是mermaid</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flowchat</span><br><span class=\"line\">flow</span><br><span class=\"line\">st=&gt;start: Start</span><br><span class=\"line\">op=&gt;operation: Your Operation</span><br><span class=\"line\">cond=&gt;condition: Yes or No?</span><br><span class=\"line\">e=&gt;end</span><br><span class=\"line\">st-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br><span class=\"line\">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>\n<h2 id=\"时序图\"><a class=\"markdownIt-Anchor\" href=\"#时序图\"></a> 时序图</h2>\n<p>既然支持流程图，当然也支持时序图，语言也是mermaid。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">X-&gt;&gt;Y: 一起去电影院怎么样？</span><br><span class=\"line\">Note right of Y: 去不去</span><br><span class=\"line\">Y-&gt;&gt;X: 好的，我等你！</span><br></pre></td></tr></table></figure>\n<h2 id=\"甘特图\"><a class=\"markdownIt-Anchor\" href=\"#甘特图\"></a> 甘特图</h2>\n<p>语言也是mermaid。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gantt</span><br><span class=\"line\">dateFormat  YYYY-MM-DD</span><br><span class=\"line\">title 软件开发甘特图</span><br><span class=\"line\"><span class=\"code\">    </span></span><br><span class=\"line\">section 设计</span><br><span class=\"line\"><span class=\"code\">\t需求                      :done,    des1, 2014-01-06,2014-01-08</span></span><br><span class=\"line\"><span class=\"code\">\t原型                      :active,  des2, 2014-01-09, 3d</span></span><br><span class=\"line\"><span class=\"code\">\tUI设计                    :         des3, after des2, 5d</span></span><br><span class=\"line\"><span class=\"code\">\t未来任务                   :         des4, after des3, 5d</span></span><br><span class=\"line\"></span><br><span class=\"line\">section 开发</span><br><span class=\"line\"><span class=\"code\">    学习准备理解需求                      :crit, done, 2014-01-06,24h</span></span><br><span class=\"line\"><span class=\"code\">    设计框架                             :crit, done, after des2, 2d</span></span><br><span class=\"line\"><span class=\"code\">    开发                                 :crit, active, 3d</span></span><br><span class=\"line\"><span class=\"code\">    未来任务                              :crit, 5d</span></span><br><span class=\"line\"><span class=\"code\">    耍                                   :2d</span></span><br><span class=\"line\"></span><br><span class=\"line\">section 测试</span><br><span class=\"line\"><span class=\"code\">    功能测试                              :active, a1, after des3, 3d</span></span><br><span class=\"line\"><span class=\"code\">    压力测试                               :after a1  , 20h</span></span><br><span class=\"line\"><span class=\"code\">    测试报告                               : 48h</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://jingyan.baidu.com/article/48b558e3035d9a7f38c09aeb.html\" target=\"_blank\" rel=\"noopener\">来自百度经验</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>如果你并不需要word那么复杂的功能，没有极强的专业性需求，那么markdown是你很好的选择。</p>\n<p>不同的markdown编辑器对markdown语法的支持与拓展会有一些出入，但是基础语法基本都会支持。</p>\n<p>有的效果默认关闭，需要到设置里打开。</p>\n<p>本文代码使用typora编辑器。推荐<a href=\"https://typora.io/\" target=\"_blank\" rel=\"noopener\">typora</a>。</p>\n<p>一般的markdown编辑器都是可以导出为各种格式的：pdf、html、word以及png等等。</p>\n<p>粘贴下面代码框中的代码到你的markdown编辑器中看看效果！</p>\n<p>部分高级用法内容资源来自网络其他博客和wiki。</p>\n</blockquote>\n<h2 id=\"标题\"><a class=\"markdownIt-Anchor\" href=\"#标题\"></a> 标题</h2>\n<p>在文字的开头加上若干<code>#</code>最后跟上空格，这段文字就变成了相应等级的标题。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 一级标题</span></span><br><span class=\"line\"><span class=\"section\">## 二级标题</span></span><br><span class=\"line\"><span class=\"section\">### 三级标题</span></span><br><span class=\"line\"><span class=\"section\">#### 四级标题</span></span><br><span class=\"line\"><span class=\"section\">##### 五级标题</span></span><br><span class=\"line\"><span class=\"section\">###### 六级标题</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"引用\"><a class=\"markdownIt-Anchor\" href=\"#引用\"></a> 引用</h2>\n<p>当我们需要加上一段引用文字或者一些声明的时候可以选择使用引用语法</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"quote\">&gt; 这是引用</span></span><br><span class=\"line\">&gt;&gt; 这也是引用</span><br></pre></td></tr></table></figure>\n<h2 id=\"列表\"><a class=\"markdownIt-Anchor\" href=\"#列表\"></a> 列表</h2>\n<p>当我们需要列举若干项的时候可以选择使用有序、无序列表和任务列表</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">* </span>无序列表1</span><br><span class=\"line\"><span class=\"bullet\">* </span>无序列表2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>无序列表1</span><br><span class=\"line\"><span class=\"bullet\">- </span>无序列表2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">1. </span>有序列表1</span><br><span class=\"line\"><span class=\"bullet\">2. </span>有序列表2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>[ ] 任务列表，未完成项</span><br><span class=\"line\"><span class=\"bullet\">- </span>[x] 任务列表，已完成项</span><br></pre></td></tr></table></figure>\n<h2 id=\"插入代码\"><a class=\"markdownIt-Anchor\" href=\"#插入代码\"></a> 插入代码</h2>\n<p>当我们需要插入一段代码的时候可以使用代码块语法。</p>\n<ol>\n<li>\n<p>文本中插入一段短的代码可以使用键盘中<code>1</code>左边的点把代码括起来</p>\n</li>\n<li>\n<p>长的规范的代码可以适用代码块，使用键盘中<code>1</code>左边的点，输入两行这个点，每行三个，第一行行末输入代码的语言。</p>\n</li>\n<li>\n<p>示例</p>\n<p>C语言中使用<code>#include&lt;&gt;</code>引入头文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"数学公式\"><a class=\"markdownIt-Anchor\" href=\"#数学公式\"></a> 数学公式</h2>\n<p>当我们需要插入数学公式，并且想要漂亮一些，可以使用数学公式的语法，更多的markdown数学转义符号请自行搜索，很容易搜到的。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在数学中$\\sum$ 是求和符号。</span><br><span class=\"line\">例如：</span><br><span class=\"line\">$$</span><br><span class=\"line\">$\\sum^&#123;k&#125;_&#123;i = 1&#125;&#123;x / i&#125;$</span><br><span class=\"line\">$$</span><br></pre></td></tr></table></figure>\n<h2 id=\"文字显示控制\"><a class=\"markdownIt-Anchor\" href=\"#文字显示控制\"></a> 文字显示控制</h2>\n<p>我们可能有时候需要对文本加粗、高亮等，这里markdown也提供了支持。</p>\n<p>每种效果可以叠加使用。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"emphasis\">*斜体*</span></span><br><span class=\"line\"><span class=\"strong\">**加粗**</span></span><br><span class=\"line\">==高亮==</span><br><span class=\"line\">~~删除~~</span><br><span class=\"line\"><span class=\"strong\">***斜体并加粗**</span>*</span><br><span class=\"line\">==<span class=\"emphasis\">*斜体并高亮*</span>==</span><br></pre></td></tr></table></figure>\n<h2 id=\"表格\"><a class=\"markdownIt-Anchor\" href=\"#表格\"></a> 表格</h2>\n<p>当然了， 常用的表格markdown也是支持的。</p>\n<p>通过冒号可以控制对齐方式</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|first head|second head|third head|</span><br><span class=\"line\">|:--|:--:|--:|</span><br><span class=\"line\">|左对齐列|中心对齐列|右侧对齐列|</span><br><span class=\"line\">|asd|fgh|jkl|</span><br></pre></td></tr></table></figure>\n<h2 id=\"脚注\"><a class=\"markdownIt-Anchor\" href=\"#脚注\"></a> 脚注</h2>\n<p>markdown也是支持脚注的。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可以这样使用脚注[^1]</span><br><span class=\"line\">[<span class=\"symbol\">^1</span>]:<span class=\"link\">脚注1的内容</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"分割线\"><a class=\"markdownIt-Anchor\" href=\"#分割线\"></a> 分割线</h2>\n<p>当我们想要分割两段内容的时候可以用分割线</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上面的内容</span><br><span class=\"line\">---</span><br><span class=\"line\">下面的内容</span><br></pre></td></tr></table></figure>\n<h2 id=\"引入图像与链接\"><a class=\"markdownIt-Anchor\" href=\"#引入图像与链接\"></a> 引入图像与链接</h2>\n<p>引入图像和链接是必不可少的功能。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![<span class=\"string\">Linux引入图片</span>](<span class=\"link\">/home/UserName/1.jpg</span>)</span><br><span class=\"line\">![<span class=\"string\">windows引入图片</span>](<span class=\"link\">C:\\Users\\UserName\\Downloads\\2.png</span>)</span><br><span class=\"line\">[<span class=\"string\">百度</span>](<span class=\"link\">https://www.baidu.com</span>)</span><br><span class=\"line\">[<span class=\"symbol\">参考链接</span>]: <span class=\"link\">www.baidu.com</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">www.baidu.com</span>&gt;</span></span></span><br><span class=\"line\">[<span class=\"string\">页内链接</span>](<span class=\"link\">#一级标题</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"目录树\"><a class=\"markdownIt-Anchor\" href=\"#目录树\"></a> 目录树</h2>\n<p>当文本过长，需要加上目录树。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文本1</span><br><span class=\"line\"></span><br><span class=\"line\">[TOC]</span><br><span class=\"line\"></span><br><span class=\"line\">文本2</span><br></pre></td></tr></table></figure>\n<h2 id=\"emoji表情\"><a class=\"markdownIt-Anchor\" href=\"#emoji表情\"></a> emoji表情</h2>\n<p>有些markdown编辑器是支持emoji表情插入的。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:smile:</span><br></pre></td></tr></table></figure>\n<h2 id=\"文本折叠\"><a class=\"markdownIt-Anchor\" href=\"#文本折叠\"></a> 文本折叠</h2>\n<p>当我们的某个段落太长需要折叠起来，markdown貌似没有原生语法支持折叠，</p>\n<p>但是有些markdown编辑器是支持HTML语法的，这里可以使用HTML实现。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">details</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">summary</span>&gt;</span>测试标题<span class=\"tag\">&lt;/<span class=\"name\">summary</span>&gt;</span></span><br><span class=\"line\">测试文本</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">details</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"注释\"><a class=\"markdownIt-Anchor\" href=\"#注释\"></a> 注释</h2>\n<p>markdown当然也有像C语言中<code>//</code>一样的注释</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"comment\">&lt;!--这是注释--&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"流程图\"><a class=\"markdownIt-Anchor\" href=\"#流程图\"></a> 流程图</h2>\n<p>markdown当然也可以画流程图</p>\n<p>按照上面插入代码的方式，按照下面的例子编写代码插入到代码块中，语言是mermaid</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flowchat</span><br><span class=\"line\">flow</span><br><span class=\"line\">st=&gt;start: Start</span><br><span class=\"line\">op=&gt;operation: Your Operation</span><br><span class=\"line\">cond=&gt;condition: Yes or No?</span><br><span class=\"line\">e=&gt;end</span><br><span class=\"line\">st-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br><span class=\"line\">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>\n<h2 id=\"时序图\"><a class=\"markdownIt-Anchor\" href=\"#时序图\"></a> 时序图</h2>\n<p>既然支持流程图，当然也支持时序图，语言也是mermaid。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">X-&gt;&gt;Y: 一起去电影院怎么样？</span><br><span class=\"line\">Note right of Y: 去不去</span><br><span class=\"line\">Y-&gt;&gt;X: 好的，我等你！</span><br></pre></td></tr></table></figure>\n<h2 id=\"甘特图\"><a class=\"markdownIt-Anchor\" href=\"#甘特图\"></a> 甘特图</h2>\n<p>语言也是mermaid。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gantt</span><br><span class=\"line\">dateFormat  YYYY-MM-DD</span><br><span class=\"line\">title 软件开发甘特图</span><br><span class=\"line\"><span class=\"code\">    </span></span><br><span class=\"line\">section 设计</span><br><span class=\"line\"><span class=\"code\">\t需求                      :done,    des1, 2014-01-06,2014-01-08</span></span><br><span class=\"line\"><span class=\"code\">\t原型                      :active,  des2, 2014-01-09, 3d</span></span><br><span class=\"line\"><span class=\"code\">\tUI设计                    :         des3, after des2, 5d</span></span><br><span class=\"line\"><span class=\"code\">\t未来任务                   :         des4, after des3, 5d</span></span><br><span class=\"line\"></span><br><span class=\"line\">section 开发</span><br><span class=\"line\"><span class=\"code\">    学习准备理解需求                      :crit, done, 2014-01-06,24h</span></span><br><span class=\"line\"><span class=\"code\">    设计框架                             :crit, done, after des2, 2d</span></span><br><span class=\"line\"><span class=\"code\">    开发                                 :crit, active, 3d</span></span><br><span class=\"line\"><span class=\"code\">    未来任务                              :crit, 5d</span></span><br><span class=\"line\"><span class=\"code\">    耍                                   :2d</span></span><br><span class=\"line\"></span><br><span class=\"line\">section 测试</span><br><span class=\"line\"><span class=\"code\">    功能测试                              :active, a1, after des3, 3d</span></span><br><span class=\"line\"><span class=\"code\">    压力测试                               :after a1  , 20h</span></span><br><span class=\"line\"><span class=\"code\">    测试报告                               : 48h</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://jingyan.baidu.com/article/48b558e3035d9a7f38c09aeb.html\" target=\"_blank\" rel=\"noopener\">来自百度经验</a></p>\n"},{"title":"磁盘信息获取","date":"2019-09-02T08:44:48.000Z","cover":"title.jpg","_content":"\n\n\n* 知识准备：\n\n  1. `df`:该工具用来获取文件系统挂载信息。\n\n  2. `awk`：该工具用来处理 `df`的数据。\n\n* 代码：\n\n     ```bash\n     #!/bin/bash\n     \n     df -m | grep \"^/dev/\" | awk -v ntime=$(date +\"%Y-%m-%d__%H:%M:%S\") '\n     BEGIN{\n         num = 0; \n         unum = 0; \n         hnum = 0;\n     } \n     {\n         num += $2; \n         unum += $3; \n         hnum += $4;\n         printf(\"%s 1 %s %sM %sM %s\\n\", ntime, $6, $2, $4, $5);\n     } \n     END{\n         printf(\"%s 0 disk %dM %dM %.2f%%\\n\", ntime, num, hnum, unum / num * 100);\n     }'\n     \n     ```\n\n     \n","source":"_posts/磁盘信息获取.md","raw":"---\ntitle: 磁盘信息获取\ndate: 2019-09-02 16:44:48\ncover: title.jpg\ntags:\n- script\n- linux\n---\n\n\n\n* 知识准备：\n\n  1. `df`:该工具用来获取文件系统挂载信息。\n\n  2. `awk`：该工具用来处理 `df`的数据。\n\n* 代码：\n\n     ```bash\n     #!/bin/bash\n     \n     df -m | grep \"^/dev/\" | awk -v ntime=$(date +\"%Y-%m-%d__%H:%M:%S\") '\n     BEGIN{\n         num = 0; \n         unum = 0; \n         hnum = 0;\n     } \n     {\n         num += $2; \n         unum += $3; \n         hnum += $4;\n         printf(\"%s 1 %s %sM %sM %s\\n\", ntime, $6, $2, $4, $5);\n     } \n     END{\n         printf(\"%s 0 disk %dM %dM %.2f%%\\n\", ntime, num, hnum, unum / num * 100);\n     }'\n     \n     ```\n\n     \n","slug":"磁盘信息获取","published":1,"updated":"2020-04-08T03:45:25.445Z","_id":"ck8qr69dl00125d3avzprafvf","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>\n<p>知识准备：</p>\n<ol>\n<li>\n<p><code>df</code>:该工具用来获取文件系统挂载信息。</p>\n</li>\n<li>\n<p><code>awk</code>：该工具用来处理 <code>df</code>的数据。</p>\n</li>\n</ol>\n</li>\n<li>\n<p>代码：</p>\n   <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">df -m | grep <span class=\"string\">\"^/dev/\"</span> | awk -v ntime=$(date +<span class=\"string\">\"%Y-%m-%d__%H:%M:%S\"</span>) <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">BEGIN&#123;</span></span><br><span class=\"line\"><span class=\"string\">    num = 0; </span></span><br><span class=\"line\"><span class=\"string\">    unum = 0; </span></span><br><span class=\"line\"><span class=\"string\">    hnum = 0;</span></span><br><span class=\"line\"><span class=\"string\">&#125; </span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">    num += $2; </span></span><br><span class=\"line\"><span class=\"string\">    unum += $3; </span></span><br><span class=\"line\"><span class=\"string\">    hnum += $4;</span></span><br><span class=\"line\"><span class=\"string\">    printf(\"%s 1 %s %sM %sM %s\\n\", ntime, $6, $2, $4, $5);</span></span><br><span class=\"line\"><span class=\"string\">&#125; </span></span><br><span class=\"line\"><span class=\"string\">END&#123;</span></span><br><span class=\"line\"><span class=\"string\">    printf(\"%s 0 disk %dM %dM %.2f%%\\n\", ntime, num, hnum, unum / num * 100);</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>\n<p>知识准备：</p>\n<ol>\n<li>\n<p><code>df</code>:该工具用来获取文件系统挂载信息。</p>\n</li>\n<li>\n<p><code>awk</code>：该工具用来处理 <code>df</code>的数据。</p>\n</li>\n</ol>\n</li>\n<li>\n<p>代码：</p>\n   <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">df -m | grep <span class=\"string\">\"^/dev/\"</span> | awk -v ntime=$(date +<span class=\"string\">\"%Y-%m-%d__%H:%M:%S\"</span>) <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">BEGIN&#123;</span></span><br><span class=\"line\"><span class=\"string\">    num = 0; </span></span><br><span class=\"line\"><span class=\"string\">    unum = 0; </span></span><br><span class=\"line\"><span class=\"string\">    hnum = 0;</span></span><br><span class=\"line\"><span class=\"string\">&#125; </span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">    num += $2; </span></span><br><span class=\"line\"><span class=\"string\">    unum += $3; </span></span><br><span class=\"line\"><span class=\"string\">    hnum += $4;</span></span><br><span class=\"line\"><span class=\"string\">    printf(\"%s 1 %s %sM %sM %s\\n\", ntime, $6, $2, $4, $5);</span></span><br><span class=\"line\"><span class=\"string\">&#125; </span></span><br><span class=\"line\"><span class=\"string\">END&#123;</span></span><br><span class=\"line\"><span class=\"string\">    printf(\"%s 0 disk %dM %dM %.2f%%\\n\", ntime, num, hnum, unum / num * 100);</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"进程信息获取","date":"2019-09-02T08:44:03.000Z","cover":"title.jpg","_content":"\n\n\n* 知识准备：\n\n  1. `ps` 该工具用来获取进程信息\n  2. `awk`该工具用来处理数据\n\n* 代码\n\n  ```bash\n  #!/bin/bash\n  \n  ps -aux | awk -v last_all=$(ps -aux | awk '\n  BEGIN{\n      num = 0;\n  } \n  { \n      if ($3 > 50 || $4 > 50) { \n          if (num > 0) {\n              printf(\"|\");\n          } \n          printf(\"%s\", $2); \n          num++;\n      } \n  }' && sleep 5) -v nowtime=$(date +\"%Y-%m-%d__%H:%M:%S\") '\n  { \n      if ($2 ~ last_all && ($3 > 50 || $4 > 50)) {\n          printf(\"%s %s %s %s %s %s\\n\", nowtime, $11, $2, $1, $3, $4);\n      } \n  }'\n  \n  ```\n\n  \n","source":"_posts/进程信息获取.md","raw":"---\ntitle: 进程信息获取\ndate: 2019-09-02 16:44:03\ncover: title.jpg\ntags:\n- script\n- linux\n---\n\n\n\n* 知识准备：\n\n  1. `ps` 该工具用来获取进程信息\n  2. `awk`该工具用来处理数据\n\n* 代码\n\n  ```bash\n  #!/bin/bash\n  \n  ps -aux | awk -v last_all=$(ps -aux | awk '\n  BEGIN{\n      num = 0;\n  } \n  { \n      if ($3 > 50 || $4 > 50) { \n          if (num > 0) {\n              printf(\"|\");\n          } \n          printf(\"%s\", $2); \n          num++;\n      } \n  }' && sleep 5) -v nowtime=$(date +\"%Y-%m-%d__%H:%M:%S\") '\n  { \n      if ($2 ~ last_all && ($3 > 50 || $4 > 50)) {\n          printf(\"%s %s %s %s %s %s\\n\", nowtime, $11, $2, $1, $3, $4);\n      } \n  }'\n  \n  ```\n\n  \n","slug":"进程信息获取","published":1,"updated":"2020-04-08T03:48:31.627Z","_id":"ck8qr69dm00145d3a0nu52dyo","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>\n<p>知识准备：</p>\n<ol>\n<li><code>ps</code> 该工具用来获取进程信息</li>\n<li><code>awk</code>该工具用来处理数据</li>\n</ol>\n</li>\n<li>\n<p>代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">ps -aux | awk -v last_all=$(ps -aux | awk <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">BEGIN&#123;</span></span><br><span class=\"line\"><span class=\"string\">    num = 0;</span></span><br><span class=\"line\"><span class=\"string\">&#125; </span></span><br><span class=\"line\"><span class=\"string\">&#123; </span></span><br><span class=\"line\"><span class=\"string\">    if ($3 &gt; 50 || $4 &gt; 50) &#123; </span></span><br><span class=\"line\"><span class=\"string\">        if (num &gt; 0) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            printf(\"|\");</span></span><br><span class=\"line\"><span class=\"string\">        &#125; </span></span><br><span class=\"line\"><span class=\"string\">        printf(\"%s\", $2); </span></span><br><span class=\"line\"><span class=\"string\">        num++;</span></span><br><span class=\"line\"><span class=\"string\">    &#125; </span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span> &amp;&amp; sleep 5) -v nowtime=$(date +<span class=\"string\">\"%Y-%m-%d__%H:%M:%S\"</span>) <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123; </span></span><br><span class=\"line\"><span class=\"string\">    if ($2 ~ last_all &amp;&amp; ($3 &gt; 50 || $4 &gt; 50)) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        printf(\"%s %s %s %s %s %s\\n\", nowtime, $11, $2, $1, $3, $4);</span></span><br><span class=\"line\"><span class=\"string\">    &#125; </span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>\n<p>知识准备：</p>\n<ol>\n<li><code>ps</code> 该工具用来获取进程信息</li>\n<li><code>awk</code>该工具用来处理数据</li>\n</ol>\n</li>\n<li>\n<p>代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">ps -aux | awk -v last_all=$(ps -aux | awk <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">BEGIN&#123;</span></span><br><span class=\"line\"><span class=\"string\">    num = 0;</span></span><br><span class=\"line\"><span class=\"string\">&#125; </span></span><br><span class=\"line\"><span class=\"string\">&#123; </span></span><br><span class=\"line\"><span class=\"string\">    if ($3 &gt; 50 || $4 &gt; 50) &#123; </span></span><br><span class=\"line\"><span class=\"string\">        if (num &gt; 0) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            printf(\"|\");</span></span><br><span class=\"line\"><span class=\"string\">        &#125; </span></span><br><span class=\"line\"><span class=\"string\">        printf(\"%s\", $2); </span></span><br><span class=\"line\"><span class=\"string\">        num++;</span></span><br><span class=\"line\"><span class=\"string\">    &#125; </span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span> &amp;&amp; sleep 5) -v nowtime=$(date +<span class=\"string\">\"%Y-%m-%d__%H:%M:%S\"</span>) <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123; </span></span><br><span class=\"line\"><span class=\"string\">    if ($2 ~ last_all &amp;&amp; ($3 &gt; 50 || $4 &gt; 50)) &#123;</span></span><br><span class=\"line\"><span class=\"string\">        printf(\"%s %s %s %s %s %s\\n\", nowtime, $11, $2, $1, $3, $4);</span></span><br><span class=\"line\"><span class=\"string\">    &#125; </span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"系统信息获取","date":"2019-09-02T08:42:44.000Z","cover":"title.jpg","_content":"\n> 欢迎大家转载，转载请注明出处，谢谢！\n* 知识准备\n\n  1. `date`：获取当前时间\n  2. `/etc/issue`：系统版本信息\n  3. `/proc/loadavg`：负载信息\n  4. `df`：获取磁盘信息\n  5. `free`：内存信息\n  6. `/sys/class/thermal/thermal_zone0/temp`：cpu温度\n  7. `hostname`：主机名\n\n* 代码\n\n  ```bash\n  #!/bin/bash\n  \n  # 现在时间\n  nowdate=`date +\"%Y-%m-%d__%H:%M:%S\"`\n  # 系统版本\n  os_v=`cat /etc/issue | awk '{printf(\"%s_%s\", $1, $2);}'`\n  # 内核版本\n  ker_v=`uname -r`\n  # 运行时间和负载信息\n  run_and_load=`uptime -p | tr -s \" \" \"\\n\" | awk '{printf(\"_%s\", $1)}'``cat /proc/loadavg | awk '{ printf(\" %s %s %s\", $1, $2, $3); }'`\n  \n  # 负载信息\n  #load_info=`uptime | awk '{printf (\"%s %s %s\", $(NF - 2), $(NF - 1), $NF)}' | tr -s \",\" \" \"`\n  \n  disk_total=`df -m | grep \"^/dev/\" | awk 'BEGIN{t_num=0; u_num = 0}{if (NR > 1) {t_num = t_num + $2; u_num += $3 }}END{printf (\"%d:%d\", t_num, u_num)}'`\n  disk_used=`echo $disk_total | cut -d \":\" -f2`\n  disk_total=`echo $disk_total | cut -d \":\" -f1`\n  \n  #内存大小\n  mem_total=`free -m | sed -n \"2p\" | awk '{printf(\"%s\", $2)}'`\n  \n  # 磁盘占用百分比\n  per_disk_used=`echo \"$disk_total $disk_used\" | awk '{printf(\"%d\", $2/$1 * 100);}'`\n  # 内存占用百分比\n  per_memo=`free -m | sed -n \"2p\" | awk '{printf(\"%d\", $3/$2 * 100);}'`\n  # CPU温度\n  cpu_temp=`cat /sys/class/thermal/thermal_zone0/temp | awk '{printf(\"%d\", $1 / 1000);}'`\n  \n  # 磁盘报警级别\n  \n  if [[ $per_disk_used -ge 0 && $per_disk_used -le 80  ]];then\n      disk_warn=\"normal\"\n  \n  elif [[ $per_disk_used -ge 81 && $per_disk_used -le 90 ]];then\n      disk_warn=\"note\"\n  \n  else\n      disk_warn=\"warning\"\n  \n  fi\n  \n  # 内存报警级别\n  \n  if [[ $per_memo -ge 0 && $per_memo -le 70  ]];then\n      memo_warn=\"normal\"\n  \n  elif [[ $per_memo -ge 71 && $per_memo -le 80 ]];then\n      memo_warn=\"note\"\n  \n  else\n      memo_warn=\"warning\"\n  \n  fi\n  \n  # CPU温度报警级别\n  \n  if [[ $cpu_temp -ge 0 && $cpu_temp -le 50  ]];then\n      cpu_warn=\"normal\"\n  \n  elif [[ $cpu_temp -ge 51 && $cpu_temp -le 70 ]];then\n      cpu_warn=\"note\"\n  \n  else\n      cpu_warn=\"warning\"\n  \n  fi\n  \n  #主机名\n  hname=`hostname`\n  \n  echo \"$nowdate $hname $os_v $ker_v ${run_and_load} ${disk_total}M ${per_disk_used}% ${mem_total}M ${per_memo}% ${cpu_temp} ${disk_warn} ${memo_warn} ${cpu_warn}\"\n  \n  ```\n\n  \n","source":"_posts/系统信息获取.md","raw":"---\ntitle: 系统信息获取\ndate: 2019-09-02 16:42:44\ncover: title.jpg\ntags:\n- script\n- linux\n---\n\n> 欢迎大家转载，转载请注明出处，谢谢！\n* 知识准备\n\n  1. `date`：获取当前时间\n  2. `/etc/issue`：系统版本信息\n  3. `/proc/loadavg`：负载信息\n  4. `df`：获取磁盘信息\n  5. `free`：内存信息\n  6. `/sys/class/thermal/thermal_zone0/temp`：cpu温度\n  7. `hostname`：主机名\n\n* 代码\n\n  ```bash\n  #!/bin/bash\n  \n  # 现在时间\n  nowdate=`date +\"%Y-%m-%d__%H:%M:%S\"`\n  # 系统版本\n  os_v=`cat /etc/issue | awk '{printf(\"%s_%s\", $1, $2);}'`\n  # 内核版本\n  ker_v=`uname -r`\n  # 运行时间和负载信息\n  run_and_load=`uptime -p | tr -s \" \" \"\\n\" | awk '{printf(\"_%s\", $1)}'``cat /proc/loadavg | awk '{ printf(\" %s %s %s\", $1, $2, $3); }'`\n  \n  # 负载信息\n  #load_info=`uptime | awk '{printf (\"%s %s %s\", $(NF - 2), $(NF - 1), $NF)}' | tr -s \",\" \" \"`\n  \n  disk_total=`df -m | grep \"^/dev/\" | awk 'BEGIN{t_num=0; u_num = 0}{if (NR > 1) {t_num = t_num + $2; u_num += $3 }}END{printf (\"%d:%d\", t_num, u_num)}'`\n  disk_used=`echo $disk_total | cut -d \":\" -f2`\n  disk_total=`echo $disk_total | cut -d \":\" -f1`\n  \n  #内存大小\n  mem_total=`free -m | sed -n \"2p\" | awk '{printf(\"%s\", $2)}'`\n  \n  # 磁盘占用百分比\n  per_disk_used=`echo \"$disk_total $disk_used\" | awk '{printf(\"%d\", $2/$1 * 100);}'`\n  # 内存占用百分比\n  per_memo=`free -m | sed -n \"2p\" | awk '{printf(\"%d\", $3/$2 * 100);}'`\n  # CPU温度\n  cpu_temp=`cat /sys/class/thermal/thermal_zone0/temp | awk '{printf(\"%d\", $1 / 1000);}'`\n  \n  # 磁盘报警级别\n  \n  if [[ $per_disk_used -ge 0 && $per_disk_used -le 80  ]];then\n      disk_warn=\"normal\"\n  \n  elif [[ $per_disk_used -ge 81 && $per_disk_used -le 90 ]];then\n      disk_warn=\"note\"\n  \n  else\n      disk_warn=\"warning\"\n  \n  fi\n  \n  # 内存报警级别\n  \n  if [[ $per_memo -ge 0 && $per_memo -le 70  ]];then\n      memo_warn=\"normal\"\n  \n  elif [[ $per_memo -ge 71 && $per_memo -le 80 ]];then\n      memo_warn=\"note\"\n  \n  else\n      memo_warn=\"warning\"\n  \n  fi\n  \n  # CPU温度报警级别\n  \n  if [[ $cpu_temp -ge 0 && $cpu_temp -le 50  ]];then\n      cpu_warn=\"normal\"\n  \n  elif [[ $cpu_temp -ge 51 && $cpu_temp -le 70 ]];then\n      cpu_warn=\"note\"\n  \n  else\n      cpu_warn=\"warning\"\n  \n  fi\n  \n  #主机名\n  hname=`hostname`\n  \n  echo \"$nowdate $hname $os_v $ker_v ${run_and_load} ${disk_total}M ${per_disk_used}% ${mem_total}M ${per_memo}% ${cpu_temp} ${disk_warn} ${memo_warn} ${cpu_warn}\"\n  \n  ```\n\n  \n","slug":"系统信息获取","published":1,"updated":"2020-04-08T03:46:09.219Z","_id":"ck8qr69do00175d3a94a9zth2","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>欢迎大家转载，转载请注明出处，谢谢！</p>\n</blockquote>\n<ul>\n<li>\n<p>知识准备</p>\n<ol>\n<li><code>date</code>：获取当前时间</li>\n<li><code>/etc/issue</code>：系统版本信息</li>\n<li><code>/proc/loadavg</code>：负载信息</li>\n<li><code>df</code>：获取磁盘信息</li>\n<li><code>free</code>：内存信息</li>\n<li><code>/sys/class/thermal/thermal_zone0/temp</code>：cpu温度</li>\n<li><code>hostname</code>：主机名</li>\n</ol>\n</li>\n<li>\n<p>代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 现在时间</span></span><br><span class=\"line\">nowdate=`date +<span class=\"string\">\"%Y-%m-%d__%H:%M:%S\"</span>`</span><br><span class=\"line\"><span class=\"comment\"># 系统版本</span></span><br><span class=\"line\">os_v=`cat /etc/issue | awk <span class=\"string\">'&#123;printf(\"%s_%s\", $1, $2);&#125;'</span>`</span><br><span class=\"line\"><span class=\"comment\"># 内核版本</span></span><br><span class=\"line\">ker_v=`uname -r`</span><br><span class=\"line\"><span class=\"comment\"># 运行时间和负载信息</span></span><br><span class=\"line\">run_and_load=`uptime -p | tr -s <span class=\"string\">\" \"</span> <span class=\"string\">\"\\n\"</span> | awk <span class=\"string\">'&#123;printf(\"_%s\", $1)&#125;'</span>``cat /proc/loadavg | awk <span class=\"string\">'&#123; printf(\" %s %s %s\", $1, $2, $3); &#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 负载信息</span></span><br><span class=\"line\"><span class=\"comment\">#load_info=`uptime | awk '&#123;printf (\"%s %s %s\", $(NF - 2), $(NF - 1), $NF)&#125;' | tr -s \",\" \" \"`</span></span><br><span class=\"line\"></span><br><span class=\"line\">disk_total=`df -m | grep <span class=\"string\">\"^/dev/\"</span> | awk <span class=\"string\">'BEGIN&#123;t_num=0; u_num = 0&#125;&#123;if (NR &gt; 1) &#123;t_num = t_num + $2; u_num += $3 &#125;&#125;END&#123;printf (\"%d:%d\", t_num, u_num)&#125;'</span>`</span><br><span class=\"line\">disk_used=`<span class=\"built_in\">echo</span> <span class=\"variable\">$disk_total</span> | cut -d <span class=\"string\">\":\"</span> -f2`</span><br><span class=\"line\">disk_total=`<span class=\"built_in\">echo</span> <span class=\"variable\">$disk_total</span> | cut -d <span class=\"string\">\":\"</span> -f1`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#内存大小</span></span><br><span class=\"line\">mem_total=`free -m | sed -n <span class=\"string\">\"2p\"</span> | awk <span class=\"string\">'&#123;printf(\"%s\", $2)&#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 磁盘占用百分比</span></span><br><span class=\"line\">per_disk_used=`<span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$disk_total</span> <span class=\"variable\">$disk_used</span>\"</span> | awk <span class=\"string\">'&#123;printf(\"%d\", $2/$1 * 100);&#125;'</span>`</span><br><span class=\"line\"><span class=\"comment\"># 内存占用百分比</span></span><br><span class=\"line\">per_memo=`free -m | sed -n <span class=\"string\">\"2p\"</span> | awk <span class=\"string\">'&#123;printf(\"%d\", $3/$2 * 100);&#125;'</span>`</span><br><span class=\"line\"><span class=\"comment\"># CPU温度</span></span><br><span class=\"line\">cpu_temp=`cat /sys/class/thermal/thermal_zone0/temp | awk <span class=\"string\">'&#123;printf(\"%d\", $1 / 1000);&#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 磁盘报警级别</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$per_disk_used</span> -ge 0 &amp;&amp; <span class=\"variable\">$per_disk_used</span> -le 80  ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    disk_warn=<span class=\"string\">\"normal\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ <span class=\"variable\">$per_disk_used</span> -ge 81 &amp;&amp; <span class=\"variable\">$per_disk_used</span> -le 90 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    disk_warn=<span class=\"string\">\"note\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    disk_warn=<span class=\"string\">\"warning\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 内存报警级别</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$per_memo</span> -ge 0 &amp;&amp; <span class=\"variable\">$per_memo</span> -le 70  ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    memo_warn=<span class=\"string\">\"normal\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ <span class=\"variable\">$per_memo</span> -ge 71 &amp;&amp; <span class=\"variable\">$per_memo</span> -le 80 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    memo_warn=<span class=\"string\">\"note\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    memo_warn=<span class=\"string\">\"warning\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CPU温度报警级别</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$cpu_temp</span> -ge 0 &amp;&amp; <span class=\"variable\">$cpu_temp</span> -le 50  ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    cpu_warn=<span class=\"string\">\"normal\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ <span class=\"variable\">$cpu_temp</span> -ge 51 &amp;&amp; <span class=\"variable\">$cpu_temp</span> -le 70 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    cpu_warn=<span class=\"string\">\"note\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    cpu_warn=<span class=\"string\">\"warning\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#主机名</span></span><br><span class=\"line\">hname=`hostname`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$nowdate</span> <span class=\"variable\">$hname</span> <span class=\"variable\">$os_v</span> <span class=\"variable\">$ker_v</span> <span class=\"variable\">$&#123;run_and_load&#125;</span> <span class=\"variable\">$&#123;disk_total&#125;</span>M <span class=\"variable\">$&#123;per_disk_used&#125;</span>% <span class=\"variable\">$&#123;mem_total&#125;</span>M <span class=\"variable\">$&#123;per_memo&#125;</span>% <span class=\"variable\">$&#123;cpu_temp&#125;</span> <span class=\"variable\">$&#123;disk_warn&#125;</span> <span class=\"variable\">$&#123;memo_warn&#125;</span> <span class=\"variable\">$&#123;cpu_warn&#125;</span>\"</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>欢迎大家转载，转载请注明出处，谢谢！</p>\n</blockquote>\n<ul>\n<li>\n<p>知识准备</p>\n<ol>\n<li><code>date</code>：获取当前时间</li>\n<li><code>/etc/issue</code>：系统版本信息</li>\n<li><code>/proc/loadavg</code>：负载信息</li>\n<li><code>df</code>：获取磁盘信息</li>\n<li><code>free</code>：内存信息</li>\n<li><code>/sys/class/thermal/thermal_zone0/temp</code>：cpu温度</li>\n<li><code>hostname</code>：主机名</li>\n</ol>\n</li>\n<li>\n<p>代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 现在时间</span></span><br><span class=\"line\">nowdate=`date +<span class=\"string\">\"%Y-%m-%d__%H:%M:%S\"</span>`</span><br><span class=\"line\"><span class=\"comment\"># 系统版本</span></span><br><span class=\"line\">os_v=`cat /etc/issue | awk <span class=\"string\">'&#123;printf(\"%s_%s\", $1, $2);&#125;'</span>`</span><br><span class=\"line\"><span class=\"comment\"># 内核版本</span></span><br><span class=\"line\">ker_v=`uname -r`</span><br><span class=\"line\"><span class=\"comment\"># 运行时间和负载信息</span></span><br><span class=\"line\">run_and_load=`uptime -p | tr -s <span class=\"string\">\" \"</span> <span class=\"string\">\"\\n\"</span> | awk <span class=\"string\">'&#123;printf(\"_%s\", $1)&#125;'</span>``cat /proc/loadavg | awk <span class=\"string\">'&#123; printf(\" %s %s %s\", $1, $2, $3); &#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 负载信息</span></span><br><span class=\"line\"><span class=\"comment\">#load_info=`uptime | awk '&#123;printf (\"%s %s %s\", $(NF - 2), $(NF - 1), $NF)&#125;' | tr -s \",\" \" \"`</span></span><br><span class=\"line\"></span><br><span class=\"line\">disk_total=`df -m | grep <span class=\"string\">\"^/dev/\"</span> | awk <span class=\"string\">'BEGIN&#123;t_num=0; u_num = 0&#125;&#123;if (NR &gt; 1) &#123;t_num = t_num + $2; u_num += $3 &#125;&#125;END&#123;printf (\"%d:%d\", t_num, u_num)&#125;'</span>`</span><br><span class=\"line\">disk_used=`<span class=\"built_in\">echo</span> <span class=\"variable\">$disk_total</span> | cut -d <span class=\"string\">\":\"</span> -f2`</span><br><span class=\"line\">disk_total=`<span class=\"built_in\">echo</span> <span class=\"variable\">$disk_total</span> | cut -d <span class=\"string\">\":\"</span> -f1`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#内存大小</span></span><br><span class=\"line\">mem_total=`free -m | sed -n <span class=\"string\">\"2p\"</span> | awk <span class=\"string\">'&#123;printf(\"%s\", $2)&#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 磁盘占用百分比</span></span><br><span class=\"line\">per_disk_used=`<span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$disk_total</span> <span class=\"variable\">$disk_used</span>\"</span> | awk <span class=\"string\">'&#123;printf(\"%d\", $2/$1 * 100);&#125;'</span>`</span><br><span class=\"line\"><span class=\"comment\"># 内存占用百分比</span></span><br><span class=\"line\">per_memo=`free -m | sed -n <span class=\"string\">\"2p\"</span> | awk <span class=\"string\">'&#123;printf(\"%d\", $3/$2 * 100);&#125;'</span>`</span><br><span class=\"line\"><span class=\"comment\"># CPU温度</span></span><br><span class=\"line\">cpu_temp=`cat /sys/class/thermal/thermal_zone0/temp | awk <span class=\"string\">'&#123;printf(\"%d\", $1 / 1000);&#125;'</span>`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 磁盘报警级别</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$per_disk_used</span> -ge 0 &amp;&amp; <span class=\"variable\">$per_disk_used</span> -le 80  ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    disk_warn=<span class=\"string\">\"normal\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ <span class=\"variable\">$per_disk_used</span> -ge 81 &amp;&amp; <span class=\"variable\">$per_disk_used</span> -le 90 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    disk_warn=<span class=\"string\">\"note\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    disk_warn=<span class=\"string\">\"warning\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 内存报警级别</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$per_memo</span> -ge 0 &amp;&amp; <span class=\"variable\">$per_memo</span> -le 70  ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    memo_warn=<span class=\"string\">\"normal\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ <span class=\"variable\">$per_memo</span> -ge 71 &amp;&amp; <span class=\"variable\">$per_memo</span> -le 80 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    memo_warn=<span class=\"string\">\"note\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    memo_warn=<span class=\"string\">\"warning\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CPU温度报警级别</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$cpu_temp</span> -ge 0 &amp;&amp; <span class=\"variable\">$cpu_temp</span> -le 50  ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    cpu_warn=<span class=\"string\">\"normal\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ <span class=\"variable\">$cpu_temp</span> -ge 51 &amp;&amp; <span class=\"variable\">$cpu_temp</span> -le 70 ]];<span class=\"keyword\">then</span></span><br><span class=\"line\">    cpu_warn=<span class=\"string\">\"note\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    cpu_warn=<span class=\"string\">\"warning\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#主机名</span></span><br><span class=\"line\">hname=`hostname`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$nowdate</span> <span class=\"variable\">$hname</span> <span class=\"variable\">$os_v</span> <span class=\"variable\">$ker_v</span> <span class=\"variable\">$&#123;run_and_load&#125;</span> <span class=\"variable\">$&#123;disk_total&#125;</span>M <span class=\"variable\">$&#123;per_disk_used&#125;</span>% <span class=\"variable\">$&#123;mem_total&#125;</span>M <span class=\"variable\">$&#123;per_memo&#125;</span>% <span class=\"variable\">$&#123;cpu_temp&#125;</span> <span class=\"variable\">$&#123;disk_warn&#125;</span> <span class=\"variable\">$&#123;memo_warn&#125;</span> <span class=\"variable\">$&#123;cpu_warn&#125;</span>\"</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"八大排序算法总结","toc":true,"cover":"title.jpg","mathjax":"true","date":"2019-09-27T06:40:10.000Z","_content":"\n## 直接插入排序算法\n* 概述\n  直接插入排序算法在逻辑上将整体数据分为两部分，一部分是已排序部分，另一部分是待排序部分 。\n  排序的过程是：在待排序部分逐步的拿出一个元素，将其插入到已排序部分中合理的位置 。\n* 适用场景\n  插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率，\n  但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 。\n* 优化\n在给当前待排序元素在已排序部分找到一个合适的位置并且待排序数据相对较多的时候，由于已排序部分元素是有序的，因此这个过程可以使用二分法，以优化排序的时间复杂度。\n* 归类\n  1. in-place（原地算法：基本上不需要额外的空间）。\n  2. 稳定排序算法。\n* 空间复杂度\n  直接插入排序是in-place，因此其空间复杂度是 O(1) 。\n* 时间复杂度\n  * 最优\n最优的情况是待排序数据为已排序好的期望顺序，此时每次从待排序部分拿出一个元素只需要与待排序部分中最后一个元素相比较一次，需要比较 $n - 1$ 次，因此其复杂度为 $O(n)$ 。\n  * 最坏\n最坏的情况是待排序数据为已排序好的，但是其顺序正好与期望顺序相反，此时每次从待排序部分拿出一个元素，该元素需要与其前面的已排序部分中的每一个元素进行比较和交换，其比较或交换的次数为 $0+1+2+...+(n-2)+(n-1)$ 也就是$\\frac{n*(n-1)}{2}$ , 因此其复杂度为 $O(n^{2})$(是n方，恶心的渲染器) 。\n  * 平均\n    $O(n^{2})$\n* 代码示例\n  ```c++\n  void insertion_sort(int arr[], int len){\n          int i,j,key;\n          for (i=1;i<len;i++){\n                  key = arr[i];\n                  j=i-1;\n                  while((j>=0) && (arr[j]>key)) {\n                          arr[j+1] = arr[j];\n                          j--;\n                  }\n                  arr[j+1] = key;\n          }\n  }\n  ```\n\n\n\n## 希尔排序算法\n- 概述\n希尔排序是插入排序的一个优化版本，是在插入排序的基础上加入了分治的思想，按照设置好的步长进行跳跃式的插入排序，或者说按照步长将数据分为几个部分，分别对这几个部分进行排序。举个例子：有一组数据arr有10个元素，我们设步长为5，排序的开始，定位到首位元素，首位元素是他们组的第一个元素，它们组的第二位元素应该是$arr[0+5]$ 也就是第5个元素。\n  ![ShellSort](1.希尔排序.webp)\n- 适用场景\n   在shell先生的优化下，希尔排序不仅继承了插入排序的优点，而且可以做到对于数据量稍微大点的，无序的数据也能很快。\n- 归类\n  1. in-place（原地算法：基本上不需要额外的空间）。\n  2. 不稳定排序算法。\n- 空间复杂度\n  与插入排序相同，它是一个原地算法，它的时间复杂度是线性的，也就是$O(1)$ 。\n- 时间复杂度\n  希尔排序的时间复杂度与步长的选取有关，当步长为1的时候，时间复杂度是$O(n^{2})$ 。\n  当采用Sedgewick提出的步长（目前最好的步长序列）的时候，时间复杂度为$O({n}log_{2}{n})$ 。\n- 代码示例\n  ```c\n  void shell_sort(int arr[], int len) {\n  \tint gap, i, j;\n  \tint temp;\n  \tfor (gap = len >> 1; gap > 0; gap >>= 1)\n  \t\tfor (i = gap; i < len; i++) {\n  \t\t\ttemp = arr[i];\n  \t\t\tfor (j = i - gap; j >= 0 && arr[j] > temp; j -= gap)\n  \t\t\t\tarr[j + gap] = arr[j];\n  \t\t\tarr[j + gap] = temp;\n  \t\t}\n  }\n  ```\n\n\n\n## 简单选择排序算法\n- 概述\n  选择排序依然是将待排序数据分为已排序区和待排序区。\n  排序的逻辑是每次从待排序区找出一个最大（或最小）的元素放置到已排序区的末尾。\n  选择排序算法是所有纯基于交换的排序算法中非常好的。\n- 归类\n  1. in-place（原地算法：基本上不需要额外的空间）。\n  2. 不稳定排序算法。\n- 空间复杂度\n  它是一个原地算法，它的时间复杂度是线性的，也就是$O(1)$ 。\n- 时间复杂度\n  其最好、最坏和平均的时间复杂度都是$O(n^{2})$ 。\n- 代码示例\n  ```c\n  void selection_sort(int a[], int len) \n  {\n      int i,j,temp;\n  \n  \tfor (i = 0 ; i < len - 1 ; i++) \n      {\n  \t\tint min = i;\n  \t\tfor (j = i + 1; j < len; j++)     //走訪未排序的元素\n  \t\t{\n  \t\t\tif (a[j] < a[min])    //找到目前最小值\n  \t\t\t{\n  \t\t\t\tmin = j;    //记录最小值\n  \t\t\t}\n  \t\t}\n  \t\ttemp=a[min];\n  \t\ta[min]=a[i];\n  \t\ta[i]=temp;\n  \t}\n  }\n  \n  ```\n\n\n\n## 堆排序\n*   概述\n    堆排序也属于选择排序。\n    利用堆的特性对数据进行排序的一种排序算法。\n    排序的逻辑就是不断的从堆顶弹出一个元素，然后每次弹出一个元素后维护一下堆，当堆空的时候排序完成。\n*   适用场景\n*   归类\n    1.  in-place（原地算法：基本上不需要额外的空间）。\n    2.  不稳定排序算法。\n*   空间复杂度\n    堆排序属于原地算法，空间复杂度为$O(1)$\n*   时间复杂度\n    平均时间复杂度为$O(nlogn)$\n*   代码示例\n    ```c\n    #include <stdio.h>\n    #include <stdlib.h>\n    \n    void swap(int *a, int *b) {\n        int temp = *b;\n        *b = *a;\n        *a = temp;\n    }\n    \n    void max_heapify(int arr[], int start, int end) {\n        // 建立父節點指標和子節點指標\n        int dad = start;\n        int son = dad * 2 + 1;\n        while (son <= end) { // 若子節點指標在範圍內才做比較\n            if (son + 1 <= end && arr[son] < arr[son + 1]) // 先比較兩個子節點大小，選擇最大的\n                son++;\n            if (arr[dad] > arr[son]) //如果父節點大於子節點代表調整完畢，直接跳出函數\n                return;\n            else { // 否則交換父子內容再繼續子節點和孫節點比较\n                swap(&arr[dad], &arr[son]);\n                dad = son;\n                son = dad * 2 + 1;\n            }\n        }\n    }\n    \n    void heap_sort(int arr[], int len) {\n        int i;\n        // 初始化，i從最後一個父節點開始調整\n        for (i = len / 2 - 1; i >= 0; i--)\n            max_heapify(arr, i, len - 1);\n        // 先將第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢\n        for (i = len - 1; i > 0; i--) {\n            swap(&arr[0], &arr[i]);\n            max_heapify(arr, 0, i - 1);\n        }\n    }\n    \n    int main() {\n        int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };\n        int len = (int) sizeof(arr) / sizeof(*arr);\n        heap_sort(arr, len);\n        int i;\n        for (i = 0; i < len; i++)\n            printf(\"%d \", arr[i]);\n        printf(\"\\n\");\n        return 0;\n    }\n    ```\n\n\n\n## 冒泡排序\n\n*   概述\n    冒泡排序是非常经典的一个纯粹基于交换的排序算法。\n    算法的基本逻辑是：对于n个待排序数据，有n次循环，每次循环从第一个元素开始与其后面的元素相比较，对相对位置不对的两个元素实施交换，循环结束后本次循环的末尾位置就是本次循环最大的元素，因此每次循环的长度都比上次循环次数少一。\n*   适用场景\n    基本有序，数量较少。\n*   归类\n    1.  in-place（原地算法：基本上不需要额外的空间）。\n    2.  稳定排序算法。\n*   时间复杂度\n    平均时间复杂度为$O(n^{2})$\n*   空间复杂度\n    原地算法，其空间复杂度为$O(1)$\n*   比较次数\n    循环次数是n次，每次循环都能有一个当前最大的元素归位，因此每次循环的长度都比上次循环次数少一，那么对于n个待排序数据，其比较次数就是$(n-1) + (n - 2) + ... + 1$\n*   代码示例\n    ```c\n    #include <stdio.h>\n    \n    #define ARR_LEN 255 /* 數組長度上限 */\n    #define elemType int /* 元素類型 */\n    \n    /* 泡沫排序 */\n    /* 1. 從當前元素起，向後依次比較每一對相鄰元素，若逆序則互換 */\n    /* 2. 對所有元素均重複以上步驟，直至最後一個元素 */\n    /* elemType arr[]: 排序目標數組; int len: 元素個數 */\n    void bubbleSort (int arr[], int len)\n    {\n    \n    \tint i, j,temp;\n    \tBoolean exchanged = true;\n    \t\n    \tfor (i=0; exchanged && i<len-1; i++) /* 外迴圈為排序趟數，len個數進行len-1趟,只有交換過,exchanged值為true才有執行迴圈的必要,否則exchanged值為false不執行迴圈 */\n    \t\tfor (j=0; j<len-1-i; j++) \n    \t\t{ /* 內迴圈為每趟比較的次數，第i趟比較len-i次  */\n    \t\t\n    \t\texchanged = false;\n    \t\t\n    \t\t\tif (arr[j] > arr[j+1])\n    \t\t\t{ /* 相鄰元素比較，若逆序則互換（升序為左大於右，逆序反之） */\n    \t\t\t\ttemp = arr[j];\n    \t\t\t\tarr[j] = arr[j+1];\n    \t\t\t\tarr[j+1] = temp;\n    \t\t\t\texchanged = true; /*只有數值互換過, exchanged才會從false變成true,否則數列已經排序完成,exchanged值仍然為false,沒必要排序 */\n    \t\t\t}\n    \t\t}\n    }\n    \n    int main (void) {\n    \tint arr[ARR_LEN] = {3,5,1,-7,4,9,-6,8,10,4};\n    \tint len = 10;\n    \tint i;\n    \t\n    \tbubbleSort (arr, len);\n    \t\n    \tfor (i=0; i<len; i++)\n    \t\tprintf (\"%d\\t\", arr[i]);\n    \tputchar ('\\n');\n    \t\n    \treturn 0;\n    }\n    ```\n\n\n\n## 快速排序\n-   概述\n    快速排序也是非常经典而且很实用的一种排序算法，该算法采用了分治的思想。\n    算法的基本逻辑是每次从当前排序区域挑选出一个基准值，通过不断的交换使得基准值左边的数据都比基准值小(或大),右边相反，\n    然后以基准值为分割，递归的对两个部分分别进行上述交换。\n-   适用场景\n    数据量较大且混乱程度较高。\n-   归类\n    1.  in-place（原地算法：基本上不需要额外的空间）。\n    2.  不稳定排序算法。\n-   时间复杂度\n    平均时间复杂度为$O(nlogn)$\n-   空间复杂度\n    原地算法，其空间复杂度为$O(1)$\n-   代码示例\n    ```c\n    typedef struct _Range {\n        int start, end;\n    } Range;\n    \n    Range new_Range(int s, int e) {\n        Range r;\n        r.start = s;\n        r.end = e;\n        return r;\n    }\n    \n    void swap(int *x, int *y) {\n        int t = *x;\n        *x = *y;\n        *y = t;\n    }\n    \n    void quick_sort(int arr[], const int len) {\n        if (len <= 0)\n            return; // 避免len等於負值時引發段錯誤（Segment Fault）\n        // r[]模擬列表,p為數量,r[p++]為push,r[--p]為pop且取得元素\n        Range r[len];\n        int p = 0;\n        r[p++] = new_Range(0, len - 1);\n        while (p) {\n            Range range = r[--p];\n            if (range.start >= range.end)\n                continue;\n            int mid = arr[(range.start + range.end) / 2]; // 選取中間點為基準點\n            int left = range.start, right = range.end;\n            do {\n                while (arr[left] < mid) ++left;   // 檢測基準點左側是否符合要求\n                while (arr[right] > mid) --right; //檢測基準點右側是否符合要求\n                if (left <= right) {\n                    swap(&arr[left], &arr[right]);\n                    left++;\n                    right--;               // 移動指針以繼續\n                }\n            } while (left <= right);\n            if (range.start < right) r[p++] = new_Range(range.start, right);\n            if (range.end > left) r[p++] = new_Range(left, range.end);\n        }\n    }\n    ```\n\n\n## 归并排序\n-   概述\n    归并排序是分治思想的经典应用。\n    归并排序分为两种操作：\n        1. 分割：当前待排序数据分割为两部分。\n        2. 合并：在保持排序顺序的情况下将两部分合并。\n    递归方式：\n        1. 不断的对待排序数据进行递归式的平均分割，直到当前数据不多于2个为止。\n        2. 对当前待排序数据进行均等分割，不断的分别从两个部分中拿出两个元素进行比较，然后按照排序顺序放置到临时区域，如此对两部分进行合并。\n    迭代方式：\n        1. 对于待排序数据两两进行按照排序顺序交换。\n        2. 对于上述得出的若干两个元素组成的数对再次进行与递归方式相同的归并操作。\n        3. 如此反复，直到只剩一个部分为止。\n-   适用场景\n    与快速排序相同，适用于数据量较大并且较为混乱的情况。\n-   归类\n    稳定排序算法。\n-   时间复杂度\n    平均时间复杂度为$O(nlogn)$\n-   空间复杂度\n    由于进行归并操作的时候需要借助额外的临时空间存储归并后的数据，而这些数据也正是原数据，因此空间复杂度是$O(n)$。\n-   代码示例\n    ```c\n    // 迭代方式\n    int min(int x, int y) {\n        return x < y ? x : y;\n    }\n    void merge_sort(int arr[], int len) {\n        int *a = arr;\n        int *b = (int *) malloc(len * sizeof(int));\n        int seg, start;\n        for (seg = 1; seg < len; seg += seg) {\n            for (start = 0; start < len; start += seg * 2) {\n                int low = start, mid = min(start + seg, len), high = min(start + seg * 2, len);\n                int k = low;\n                int start1 = low, end1 = mid;\n                int start2 = mid, end2 = high;\n                while (start1 < end1 && start2 < end2)\n                    b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];\n                while (start1 < end1)\n                    b[k++] = a[start1++];\n                while (start2 < end2)\n                    b[k++] = a[start2++];\n            }\n            int *temp = a;\n            a = b;\n            b = temp;\n        }\n        if (a != arr) {\n            int i;\n            for (i = 0; i < len; i++)\n                b[i] = a[i];\n            b = a;\n        }\n        free(b);\n    }\n    \n    // 归并方法\n    void merge_sort_recursive(int arr[], int reg[], int start, int end) {\n        if (start >= end)\n            return;\n        int len = end - start, mid = (len >> 1) + start;\n        int start1 = start, end1 = mid;\n        int start2 = mid + 1, end2 = end;\n        merge_sort_recursive(arr, reg, start1, end1);\n        merge_sort_recursive(arr, reg, start2, end2);\n        int k = start;\n        while (start1 <= end1 && start2 <= end2)\n            reg[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];\n        while (start1 <= end1)\n            reg[k++] = arr[start1++];\n        while (start2 <= end2)\n            reg[k++] = arr[start2++];\n        for (k = start; k <= end; k++)\n            arr[k] = reg[k];\n    }\n    \n    void merge_sort(int arr[], const int len) {\n        int reg[len];\n        merge_sort_recursive(arr, reg, 0, len - 1);\n    }\n    ```\n\n\n## 基数排序\n-   概述\n    基数排序是比较特殊的一种排序方法，是唯一的一个不是基于交换的排序算法。\n    其基本思想是按照待排序数据的每一位进行排序，进行若干次排序。\n    基数排序有两种排序方式，一种是从低位到高位排序(LSD), 另一种是从高位到低位排序(MSD)。\n    这里提到的每一位，可以是任意进制的每一位，而位数的选择也直接影响其时间复杂度与空间复杂度。\n-   归类\n    稳定排序算法\n-   时间复杂度\n    基数排序的时间复杂度受到位数的影响，也就是说有多少位当然也就需要排序多少次，因此其时间复杂度为$O(n * k)$，其中k是位数。\n-   空间复杂度\n    每一位的数字的种类就是以什么样的方式来选择位数，分割每一位，若以十进制来分割每一位，那么每一位的数字的种类就有十种。\n    在对每一位进行排序的时候，就需要类似桶排序的方式进行。\n    因此，其空间复杂度就是这若干个“桶”，也就是位数，再加上存储待排序数据的数据结构$O(n * k)$，k为位数。\n-   代码示例\n    ```c\n    \n    int maxbit(int data[], int n) //辅助函数，求数据的最大位数\n    {\n        int maxData = data[0];\t\t///< 最大数\n        /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。\n        for (int i = 1; i < n; ++i)\n        {\n            if (maxData < data[i])\n                maxData = data[i];\n        }\n        int d = 1;\n        int p = 10;\n        while (maxData >= p)\n        {\n            //p *= 10; // Maybe overflow\n            maxData /= 10;\n            ++d;\n        }\n        return d;\n    /*    int d = 1; //保存最大的位数\n        int p = 10;\n        for(int i = 0; i < n; ++i)\n        {\n            while(data[i] >= p)\n            {\n                p *= 10;\n                ++d;\n            }\n        }\n        return d;*/\n    }\n    void radixsort(int data[], int n) //基数排序\n    {\n        int d = maxbit(data, n);\n        int *tmp = new int[n];\n        int *count = new int[10]; //计数器\n        int i, j, k;\n        int radix = 1;\n        for(i = 1; i <= d; i++) //进行d次排序\n        {\n            for(j = 0; j < 10; j++)\n                count[j] = 0; //每次分配前清空计数器\n            for(j = 0; j < n; j++)\n            {\n                k = (data[j] / radix) % 10; //统计每个桶中的记录数\n                count[k]++;\n            }\n            for(j = 1; j < 10; j++)\n                count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶\n            for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中\n            {\n                k = (data[j] / radix) % 10;\n                tmp[count[k] - 1] = data[j];\n                count[k]--;\n            }\n            for(j = 0; j < n; j++) //将临时数组的内容复制到data中\n                data[j] = tmp[j];\n            radix = radix * 10;\n        }\n        delete []tmp;\n        delete []count;\n    }\n        \n    ```\n\n\n\n---\n\n资源引用声明：\n\n[维基百科](https://zh.wikipedia.org/wiki/)\n[简书：排序算法使用场景对比](https://www.jianshu.com/p/4db794bd7c1b)\n[八大排序算法总结与java实现](https://itimetraveler.github.io/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/)\n","source":"_posts/八大排序算法总结.md","raw":"---\ntitle: 八大排序算法总结\ntags:\n  - note\n  - alogrithm\ncategories: []\ntoc: true\ncover: title.jpg\nmathjax: 'true'\ndate: 2019-09-27 14:40:10\n---\n\n## 直接插入排序算法\n* 概述\n  直接插入排序算法在逻辑上将整体数据分为两部分，一部分是已排序部分，另一部分是待排序部分 。\n  排序的过程是：在待排序部分逐步的拿出一个元素，将其插入到已排序部分中合理的位置 。\n* 适用场景\n  插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率，\n  但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 。\n* 优化\n在给当前待排序元素在已排序部分找到一个合适的位置并且待排序数据相对较多的时候，由于已排序部分元素是有序的，因此这个过程可以使用二分法，以优化排序的时间复杂度。\n* 归类\n  1. in-place（原地算法：基本上不需要额外的空间）。\n  2. 稳定排序算法。\n* 空间复杂度\n  直接插入排序是in-place，因此其空间复杂度是 O(1) 。\n* 时间复杂度\n  * 最优\n最优的情况是待排序数据为已排序好的期望顺序，此时每次从待排序部分拿出一个元素只需要与待排序部分中最后一个元素相比较一次，需要比较 $n - 1$ 次，因此其复杂度为 $O(n)$ 。\n  * 最坏\n最坏的情况是待排序数据为已排序好的，但是其顺序正好与期望顺序相反，此时每次从待排序部分拿出一个元素，该元素需要与其前面的已排序部分中的每一个元素进行比较和交换，其比较或交换的次数为 $0+1+2+...+(n-2)+(n-1)$ 也就是$\\frac{n*(n-1)}{2}$ , 因此其复杂度为 $O(n^{2})$(是n方，恶心的渲染器) 。\n  * 平均\n    $O(n^{2})$\n* 代码示例\n  ```c++\n  void insertion_sort(int arr[], int len){\n          int i,j,key;\n          for (i=1;i<len;i++){\n                  key = arr[i];\n                  j=i-1;\n                  while((j>=0) && (arr[j]>key)) {\n                          arr[j+1] = arr[j];\n                          j--;\n                  }\n                  arr[j+1] = key;\n          }\n  }\n  ```\n\n\n\n## 希尔排序算法\n- 概述\n希尔排序是插入排序的一个优化版本，是在插入排序的基础上加入了分治的思想，按照设置好的步长进行跳跃式的插入排序，或者说按照步长将数据分为几个部分，分别对这几个部分进行排序。举个例子：有一组数据arr有10个元素，我们设步长为5，排序的开始，定位到首位元素，首位元素是他们组的第一个元素，它们组的第二位元素应该是$arr[0+5]$ 也就是第5个元素。\n  ![ShellSort](1.希尔排序.webp)\n- 适用场景\n   在shell先生的优化下，希尔排序不仅继承了插入排序的优点，而且可以做到对于数据量稍微大点的，无序的数据也能很快。\n- 归类\n  1. in-place（原地算法：基本上不需要额外的空间）。\n  2. 不稳定排序算法。\n- 空间复杂度\n  与插入排序相同，它是一个原地算法，它的时间复杂度是线性的，也就是$O(1)$ 。\n- 时间复杂度\n  希尔排序的时间复杂度与步长的选取有关，当步长为1的时候，时间复杂度是$O(n^{2})$ 。\n  当采用Sedgewick提出的步长（目前最好的步长序列）的时候，时间复杂度为$O({n}log_{2}{n})$ 。\n- 代码示例\n  ```c\n  void shell_sort(int arr[], int len) {\n  \tint gap, i, j;\n  \tint temp;\n  \tfor (gap = len >> 1; gap > 0; gap >>= 1)\n  \t\tfor (i = gap; i < len; i++) {\n  \t\t\ttemp = arr[i];\n  \t\t\tfor (j = i - gap; j >= 0 && arr[j] > temp; j -= gap)\n  \t\t\t\tarr[j + gap] = arr[j];\n  \t\t\tarr[j + gap] = temp;\n  \t\t}\n  }\n  ```\n\n\n\n## 简单选择排序算法\n- 概述\n  选择排序依然是将待排序数据分为已排序区和待排序区。\n  排序的逻辑是每次从待排序区找出一个最大（或最小）的元素放置到已排序区的末尾。\n  选择排序算法是所有纯基于交换的排序算法中非常好的。\n- 归类\n  1. in-place（原地算法：基本上不需要额外的空间）。\n  2. 不稳定排序算法。\n- 空间复杂度\n  它是一个原地算法，它的时间复杂度是线性的，也就是$O(1)$ 。\n- 时间复杂度\n  其最好、最坏和平均的时间复杂度都是$O(n^{2})$ 。\n- 代码示例\n  ```c\n  void selection_sort(int a[], int len) \n  {\n      int i,j,temp;\n  \n  \tfor (i = 0 ; i < len - 1 ; i++) \n      {\n  \t\tint min = i;\n  \t\tfor (j = i + 1; j < len; j++)     //走訪未排序的元素\n  \t\t{\n  \t\t\tif (a[j] < a[min])    //找到目前最小值\n  \t\t\t{\n  \t\t\t\tmin = j;    //记录最小值\n  \t\t\t}\n  \t\t}\n  \t\ttemp=a[min];\n  \t\ta[min]=a[i];\n  \t\ta[i]=temp;\n  \t}\n  }\n  \n  ```\n\n\n\n## 堆排序\n*   概述\n    堆排序也属于选择排序。\n    利用堆的特性对数据进行排序的一种排序算法。\n    排序的逻辑就是不断的从堆顶弹出一个元素，然后每次弹出一个元素后维护一下堆，当堆空的时候排序完成。\n*   适用场景\n*   归类\n    1.  in-place（原地算法：基本上不需要额外的空间）。\n    2.  不稳定排序算法。\n*   空间复杂度\n    堆排序属于原地算法，空间复杂度为$O(1)$\n*   时间复杂度\n    平均时间复杂度为$O(nlogn)$\n*   代码示例\n    ```c\n    #include <stdio.h>\n    #include <stdlib.h>\n    \n    void swap(int *a, int *b) {\n        int temp = *b;\n        *b = *a;\n        *a = temp;\n    }\n    \n    void max_heapify(int arr[], int start, int end) {\n        // 建立父節點指標和子節點指標\n        int dad = start;\n        int son = dad * 2 + 1;\n        while (son <= end) { // 若子節點指標在範圍內才做比較\n            if (son + 1 <= end && arr[son] < arr[son + 1]) // 先比較兩個子節點大小，選擇最大的\n                son++;\n            if (arr[dad] > arr[son]) //如果父節點大於子節點代表調整完畢，直接跳出函數\n                return;\n            else { // 否則交換父子內容再繼續子節點和孫節點比较\n                swap(&arr[dad], &arr[son]);\n                dad = son;\n                son = dad * 2 + 1;\n            }\n        }\n    }\n    \n    void heap_sort(int arr[], int len) {\n        int i;\n        // 初始化，i從最後一個父節點開始調整\n        for (i = len / 2 - 1; i >= 0; i--)\n            max_heapify(arr, i, len - 1);\n        // 先將第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢\n        for (i = len - 1; i > 0; i--) {\n            swap(&arr[0], &arr[i]);\n            max_heapify(arr, 0, i - 1);\n        }\n    }\n    \n    int main() {\n        int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };\n        int len = (int) sizeof(arr) / sizeof(*arr);\n        heap_sort(arr, len);\n        int i;\n        for (i = 0; i < len; i++)\n            printf(\"%d \", arr[i]);\n        printf(\"\\n\");\n        return 0;\n    }\n    ```\n\n\n\n## 冒泡排序\n\n*   概述\n    冒泡排序是非常经典的一个纯粹基于交换的排序算法。\n    算法的基本逻辑是：对于n个待排序数据，有n次循环，每次循环从第一个元素开始与其后面的元素相比较，对相对位置不对的两个元素实施交换，循环结束后本次循环的末尾位置就是本次循环最大的元素，因此每次循环的长度都比上次循环次数少一。\n*   适用场景\n    基本有序，数量较少。\n*   归类\n    1.  in-place（原地算法：基本上不需要额外的空间）。\n    2.  稳定排序算法。\n*   时间复杂度\n    平均时间复杂度为$O(n^{2})$\n*   空间复杂度\n    原地算法，其空间复杂度为$O(1)$\n*   比较次数\n    循环次数是n次，每次循环都能有一个当前最大的元素归位，因此每次循环的长度都比上次循环次数少一，那么对于n个待排序数据，其比较次数就是$(n-1) + (n - 2) + ... + 1$\n*   代码示例\n    ```c\n    #include <stdio.h>\n    \n    #define ARR_LEN 255 /* 數組長度上限 */\n    #define elemType int /* 元素類型 */\n    \n    /* 泡沫排序 */\n    /* 1. 從當前元素起，向後依次比較每一對相鄰元素，若逆序則互換 */\n    /* 2. 對所有元素均重複以上步驟，直至最後一個元素 */\n    /* elemType arr[]: 排序目標數組; int len: 元素個數 */\n    void bubbleSort (int arr[], int len)\n    {\n    \n    \tint i, j,temp;\n    \tBoolean exchanged = true;\n    \t\n    \tfor (i=0; exchanged && i<len-1; i++) /* 外迴圈為排序趟數，len個數進行len-1趟,只有交換過,exchanged值為true才有執行迴圈的必要,否則exchanged值為false不執行迴圈 */\n    \t\tfor (j=0; j<len-1-i; j++) \n    \t\t{ /* 內迴圈為每趟比較的次數，第i趟比較len-i次  */\n    \t\t\n    \t\texchanged = false;\n    \t\t\n    \t\t\tif (arr[j] > arr[j+1])\n    \t\t\t{ /* 相鄰元素比較，若逆序則互換（升序為左大於右，逆序反之） */\n    \t\t\t\ttemp = arr[j];\n    \t\t\t\tarr[j] = arr[j+1];\n    \t\t\t\tarr[j+1] = temp;\n    \t\t\t\texchanged = true; /*只有數值互換過, exchanged才會從false變成true,否則數列已經排序完成,exchanged值仍然為false,沒必要排序 */\n    \t\t\t}\n    \t\t}\n    }\n    \n    int main (void) {\n    \tint arr[ARR_LEN] = {3,5,1,-7,4,9,-6,8,10,4};\n    \tint len = 10;\n    \tint i;\n    \t\n    \tbubbleSort (arr, len);\n    \t\n    \tfor (i=0; i<len; i++)\n    \t\tprintf (\"%d\\t\", arr[i]);\n    \tputchar ('\\n');\n    \t\n    \treturn 0;\n    }\n    ```\n\n\n\n## 快速排序\n-   概述\n    快速排序也是非常经典而且很实用的一种排序算法，该算法采用了分治的思想。\n    算法的基本逻辑是每次从当前排序区域挑选出一个基准值，通过不断的交换使得基准值左边的数据都比基准值小(或大),右边相反，\n    然后以基准值为分割，递归的对两个部分分别进行上述交换。\n-   适用场景\n    数据量较大且混乱程度较高。\n-   归类\n    1.  in-place（原地算法：基本上不需要额外的空间）。\n    2.  不稳定排序算法。\n-   时间复杂度\n    平均时间复杂度为$O(nlogn)$\n-   空间复杂度\n    原地算法，其空间复杂度为$O(1)$\n-   代码示例\n    ```c\n    typedef struct _Range {\n        int start, end;\n    } Range;\n    \n    Range new_Range(int s, int e) {\n        Range r;\n        r.start = s;\n        r.end = e;\n        return r;\n    }\n    \n    void swap(int *x, int *y) {\n        int t = *x;\n        *x = *y;\n        *y = t;\n    }\n    \n    void quick_sort(int arr[], const int len) {\n        if (len <= 0)\n            return; // 避免len等於負值時引發段錯誤（Segment Fault）\n        // r[]模擬列表,p為數量,r[p++]為push,r[--p]為pop且取得元素\n        Range r[len];\n        int p = 0;\n        r[p++] = new_Range(0, len - 1);\n        while (p) {\n            Range range = r[--p];\n            if (range.start >= range.end)\n                continue;\n            int mid = arr[(range.start + range.end) / 2]; // 選取中間點為基準點\n            int left = range.start, right = range.end;\n            do {\n                while (arr[left] < mid) ++left;   // 檢測基準點左側是否符合要求\n                while (arr[right] > mid) --right; //檢測基準點右側是否符合要求\n                if (left <= right) {\n                    swap(&arr[left], &arr[right]);\n                    left++;\n                    right--;               // 移動指針以繼續\n                }\n            } while (left <= right);\n            if (range.start < right) r[p++] = new_Range(range.start, right);\n            if (range.end > left) r[p++] = new_Range(left, range.end);\n        }\n    }\n    ```\n\n\n## 归并排序\n-   概述\n    归并排序是分治思想的经典应用。\n    归并排序分为两种操作：\n        1. 分割：当前待排序数据分割为两部分。\n        2. 合并：在保持排序顺序的情况下将两部分合并。\n    递归方式：\n        1. 不断的对待排序数据进行递归式的平均分割，直到当前数据不多于2个为止。\n        2. 对当前待排序数据进行均等分割，不断的分别从两个部分中拿出两个元素进行比较，然后按照排序顺序放置到临时区域，如此对两部分进行合并。\n    迭代方式：\n        1. 对于待排序数据两两进行按照排序顺序交换。\n        2. 对于上述得出的若干两个元素组成的数对再次进行与递归方式相同的归并操作。\n        3. 如此反复，直到只剩一个部分为止。\n-   适用场景\n    与快速排序相同，适用于数据量较大并且较为混乱的情况。\n-   归类\n    稳定排序算法。\n-   时间复杂度\n    平均时间复杂度为$O(nlogn)$\n-   空间复杂度\n    由于进行归并操作的时候需要借助额外的临时空间存储归并后的数据，而这些数据也正是原数据，因此空间复杂度是$O(n)$。\n-   代码示例\n    ```c\n    // 迭代方式\n    int min(int x, int y) {\n        return x < y ? x : y;\n    }\n    void merge_sort(int arr[], int len) {\n        int *a = arr;\n        int *b = (int *) malloc(len * sizeof(int));\n        int seg, start;\n        for (seg = 1; seg < len; seg += seg) {\n            for (start = 0; start < len; start += seg * 2) {\n                int low = start, mid = min(start + seg, len), high = min(start + seg * 2, len);\n                int k = low;\n                int start1 = low, end1 = mid;\n                int start2 = mid, end2 = high;\n                while (start1 < end1 && start2 < end2)\n                    b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];\n                while (start1 < end1)\n                    b[k++] = a[start1++];\n                while (start2 < end2)\n                    b[k++] = a[start2++];\n            }\n            int *temp = a;\n            a = b;\n            b = temp;\n        }\n        if (a != arr) {\n            int i;\n            for (i = 0; i < len; i++)\n                b[i] = a[i];\n            b = a;\n        }\n        free(b);\n    }\n    \n    // 归并方法\n    void merge_sort_recursive(int arr[], int reg[], int start, int end) {\n        if (start >= end)\n            return;\n        int len = end - start, mid = (len >> 1) + start;\n        int start1 = start, end1 = mid;\n        int start2 = mid + 1, end2 = end;\n        merge_sort_recursive(arr, reg, start1, end1);\n        merge_sort_recursive(arr, reg, start2, end2);\n        int k = start;\n        while (start1 <= end1 && start2 <= end2)\n            reg[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];\n        while (start1 <= end1)\n            reg[k++] = arr[start1++];\n        while (start2 <= end2)\n            reg[k++] = arr[start2++];\n        for (k = start; k <= end; k++)\n            arr[k] = reg[k];\n    }\n    \n    void merge_sort(int arr[], const int len) {\n        int reg[len];\n        merge_sort_recursive(arr, reg, 0, len - 1);\n    }\n    ```\n\n\n## 基数排序\n-   概述\n    基数排序是比较特殊的一种排序方法，是唯一的一个不是基于交换的排序算法。\n    其基本思想是按照待排序数据的每一位进行排序，进行若干次排序。\n    基数排序有两种排序方式，一种是从低位到高位排序(LSD), 另一种是从高位到低位排序(MSD)。\n    这里提到的每一位，可以是任意进制的每一位，而位数的选择也直接影响其时间复杂度与空间复杂度。\n-   归类\n    稳定排序算法\n-   时间复杂度\n    基数排序的时间复杂度受到位数的影响，也就是说有多少位当然也就需要排序多少次，因此其时间复杂度为$O(n * k)$，其中k是位数。\n-   空间复杂度\n    每一位的数字的种类就是以什么样的方式来选择位数，分割每一位，若以十进制来分割每一位，那么每一位的数字的种类就有十种。\n    在对每一位进行排序的时候，就需要类似桶排序的方式进行。\n    因此，其空间复杂度就是这若干个“桶”，也就是位数，再加上存储待排序数据的数据结构$O(n * k)$，k为位数。\n-   代码示例\n    ```c\n    \n    int maxbit(int data[], int n) //辅助函数，求数据的最大位数\n    {\n        int maxData = data[0];\t\t///< 最大数\n        /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。\n        for (int i = 1; i < n; ++i)\n        {\n            if (maxData < data[i])\n                maxData = data[i];\n        }\n        int d = 1;\n        int p = 10;\n        while (maxData >= p)\n        {\n            //p *= 10; // Maybe overflow\n            maxData /= 10;\n            ++d;\n        }\n        return d;\n    /*    int d = 1; //保存最大的位数\n        int p = 10;\n        for(int i = 0; i < n; ++i)\n        {\n            while(data[i] >= p)\n            {\n                p *= 10;\n                ++d;\n            }\n        }\n        return d;*/\n    }\n    void radixsort(int data[], int n) //基数排序\n    {\n        int d = maxbit(data, n);\n        int *tmp = new int[n];\n        int *count = new int[10]; //计数器\n        int i, j, k;\n        int radix = 1;\n        for(i = 1; i <= d; i++) //进行d次排序\n        {\n            for(j = 0; j < 10; j++)\n                count[j] = 0; //每次分配前清空计数器\n            for(j = 0; j < n; j++)\n            {\n                k = (data[j] / radix) % 10; //统计每个桶中的记录数\n                count[k]++;\n            }\n            for(j = 1; j < 10; j++)\n                count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶\n            for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中\n            {\n                k = (data[j] / radix) % 10;\n                tmp[count[k] - 1] = data[j];\n                count[k]--;\n            }\n            for(j = 0; j < n; j++) //将临时数组的内容复制到data中\n                data[j] = tmp[j];\n            radix = radix * 10;\n        }\n        delete []tmp;\n        delete []count;\n    }\n        \n    ```\n\n\n\n---\n\n资源引用声明：\n\n[维基百科](https://zh.wikipedia.org/wiki/)\n[简书：排序算法使用场景对比](https://www.jianshu.com/p/4db794bd7c1b)\n[八大排序算法总结与java实现](https://itimetraveler.github.io/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/)\n","slug":"八大排序算法总结","published":1,"updated":"2020-04-08T03:40:32.540Z","_id":"ck8qr69dp00195d3a1j9fbwao","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"直接插入排序算法\"><a class=\"markdownIt-Anchor\" href=\"#直接插入排序算法\"></a> 直接插入排序算法</h2>\n<ul>\n<li>概述<br>\n直接插入排序算法在逻辑上将整体数据分为两部分，一部分是已排序部分，另一部分是待排序部分 。<br>\n排序的过程是：在待排序部分逐步的拿出一个元素，将其插入到已排序部分中合理的位置 。</li>\n<li>适用场景<br>\n插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率，<br>\n但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 。</li>\n<li>优化<br>\n在给当前待排序元素在已排序部分找到一个合适的位置并且待排序数据相对较多的时候，由于已排序部分元素是有序的，因此这个过程可以使用二分法，以优化排序的时间复杂度。</li>\n<li>归类\n<ol>\n<li>in-place（原地算法：基本上不需要额外的空间）。</li>\n<li>稳定排序算法。</li>\n</ol>\n</li>\n<li>空间复杂度<br>\n直接插入排序是in-place，因此其空间复杂度是 O(1) 。</li>\n<li>时间复杂度\n<ul>\n<li>最优<br>\n最优的情况是待排序数据为已排序好的期望顺序，此时每次从待排序部分拿出一个元素只需要与待排序部分中最后一个元素相比较一次，需要比较 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.64444em;\"></span><span class=\"strut bottom\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span></span></span></span> 次，因此其复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span> 。</li>\n<li>最坏<br>\n最坏的情况是待排序数据为已排序好的，但是其顺序正好与期望顺序相反，此时每次从待排序部分拿出一个元素，该元素需要与其前面的已排序部分中的每一个元素进行比较和交换，其比较或交换的次数为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">0+1+2+...+(n-2)+(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathrm\">0</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">2</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">.</span><span class=\"mbin\">+</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">2</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span> 也就是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>∗</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n*(n-1)}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.01em;\"></span><span class=\"strut bottom\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord reset-textstyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.345em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathrm\">2</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.485em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mbin\">∗</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span> , 因此其复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mrow><mn>2</mn></mrow></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^{2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">n</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span>(是n方，恶心的渲染器) 。</li>\n<li>平均<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mrow><mn>2</mn></mrow></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^{2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">n</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n</li>\n<li>代码示例<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insertion_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i,j,key;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i=<span class=\"number\">1</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">                key = arr[i];</span><br><span class=\"line\">                j=i<span class=\"number\">-1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>((j&gt;=<span class=\"number\">0</span>) &amp;&amp; (arr[j]&gt;key)) &#123;</span><br><span class=\"line\">                        arr[j+<span class=\"number\">1</span>] = arr[j];</span><br><span class=\"line\">                        j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                arr[j+<span class=\"number\">1</span>] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"希尔排序算法\"><a class=\"markdownIt-Anchor\" href=\"#希尔排序算法\"></a> 希尔排序算法</h2>\n<ul>\n<li>概述<br>\n希尔排序是插入排序的一个优化版本，是在插入排序的基础上加入了分治的思想，按照设置好的步长进行跳跃式的插入排序，或者说按照步长将数据分为几个部分，分别对这几个部分进行排序。举个例子：有一组数据arr有10个元素，我们设步长为5，排序的开始，定位到首位元素，首位元素是他们组的第一个元素，它们组的第二位元素应该是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo>[</mo><mn>0</mn><mo>+</mo><mn>5</mn><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">arr[0+5]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">a</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">0</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">5</span><span class=\"mclose\">]</span></span></span></span> 也就是第5个元素。<br>\n<img src=\"1.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.webp\" alt=\"ShellSort\"></li>\n<li>适用场景<br>\n在shell先生的优化下，希尔排序不仅继承了插入排序的优点，而且可以做到对于数据量稍微大点的，无序的数据也能很快。</li>\n<li>归类\n<ol>\n<li>in-place（原地算法：基本上不需要额外的空间）。</li>\n<li>不稳定排序算法。</li>\n</ol>\n</li>\n<li>空间复杂度<br>\n与插入排序相同，它是一个原地算法，它的时间复杂度是线性的，也就是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span> 。</li>\n<li>时间复杂度<br>\n希尔排序的时间复杂度与步长的选取有关，当步长为1的时候，时间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mrow><mn>2</mn></mrow></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^{2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">n</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span> 。<br>\n当采用Sedgewick提出的步长（目前最好的步长序列）的时候，时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mrow><mi>n</mi></mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mn>2</mn></mrow></msub><mrow><mi>n</mi></mrow><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O({n}log_{2}{n})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">n</span></span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">o</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.03588em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathrm\">2</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">n</span></span><span class=\"mclose\">)</span></span></span></span> 。</li>\n<li>代码示例<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shell_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> gap, i, j;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (gap = len &gt;&gt; <span class=\"number\">1</span>; gap &gt; <span class=\"number\">0</span>; gap &gt;&gt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">\t\t\ttemp = arr[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (j = i - gap; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class=\"line\">\t\t\t\tarr[j + gap] = arr[j];</span><br><span class=\"line\">\t\t\tarr[j + gap] = temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"简单选择排序算法\"><a class=\"markdownIt-Anchor\" href=\"#简单选择排序算法\"></a> 简单选择排序算法</h2>\n<ul>\n<li>概述<br>\n选择排序依然是将待排序数据分为已排序区和待排序区。<br>\n排序的逻辑是每次从待排序区找出一个最大（或最小）的元素放置到已排序区的末尾。<br>\n选择排序算法是所有纯基于交换的排序算法中非常好的。</li>\n<li>归类\n<ol>\n<li>in-place（原地算法：基本上不需要额外的空间）。</li>\n<li>不稳定排序算法。</li>\n</ol>\n</li>\n<li>空间复杂度<br>\n它是一个原地算法，它的时间复杂度是线性的，也就是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span> 。</li>\n<li>时间复杂度<br>\n其最好、最坏和平均的时间复杂度都是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mrow><mn>2</mn></mrow></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^{2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">n</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span> 。</li>\n<li>代码示例<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">selection_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> len)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j,temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span> ; i &lt; len - <span class=\"number\">1</span> ; i++) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> min = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (j = i + <span class=\"number\">1</span>; j &lt; len; j++)     <span class=\"comment\">//走訪未排序的元素</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[j] &lt; a[min])    <span class=\"comment\">//找到目前最小值</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tmin = j;    <span class=\"comment\">//记录最小值</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttemp=a[min];</span><br><span class=\"line\">\t\ta[min]=a[i];</span><br><span class=\"line\">\t\ta[i]=temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"堆排序\"><a class=\"markdownIt-Anchor\" href=\"#堆排序\"></a> 堆排序</h2>\n<ul>\n<li>概述<br>\n堆排序也属于选择排序。<br>\n利用堆的特性对数据进行排序的一种排序算法。<br>\n排序的逻辑就是不断的从堆顶弹出一个元素，然后每次弹出一个元素后维护一下堆，当堆空的时候排序完成。</li>\n<li>适用场景</li>\n<li>归类\n<ol>\n<li>in-place（原地算法：基本上不需要额外的空间）。</li>\n<li>不稳定排序算法。</li>\n</ol>\n</li>\n<li>空间复杂度<br>\n堆排序属于原地算法，空间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>时间复杂度<br>\n平均时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">o</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>代码示例<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> *b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = *b;</span><br><span class=\"line\">    *b = *a;</span><br><span class=\"line\">    *a = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">max_heapify</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 建立父節點指標和子節點指標</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> dad = start;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> son = dad * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (son &lt;= end) &#123; <span class=\"comment\">// 若子節點指標在範圍內才做比較</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (son + <span class=\"number\">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class=\"number\">1</span>]) <span class=\"comment\">// 先比較兩個子節點大小，選擇最大的</span></span><br><span class=\"line\">            son++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[dad] &gt; arr[son]) <span class=\"comment\">//如果父節點大於子節點代表調整完畢，直接跳出函數</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 否則交換父子內容再繼續子節點和孫節點比较</span></span><br><span class=\"line\">            swap(&amp;arr[dad], &amp;arr[son]);</span><br><span class=\"line\">            dad = son;</span><br><span class=\"line\">            son = dad * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">heap_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化，i從最後一個父節點開始調整</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = len / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        max_heapify(arr, i, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 先將第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = len - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        swap(&amp;arr[<span class=\"number\">0</span>], &amp;arr[i]);</span><br><span class=\"line\">        max_heapify(arr, <span class=\"number\">0</span>, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[] = &#123; <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = (<span class=\"keyword\">int</span>) <span class=\"keyword\">sizeof</span>(arr) / <span class=\"keyword\">sizeof</span>(*arr);</span><br><span class=\"line\">    heap_sort(arr, len);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, arr[i]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"冒泡排序\"><a class=\"markdownIt-Anchor\" href=\"#冒泡排序\"></a> 冒泡排序</h2>\n<ul>\n<li>概述<br>\n冒泡排序是非常经典的一个纯粹基于交换的排序算法。<br>\n算法的基本逻辑是：对于n个待排序数据，有n次循环，每次循环从第一个元素开始与其后面的元素相比较，对相对位置不对的两个元素实施交换，循环结束后本次循环的末尾位置就是本次循环最大的元素，因此每次循环的长度都比上次循环次数少一。</li>\n<li>适用场景<br>\n基本有序，数量较少。</li>\n<li>归类\n<ol>\n<li>in-place（原地算法：基本上不需要额外的空间）。</li>\n<li>稳定排序算法。</li>\n</ol>\n</li>\n<li>时间复杂度<br>\n平均时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mrow><mn>2</mn></mrow></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^{2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">n</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度<br>\n原地算法，其空间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>比较次数<br>\n循环次数是n次，每次循环都能有一个当前最大的元素归位，因此每次循环的长度都比上次循环次数少一，那么对于n个待排序数据，其比较次数就是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>+</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">(n-1) + (n - 2) + ... + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">2</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">.</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span></span></span></span></li>\n<li>代码示例<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ARR_LEN 255 <span class=\"comment\">/* 數組長度上限 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> elemType int <span class=\"comment\">/* 元素類型 */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 泡沫排序 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 1. 從當前元素起，向後依次比較每一對相鄰元素，若逆序則互換 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 2. 對所有元素均重複以上步驟，直至最後一個元素 */</span></span><br><span class=\"line\"><span class=\"comment\">/* elemType arr[]: 排序目標數組; int len: 元素個數 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span> <span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, j,temp;</span><br><span class=\"line\">\tBoolean exchanged = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; exchanged &amp;&amp; i&lt;len<span class=\"number\">-1</span>; i++) <span class=\"comment\">/* 外迴圈為排序趟數，len個數進行len-1趟,只有交換過,exchanged值為true才有執行迴圈的必要,否則exchanged值為false不執行迴圈 */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (j=<span class=\"number\">0</span>; j&lt;len<span class=\"number\">-1</span>-i; j++) </span><br><span class=\"line\">\t\t&#123; <span class=\"comment\">/* 內迴圈為每趟比較的次數，第i趟比較len-i次  */</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\texchanged = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123; <span class=\"comment\">/* 相鄰元素比較，若逆序則互換（升序為左大於右，逆序反之） */</span></span><br><span class=\"line\">\t\t\t\ttemp = arr[j];</span><br><span class=\"line\">\t\t\t\tarr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t\tarr[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">\t\t\t\texchanged = <span class=\"literal\">true</span>; <span class=\"comment\">/*只有數值互換過, exchanged才會從false變成true,否則數列已經排序完成,exchanged值仍然為false,沒必要排序 */</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[ARR_LEN] = &#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">-7</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"number\">-6</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tbubbleSort (arr, len);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;len; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span> (<span class=\"string\">\"%d\\t\"</span>, arr[i]);</span><br><span class=\"line\">\t<span class=\"built_in\">putchar</span> (<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"快速排序\"><a class=\"markdownIt-Anchor\" href=\"#快速排序\"></a> 快速排序</h2>\n<ul>\n<li>概述<br>\n快速排序也是非常经典而且很实用的一种排序算法，该算法采用了分治的思想。<br>\n算法的基本逻辑是每次从当前排序区域挑选出一个基准值，通过不断的交换使得基准值左边的数据都比基准值小(或大),右边相反，<br>\n然后以基准值为分割，递归的对两个部分分别进行上述交换。</li>\n<li>适用场景<br>\n数据量较大且混乱程度较高。</li>\n<li>归类\n<ol>\n<li>in-place（原地算法：基本上不需要额外的空间）。</li>\n<li>不稳定排序算法。</li>\n</ol>\n</li>\n<li>时间复杂度<br>\n平均时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">o</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度<br>\n原地算法，其空间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>代码示例<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">Range</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> start, end;</span><br><span class=\"line\">&#125; Range;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Range <span class=\"title\">new_Range</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e)</span> </span>&#123;</span><br><span class=\"line\">    Range r;</span><br><span class=\"line\">    r.start = s;</span><br><span class=\"line\">    r.end = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *x, <span class=\"keyword\">int</span> *y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = *x;</span><br><span class=\"line\">    *x = *y;</span><br><span class=\"line\">    *y = t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>; <span class=\"comment\">// 避免len等於負值時引發段錯誤（Segment Fault）</span></span><br><span class=\"line\">    <span class=\"comment\">// r[]模擬列表,p為數量,r[p++]為push,r[--p]為pop且取得元素</span></span><br><span class=\"line\">    Range r[len];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">    r[p++] = new_Range(<span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p) &#123;</span><br><span class=\"line\">        Range range = r[--p];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.start &gt;= range.end)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = arr[(range.start + range.end) / <span class=\"number\">2</span>]; <span class=\"comment\">// 選取中間點為基準點</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = range.start, right = range.end;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (arr[left] &lt; mid) ++left;   <span class=\"comment\">// 檢測基準點左側是否符合要求</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (arr[right] &gt; mid) --right; <span class=\"comment\">//檢測基準點右側是否符合要求</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left &lt;= right) &#123;</span><br><span class=\"line\">                swap(&amp;arr[left], &amp;arr[right]);</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                right--;               <span class=\"comment\">// 移動指針以繼續</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (left &lt;= right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.start &lt; right) r[p++] = new_Range(range.start, right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.end &gt; left) r[p++] = new_Range(left, range.end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"归并排序\"><a class=\"markdownIt-Anchor\" href=\"#归并排序\"></a> 归并排序</h2>\n<ul>\n<li>概述<br>\n归并排序是分治思想的经典应用。<br>\n归并排序分为两种操作：<br>\n1. 分割：当前待排序数据分割为两部分。<br>\n2. 合并：在保持排序顺序的情况下将两部分合并。<br>\n递归方式：<br>\n1. 不断的对待排序数据进行递归式的平均分割，直到当前数据不多于2个为止。<br>\n2. 对当前待排序数据进行均等分割，不断的分别从两个部分中拿出两个元素进行比较，然后按照排序顺序放置到临时区域，如此对两部分进行合并。<br>\n迭代方式：<br>\n1. 对于待排序数据两两进行按照排序顺序交换。<br>\n2. 对于上述得出的若干两个元素组成的数对再次进行与递归方式相同的归并操作。<br>\n3. 如此反复，直到只剩一个部分为止。</li>\n<li>适用场景<br>\n与快速排序相同，适用于数据量较大并且较为混乱的情况。</li>\n<li>归类<br>\n稳定排序算法。</li>\n<li>时间复杂度<br>\n平均时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">o</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度<br>\n由于进行归并操作的时候需要借助额外的临时空间存储归并后的数据，而这些数据也正是原数据，因此空间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>代码示例<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 迭代方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &lt; y ? x : y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *a = arr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *b = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>(len * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> seg, start;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (seg = <span class=\"number\">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (start = <span class=\"number\">0</span>; start &lt; len; start += seg * <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> low = start, mid = min(start + seg, len), high = min(start + seg * <span class=\"number\">2</span>, len);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> k = low;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> start1 = low, end1 = mid;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> start2 = mid, end2 = high;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class=\"line\">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (start1 &lt; end1)</span><br><span class=\"line\">                b[k++] = a[start1++];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (start2 &lt; end2)</span><br><span class=\"line\">                b[k++] = a[start2++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> *temp = a;</span><br><span class=\"line\">        a = b;</span><br><span class=\"line\">        b = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++)</span><br><span class=\"line\">            b[i] = a[i];</span><br><span class=\"line\">        b = a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 归并方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort_recursive</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> reg[], <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &gt;= end)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = end - start, mid = (len &gt;&gt; <span class=\"number\">1</span>) + start;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start1 = start, end1 = mid;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start2 = mid + <span class=\"number\">1</span>, end2 = end;</span><br><span class=\"line\">    merge_sort_recursive(arr, reg, start1, end1);</span><br><span class=\"line\">    merge_sort_recursive(arr, reg, start2, end2);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = start;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class=\"line\">        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start1 &lt;= end1)</span><br><span class=\"line\">        reg[k++] = arr[start1++];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start2 &lt;= end2)</span><br><span class=\"line\">        reg[k++] = arr[start2++];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (k = start; k &lt;= end; k++)</span><br><span class=\"line\">        arr[k] = reg[k];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> reg[len];</span><br><span class=\"line\">    merge_sort_recursive(arr, reg, <span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"基数排序\"><a class=\"markdownIt-Anchor\" href=\"#基数排序\"></a> 基数排序</h2>\n<ul>\n<li>概述<br>\n基数排序是比较特殊的一种排序方法，是唯一的一个不是基于交换的排序算法。<br>\n其基本思想是按照待排序数据的每一位进行排序，进行若干次排序。<br>\n基数排序有两种排序方式，一种是从低位到高位排序(LSD), 另一种是从高位到低位排序(MSD)。<br>\n这里提到的每一位，可以是任意进制的每一位，而位数的选择也直接影响其时间复杂度与空间复杂度。</li>\n<li>归类<br>\n稳定排序算法</li>\n<li>时间复杂度<br>\n基数排序的时间复杂度受到位数的影响，也就是说有多少位当然也就需要排序多少次，因此其时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n * k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">∗</span><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>，其中k是位数。</li>\n<li>空间复杂度<br>\n每一位的数字的种类就是以什么样的方式来选择位数，分割每一位，若以十进制来分割每一位，那么每一位的数字的种类就有十种。<br>\n在对每一位进行排序的时候，就需要类似桶排序的方式进行。<br>\n因此，其空间复杂度就是这若干个“桶”，也就是位数，再加上存储待排序数据的数据结构<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n * k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">∗</span><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>，k为位数。</li>\n<li>代码示例<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxbit</span><span class=\"params\">(<span class=\"keyword\">int</span> data[], <span class=\"keyword\">int</span> n)</span> <span class=\"comment\">//辅助函数，求数据的最大位数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxData = data[<span class=\"number\">0</span>];\t\t<span class=\"comment\">///&lt; 最大数</span></span><br><span class=\"line\">    <span class=\"comment\">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxData &lt; data[i])</span><br><span class=\"line\">            maxData = data[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> d = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (maxData &gt;= p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//p *= 10; // Maybe overflow</span></span><br><span class=\"line\">        maxData /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        ++d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d;</span><br><span class=\"line\"><span class=\"comment\">/*    int d = 1; //保存最大的位数</span></span><br><span class=\"line\"><span class=\"comment\">    int p = 10;</span></span><br><span class=\"line\"><span class=\"comment\">    for(int i = 0; i &lt; n; ++i)</span></span><br><span class=\"line\"><span class=\"comment\">    &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        while(data[i] &gt;= p)</span></span><br><span class=\"line\"><span class=\"comment\">        &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            p *= 10;</span></span><br><span class=\"line\"><span class=\"comment\">            ++d;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    return d;*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">radixsort</span><span class=\"params\">(<span class=\"keyword\">int</span> data[], <span class=\"keyword\">int</span> n)</span> <span class=\"comment\">//基数排序</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> d = maxbit(data, n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *tmp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>]; <span class=\"comment\">//计数器</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j, k;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> radix = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; i &lt;= d; i++) <span class=\"comment\">//进行d次排序</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++)</span><br><span class=\"line\">            count[j] = <span class=\"number\">0</span>; <span class=\"comment\">//每次分配前清空计数器</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            k = (data[j] / radix) % <span class=\"number\">10</span>; <span class=\"comment\">//统计每个桶中的记录数</span></span><br><span class=\"line\">            count[k]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">1</span>; j &lt; <span class=\"number\">10</span>; j++)</span><br><span class=\"line\">            count[j] = count[j - <span class=\"number\">1</span>] + count[j]; <span class=\"comment\">//将tmp中的位置依次分配给每个桶</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = n - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) <span class=\"comment\">//将所有桶中记录依次收集到tmp中</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            k = (data[j] / radix) % <span class=\"number\">10</span>;</span><br><span class=\"line\">            tmp[count[k] - <span class=\"number\">1</span>] = data[j];</span><br><span class=\"line\">            count[k]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; n; j++) <span class=\"comment\">//将临时数组的内容复制到data中</span></span><br><span class=\"line\">            data[j] = tmp[j];</span><br><span class=\"line\">        radix = radix * <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> []tmp;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> []count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>资源引用声明：</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/\" target=\"_blank\" rel=\"noopener\">维基百科</a><br>\n<a href=\"https://www.jianshu.com/p/4db794bd7c1b\" target=\"_blank\" rel=\"noopener\">简书：排序算法使用场景对比</a><br>\n<a href=\"https://itimetraveler.github.io/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/\" target=\"_blank\" rel=\"noopener\">八大排序算法总结与java实现</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"直接插入排序算法\"><a class=\"markdownIt-Anchor\" href=\"#直接插入排序算法\"></a> 直接插入排序算法</h2>\n<ul>\n<li>概述<br>\n直接插入排序算法在逻辑上将整体数据分为两部分，一部分是已排序部分，另一部分是待排序部分 。<br>\n排序的过程是：在待排序部分逐步的拿出一个元素，将其插入到已排序部分中合理的位置 。</li>\n<li>适用场景<br>\n插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率，<br>\n但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 。</li>\n<li>优化<br>\n在给当前待排序元素在已排序部分找到一个合适的位置并且待排序数据相对较多的时候，由于已排序部分元素是有序的，因此这个过程可以使用二分法，以优化排序的时间复杂度。</li>\n<li>归类\n<ol>\n<li>in-place（原地算法：基本上不需要额外的空间）。</li>\n<li>稳定排序算法。</li>\n</ol>\n</li>\n<li>空间复杂度<br>\n直接插入排序是in-place，因此其空间复杂度是 O(1) 。</li>\n<li>时间复杂度\n<ul>\n<li>最优<br>\n最优的情况是待排序数据为已排序好的期望顺序，此时每次从待排序部分拿出一个元素只需要与待排序部分中最后一个元素相比较一次，需要比较 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.64444em;\"></span><span class=\"strut bottom\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span></span></span></span> 次，因此其复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span> 。</li>\n<li>最坏<br>\n最坏的情况是待排序数据为已排序好的，但是其顺序正好与期望顺序相反，此时每次从待排序部分拿出一个元素，该元素需要与其前面的已排序部分中的每一个元素进行比较和交换，其比较或交换的次数为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">0+1+2+...+(n-2)+(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathrm\">0</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">2</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">.</span><span class=\"mbin\">+</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">2</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span> 也就是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>∗</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n*(n-1)}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:1.01em;\"></span><span class=\"strut bottom\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord reset-textstyle textstyle uncramped\"><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist\"><span style=\"top:0.345em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathrm\">2</span></span></span></span><span style=\"top:-0.22999999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle textstyle uncramped frac-line\"></span></span><span style=\"top:-0.485em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mbin\">∗</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span> , 因此其复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mrow><mn>2</mn></mrow></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^{2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">n</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span>(是n方，恶心的渲染器) 。</li>\n<li>平均<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mrow><mn>2</mn></mrow></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^{2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">n</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n</li>\n<li>代码示例<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insertion_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i,j,key;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i=<span class=\"number\">1</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">                key = arr[i];</span><br><span class=\"line\">                j=i<span class=\"number\">-1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>((j&gt;=<span class=\"number\">0</span>) &amp;&amp; (arr[j]&gt;key)) &#123;</span><br><span class=\"line\">                        arr[j+<span class=\"number\">1</span>] = arr[j];</span><br><span class=\"line\">                        j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                arr[j+<span class=\"number\">1</span>] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"希尔排序算法\"><a class=\"markdownIt-Anchor\" href=\"#希尔排序算法\"></a> 希尔排序算法</h2>\n<ul>\n<li>概述<br>\n希尔排序是插入排序的一个优化版本，是在插入排序的基础上加入了分治的思想，按照设置好的步长进行跳跃式的插入排序，或者说按照步长将数据分为几个部分，分别对这几个部分进行排序。举个例子：有一组数据arr有10个元素，我们设步长为5，排序的开始，定位到首位元素，首位元素是他们组的第一个元素，它们组的第二位元素应该是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo>[</mo><mn>0</mn><mo>+</mo><mn>5</mn><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">arr[0+5]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">a</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">0</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">5</span><span class=\"mclose\">]</span></span></span></span> 也就是第5个元素。<br>\n<img src=\"1.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.webp\" alt=\"ShellSort\"></li>\n<li>适用场景<br>\n在shell先生的优化下，希尔排序不仅继承了插入排序的优点，而且可以做到对于数据量稍微大点的，无序的数据也能很快。</li>\n<li>归类\n<ol>\n<li>in-place（原地算法：基本上不需要额外的空间）。</li>\n<li>不稳定排序算法。</li>\n</ol>\n</li>\n<li>空间复杂度<br>\n与插入排序相同，它是一个原地算法，它的时间复杂度是线性的，也就是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span> 。</li>\n<li>时间复杂度<br>\n希尔排序的时间复杂度与步长的选取有关，当步长为1的时候，时间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mrow><mn>2</mn></mrow></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^{2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">n</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span> 。<br>\n当采用Sedgewick提出的步长（目前最好的步长序列）的时候，时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mrow><mi>n</mi></mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mn>2</mn></mrow></msub><mrow><mi>n</mi></mrow><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O({n}log_{2}{n})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">n</span></span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">o</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"vlist\"><span style=\"top:0.15em;margin-right:0.05em;margin-left:-0.03588em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle cramped\"><span class=\"mord scriptstyle cramped\"><span class=\"mord mathrm\">2</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">n</span></span><span class=\"mclose\">)</span></span></span></span> 。</li>\n<li>代码示例<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shell_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> gap, i, j;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (gap = len &gt;&gt; <span class=\"number\">1</span>; gap &gt; <span class=\"number\">0</span>; gap &gt;&gt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">\t\t\ttemp = arr[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (j = i - gap; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class=\"line\">\t\t\t\tarr[j + gap] = arr[j];</span><br><span class=\"line\">\t\t\tarr[j + gap] = temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"简单选择排序算法\"><a class=\"markdownIt-Anchor\" href=\"#简单选择排序算法\"></a> 简单选择排序算法</h2>\n<ul>\n<li>概述<br>\n选择排序依然是将待排序数据分为已排序区和待排序区。<br>\n排序的逻辑是每次从待排序区找出一个最大（或最小）的元素放置到已排序区的末尾。<br>\n选择排序算法是所有纯基于交换的排序算法中非常好的。</li>\n<li>归类\n<ol>\n<li>in-place（原地算法：基本上不需要额外的空间）。</li>\n<li>不稳定排序算法。</li>\n</ol>\n</li>\n<li>空间复杂度<br>\n它是一个原地算法，它的时间复杂度是线性的，也就是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span> 。</li>\n<li>时间复杂度<br>\n其最好、最坏和平均的时间复杂度都是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mrow><mn>2</mn></mrow></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^{2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">n</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span> 。</li>\n<li>代码示例<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">selection_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> len)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j,temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span> ; i &lt; len - <span class=\"number\">1</span> ; i++) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> min = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (j = i + <span class=\"number\">1</span>; j &lt; len; j++)     <span class=\"comment\">//走訪未排序的元素</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[j] &lt; a[min])    <span class=\"comment\">//找到目前最小值</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tmin = j;    <span class=\"comment\">//记录最小值</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttemp=a[min];</span><br><span class=\"line\">\t\ta[min]=a[i];</span><br><span class=\"line\">\t\ta[i]=temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"堆排序\"><a class=\"markdownIt-Anchor\" href=\"#堆排序\"></a> 堆排序</h2>\n<ul>\n<li>概述<br>\n堆排序也属于选择排序。<br>\n利用堆的特性对数据进行排序的一种排序算法。<br>\n排序的逻辑就是不断的从堆顶弹出一个元素，然后每次弹出一个元素后维护一下堆，当堆空的时候排序完成。</li>\n<li>适用场景</li>\n<li>归类\n<ol>\n<li>in-place（原地算法：基本上不需要额外的空间）。</li>\n<li>不稳定排序算法。</li>\n</ol>\n</li>\n<li>空间复杂度<br>\n堆排序属于原地算法，空间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>时间复杂度<br>\n平均时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">o</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>代码示例<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> *b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = *b;</span><br><span class=\"line\">    *b = *a;</span><br><span class=\"line\">    *a = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">max_heapify</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 建立父節點指標和子節點指標</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> dad = start;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> son = dad * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (son &lt;= end) &#123; <span class=\"comment\">// 若子節點指標在範圍內才做比較</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (son + <span class=\"number\">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class=\"number\">1</span>]) <span class=\"comment\">// 先比較兩個子節點大小，選擇最大的</span></span><br><span class=\"line\">            son++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[dad] &gt; arr[son]) <span class=\"comment\">//如果父節點大於子節點代表調整完畢，直接跳出函數</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 否則交換父子內容再繼續子節點和孫節點比较</span></span><br><span class=\"line\">            swap(&amp;arr[dad], &amp;arr[son]);</span><br><span class=\"line\">            dad = son;</span><br><span class=\"line\">            son = dad * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">heap_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化，i從最後一個父節點開始調整</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = len / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        max_heapify(arr, i, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 先將第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = len - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        swap(&amp;arr[<span class=\"number\">0</span>], &amp;arr[i]);</span><br><span class=\"line\">        max_heapify(arr, <span class=\"number\">0</span>, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[] = &#123; <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = (<span class=\"keyword\">int</span>) <span class=\"keyword\">sizeof</span>(arr) / <span class=\"keyword\">sizeof</span>(*arr);</span><br><span class=\"line\">    heap_sort(arr, len);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, arr[i]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"冒泡排序\"><a class=\"markdownIt-Anchor\" href=\"#冒泡排序\"></a> 冒泡排序</h2>\n<ul>\n<li>概述<br>\n冒泡排序是非常经典的一个纯粹基于交换的排序算法。<br>\n算法的基本逻辑是：对于n个待排序数据，有n次循环，每次循环从第一个元素开始与其后面的元素相比较，对相对位置不对的两个元素实施交换，循环结束后本次循环的末尾位置就是本次循环最大的元素，因此每次循环的长度都比上次循环次数少一。</li>\n<li>适用场景<br>\n基本有序，数量较少。</li>\n<li>归类\n<ol>\n<li>in-place（原地算法：基本上不需要额外的空间）。</li>\n<li>稳定排序算法。</li>\n</ol>\n</li>\n<li>时间复杂度<br>\n平均时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mrow><mn>2</mn></mrow></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^{2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">n</span><span class=\"vlist\"><span style=\"top:-0.363em;margin-right:0.05em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"reset-textstyle scriptstyle uncramped\"><span class=\"mord scriptstyle uncramped\"><span class=\"mord mathrm\">2</span></span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度<br>\n原地算法，其空间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>比较次数<br>\n循环次数是n次，每次循环都能有一个当前最大的元素归位，因此每次循环的长度都比上次循环次数少一，那么对于n个待排序数据，其比较次数就是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>+</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">(n-1) + (n - 2) + ... + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathrm\">2</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">.</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span></span></span></span></li>\n<li>代码示例<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ARR_LEN 255 <span class=\"comment\">/* 數組長度上限 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> elemType int <span class=\"comment\">/* 元素類型 */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 泡沫排序 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 1. 從當前元素起，向後依次比較每一對相鄰元素，若逆序則互換 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 2. 對所有元素均重複以上步驟，直至最後一個元素 */</span></span><br><span class=\"line\"><span class=\"comment\">/* elemType arr[]: 排序目標數組; int len: 元素個數 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span> <span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, j,temp;</span><br><span class=\"line\">\tBoolean exchanged = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; exchanged &amp;&amp; i&lt;len<span class=\"number\">-1</span>; i++) <span class=\"comment\">/* 外迴圈為排序趟數，len個數進行len-1趟,只有交換過,exchanged值為true才有執行迴圈的必要,否則exchanged值為false不執行迴圈 */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (j=<span class=\"number\">0</span>; j&lt;len<span class=\"number\">-1</span>-i; j++) </span><br><span class=\"line\">\t\t&#123; <span class=\"comment\">/* 內迴圈為每趟比較的次數，第i趟比較len-i次  */</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\texchanged = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123; <span class=\"comment\">/* 相鄰元素比較，若逆序則互換（升序為左大於右，逆序反之） */</span></span><br><span class=\"line\">\t\t\t\ttemp = arr[j];</span><br><span class=\"line\">\t\t\t\tarr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t\tarr[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">\t\t\t\texchanged = <span class=\"literal\">true</span>; <span class=\"comment\">/*只有數值互換過, exchanged才會從false變成true,否則數列已經排序完成,exchanged值仍然為false,沒必要排序 */</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[ARR_LEN] = &#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">-7</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"number\">-6</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tbubbleSort (arr, len);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;len; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span> (<span class=\"string\">\"%d\\t\"</span>, arr[i]);</span><br><span class=\"line\">\t<span class=\"built_in\">putchar</span> (<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"快速排序\"><a class=\"markdownIt-Anchor\" href=\"#快速排序\"></a> 快速排序</h2>\n<ul>\n<li>概述<br>\n快速排序也是非常经典而且很实用的一种排序算法，该算法采用了分治的思想。<br>\n算法的基本逻辑是每次从当前排序区域挑选出一个基准值，通过不断的交换使得基准值左边的数据都比基准值小(或大),右边相反，<br>\n然后以基准值为分割，递归的对两个部分分别进行上述交换。</li>\n<li>适用场景<br>\n数据量较大且混乱程度较高。</li>\n<li>归类\n<ol>\n<li>in-place（原地算法：基本上不需要额外的空间）。</li>\n<li>不稳定排序算法。</li>\n</ol>\n</li>\n<li>时间复杂度<br>\n平均时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">o</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度<br>\n原地算法，其空间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>代码示例<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">Range</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> start, end;</span><br><span class=\"line\">&#125; Range;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Range <span class=\"title\">new_Range</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e)</span> </span>&#123;</span><br><span class=\"line\">    Range r;</span><br><span class=\"line\">    r.start = s;</span><br><span class=\"line\">    r.end = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *x, <span class=\"keyword\">int</span> *y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = *x;</span><br><span class=\"line\">    *x = *y;</span><br><span class=\"line\">    *y = t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>; <span class=\"comment\">// 避免len等於負值時引發段錯誤（Segment Fault）</span></span><br><span class=\"line\">    <span class=\"comment\">// r[]模擬列表,p為數量,r[p++]為push,r[--p]為pop且取得元素</span></span><br><span class=\"line\">    Range r[len];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">    r[p++] = new_Range(<span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p) &#123;</span><br><span class=\"line\">        Range range = r[--p];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.start &gt;= range.end)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = arr[(range.start + range.end) / <span class=\"number\">2</span>]; <span class=\"comment\">// 選取中間點為基準點</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = range.start, right = range.end;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (arr[left] &lt; mid) ++left;   <span class=\"comment\">// 檢測基準點左側是否符合要求</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (arr[right] &gt; mid) --right; <span class=\"comment\">//檢測基準點右側是否符合要求</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left &lt;= right) &#123;</span><br><span class=\"line\">                swap(&amp;arr[left], &amp;arr[right]);</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                right--;               <span class=\"comment\">// 移動指針以繼續</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (left &lt;= right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.start &lt; right) r[p++] = new_Range(range.start, right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.end &gt; left) r[p++] = new_Range(left, range.end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"归并排序\"><a class=\"markdownIt-Anchor\" href=\"#归并排序\"></a> 归并排序</h2>\n<ul>\n<li>概述<br>\n归并排序是分治思想的经典应用。<br>\n归并排序分为两种操作：<br>\n1. 分割：当前待排序数据分割为两部分。<br>\n2. 合并：在保持排序顺序的情况下将两部分合并。<br>\n递归方式：<br>\n1. 不断的对待排序数据进行递归式的平均分割，直到当前数据不多于2个为止。<br>\n2. 对当前待排序数据进行均等分割，不断的分别从两个部分中拿出两个元素进行比较，然后按照排序顺序放置到临时区域，如此对两部分进行合并。<br>\n迭代方式：<br>\n1. 对于待排序数据两两进行按照排序顺序交换。<br>\n2. 对于上述得出的若干两个元素组成的数对再次进行与递归方式相同的归并操作。<br>\n3. 如此反复，直到只剩一个部分为止。</li>\n<li>适用场景<br>\n与快速排序相同，适用于数据量较大并且较为混乱的情况。</li>\n<li>归类<br>\n稳定排序算法。</li>\n<li>时间复杂度<br>\n平均时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">o</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度<br>\n由于进行归并操作的时候需要借助额外的临时空间存储归并后的数据，而这些数据也正是原数据，因此空间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n<li>代码示例<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 迭代方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &lt; y ? x : y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *a = arr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *b = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>(len * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> seg, start;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (seg = <span class=\"number\">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (start = <span class=\"number\">0</span>; start &lt; len; start += seg * <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> low = start, mid = min(start + seg, len), high = min(start + seg * <span class=\"number\">2</span>, len);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> k = low;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> start1 = low, end1 = mid;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> start2 = mid, end2 = high;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class=\"line\">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (start1 &lt; end1)</span><br><span class=\"line\">                b[k++] = a[start1++];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (start2 &lt; end2)</span><br><span class=\"line\">                b[k++] = a[start2++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> *temp = a;</span><br><span class=\"line\">        a = b;</span><br><span class=\"line\">        b = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++)</span><br><span class=\"line\">            b[i] = a[i];</span><br><span class=\"line\">        b = a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 归并方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort_recursive</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> reg[], <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &gt;= end)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = end - start, mid = (len &gt;&gt; <span class=\"number\">1</span>) + start;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start1 = start, end1 = mid;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start2 = mid + <span class=\"number\">1</span>, end2 = end;</span><br><span class=\"line\">    merge_sort_recursive(arr, reg, start1, end1);</span><br><span class=\"line\">    merge_sort_recursive(arr, reg, start2, end2);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = start;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class=\"line\">        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start1 &lt;= end1)</span><br><span class=\"line\">        reg[k++] = arr[start1++];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start2 &lt;= end2)</span><br><span class=\"line\">        reg[k++] = arr[start2++];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (k = start; k &lt;= end; k++)</span><br><span class=\"line\">        arr[k] = reg[k];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> reg[len];</span><br><span class=\"line\">    merge_sort_recursive(arr, reg, <span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"基数排序\"><a class=\"markdownIt-Anchor\" href=\"#基数排序\"></a> 基数排序</h2>\n<ul>\n<li>概述<br>\n基数排序是比较特殊的一种排序方法，是唯一的一个不是基于交换的排序算法。<br>\n其基本思想是按照待排序数据的每一位进行排序，进行若干次排序。<br>\n基数排序有两种排序方式，一种是从低位到高位排序(LSD), 另一种是从高位到低位排序(MSD)。<br>\n这里提到的每一位，可以是任意进制的每一位，而位数的选择也直接影响其时间复杂度与空间复杂度。</li>\n<li>归类<br>\n稳定排序算法</li>\n<li>时间复杂度<br>\n基数排序的时间复杂度受到位数的影响，也就是说有多少位当然也就需要排序多少次，因此其时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n * k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">∗</span><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>，其中k是位数。</li>\n<li>空间复杂度<br>\n每一位的数字的种类就是以什么样的方式来选择位数，分割每一位，若以十进制来分割每一位，那么每一位的数字的种类就有十种。<br>\n在对每一位进行排序的时候，就需要类似桶排序的方式进行。<br>\n因此，其空间复杂度就是这若干个“桶”，也就是位数，再加上存储待排序数据的数据结构<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n * k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">∗</span><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>，k为位数。</li>\n<li>代码示例<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxbit</span><span class=\"params\">(<span class=\"keyword\">int</span> data[], <span class=\"keyword\">int</span> n)</span> <span class=\"comment\">//辅助函数，求数据的最大位数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxData = data[<span class=\"number\">0</span>];\t\t<span class=\"comment\">///&lt; 最大数</span></span><br><span class=\"line\">    <span class=\"comment\">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxData &lt; data[i])</span><br><span class=\"line\">            maxData = data[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> d = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (maxData &gt;= p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//p *= 10; // Maybe overflow</span></span><br><span class=\"line\">        maxData /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        ++d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d;</span><br><span class=\"line\"><span class=\"comment\">/*    int d = 1; //保存最大的位数</span></span><br><span class=\"line\"><span class=\"comment\">    int p = 10;</span></span><br><span class=\"line\"><span class=\"comment\">    for(int i = 0; i &lt; n; ++i)</span></span><br><span class=\"line\"><span class=\"comment\">    &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        while(data[i] &gt;= p)</span></span><br><span class=\"line\"><span class=\"comment\">        &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            p *= 10;</span></span><br><span class=\"line\"><span class=\"comment\">            ++d;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    return d;*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">radixsort</span><span class=\"params\">(<span class=\"keyword\">int</span> data[], <span class=\"keyword\">int</span> n)</span> <span class=\"comment\">//基数排序</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> d = maxbit(data, n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *tmp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>]; <span class=\"comment\">//计数器</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j, k;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> radix = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; i &lt;= d; i++) <span class=\"comment\">//进行d次排序</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++)</span><br><span class=\"line\">            count[j] = <span class=\"number\">0</span>; <span class=\"comment\">//每次分配前清空计数器</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            k = (data[j] / radix) % <span class=\"number\">10</span>; <span class=\"comment\">//统计每个桶中的记录数</span></span><br><span class=\"line\">            count[k]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">1</span>; j &lt; <span class=\"number\">10</span>; j++)</span><br><span class=\"line\">            count[j] = count[j - <span class=\"number\">1</span>] + count[j]; <span class=\"comment\">//将tmp中的位置依次分配给每个桶</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = n - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) <span class=\"comment\">//将所有桶中记录依次收集到tmp中</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            k = (data[j] / radix) % <span class=\"number\">10</span>;</span><br><span class=\"line\">            tmp[count[k] - <span class=\"number\">1</span>] = data[j];</span><br><span class=\"line\">            count[k]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; n; j++) <span class=\"comment\">//将临时数组的内容复制到data中</span></span><br><span class=\"line\">            data[j] = tmp[j];</span><br><span class=\"line\">        radix = radix * <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> []tmp;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> []count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>资源引用声明：</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/\" target=\"_blank\" rel=\"noopener\">维基百科</a><br>\n<a href=\"https://www.jianshu.com/p/4db794bd7c1b\" target=\"_blank\" rel=\"noopener\">简书：排序算法使用场景对比</a><br>\n<a href=\"https://itimetraveler.github.io/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/\" target=\"_blank\" rel=\"noopener\">八大排序算法总结与java实现</a></p>\n"},{"title":"进程、线程及共享内存学习笔记","date":"2019-09-02T08:40:51.000Z","cover":"title.jpg","_content":"\n## 进程、线程及共享内存学习笔记\n> 系统环境：deepin Linux，语言环境：Linux C\n> 欢迎大家转载，转载请注明出处，谢谢！\n\n1. 理论基础：\n\n   * 进程：计算机上每个执行的活动，运行一个可执行程序是一个进程，打开一个软件是一个进程，打开一个终端是一个进程等等。\n   * 多进程：为了充分利用计算机资源产生了多进程的执行方式。通俗来讲就是在同一时间做多个事情，从而可以充分利用计算机资源还可以提高程序的执行效率。在创建一个新的子进程后，子进程会会获得计算机分配的资源，并拷贝父进程的数据。\n   * 子进程与父进程：我们编写的一段程序运行时就是一个进程，当我们在这段代码中调用特定函数新创建一个进程时，新创建的进程就是当前进程的子进程，而对于新创建的进程来说，当前进程就是它的父进程，子进程通过拷贝等手段继承父进程在创建子进程之前的数据、属性等。\n   * 多线程：上面说到进程是计算机上执行的每个活动。在实际编程中，一个进程中会有很多任务需要做。从而引发思考：一个进程中的多个任务是否也可以并发的执行？因为有些任务之间是没有联系的，也就是说有些任务完全可以同时进行而没有依赖问题。答案就是线程。与多进程相同的是，多线程也是为了让计算机资源得到充分利用并且程序的执行效率也会得到提高，与多进程不同的是，多线程并没有拷贝这种需求，它实际上是把一个进程分成多个片段。\n   * 重入性：尽管多线程系统开销少，但是也难免有缺陷，那就是重入性问题，使用多线程编程需要保证被多线程多次执行的函数的可重入性，所谓重入性就是函数被多个线程多次调用皆能正常执行。见附录2，有几个保证函数可重入性的条件。\n   * 线程安全：使用多线程编程除了需要保证函数的可重入性还需要保证线程安全，另外，可重入的函数一定是 线程安全的，但是反之不成立。\n   * 共享内存：根据字面意思就很好理解，通过把不同的进程中的逻辑内存映射到同一块物理内存中，进而允许两个进程共享同一块逻辑内存空间。它是进程间通信的一种方式。共享内存本身并没有提供同步机制。\n\n2. 相关函数：\n\n   * 多进程相关：\n\n     1. `fork()`：\n\n        * 原型：\n\n          ```c\n          #include <sys/types.h>\n          #include <unistd.h>\n          \n          pid_t fork(void);\n          ```\n\n        * 说明：\n\n          通过复制调用者来创建新进程。这个新的进程简称为子进程。调用该函数的进程称为父进程。\n\n          子进程和父进程运行在不同的内存空间中。在调用该函数的时候，两个进程内存空间都拥有相同的内容。其中一个进程执行的内存写入，文件映射和解除映射操作不会影响到另一个进程。该函数的返回值在父子进程中不同，在父进程中返回子进程PID，在子进程中返回0。\n\n     2. `wait()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <sys/types.h>\n          #include <sys/wait.h>\n          \n          pid_t wait(int *stat_loc);\n          ```\n\n        * 函数说明：\n\n          当调用这个函数的时候，当前进程会阻塞等待，该进程的某个子进程运行结束为止。\n          该结束的子进程的返回状态被存储在wait()函数的参数stat_loc变量中。\n\n     3. `system();`\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <stdlib.h>\n          #include <stdio.h>\n          int system(char *command);\n          ```\n\n        * 函数说明：\n\n          创建新的进程，执行制定命令。\n\n     4. exec函数族：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <unistd.h>\n          int execl(cONst char *path, const char *arg, ...);\n          int execlp(const char *file, const char *arg, ...);\n          int execle(const char *path, const char *arg, ..., char *const envp[]);\n          int execv(const char *path, char *const argv[]);\n          int execvp(const char *file, char *const argv[]);\n          int execve(const char *filename, char *const argv[], char *const envp[]);\n          ```\n\n        * 函数说明：\n\n          exec 函数族\n          execve 函数是该族的基础函数，其他函数是由该函数封装而来\n          exec 族被用启动新的指定路径下的程序来替换当前的程序。\n          函数名称后面的后缀不同参数不尽相同见下面附录1。\n\n     5. `exit()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <stdlib.h>\n          void exit(int status);\n          ```\n\n        * 函数说明：\n\n          终止进程并返回状态码。\n\n   * 多线程相关：\n\n     1. `pthread_create()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);\n          ```\n\n        * 函数说明：\n\n          * 作用：创建线程\n          * 该函数开始一个新的线程在调用该函数的进程中。新开始的线程通过调用`start_routine()`函数指针指向的函数来执行，arg参数是该函数指针指向的函数唯一的参数。\n          * 该线程可以通过一下方式中的一个终止：\n            * 调用`pthread_exit()`函数，并确定退出状态值，该值可用于该进程中的调用`phread_join()`的其他线程。\n            * 该线程执行的函数退出，这相当于调用`phread_exit()`并带有返回值。\n            * 被取消（见`pthread_cancel()`）\n            * 调用`exit()`函数，或者在主函数中执行`return`。这会导致该进程中所有线程终止。\n          * attr参数指向一个pthread_attr_t类型的结构体，这个参数被用来在线程创建之初确定该线程的属性。\n          * 如果调用该函数成功创建了一个线程，那么该线程的ID会存储在thread参数中。这个标志会在其他的函数中用到。\n\n     2. `pthread_join()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          int pthread_join(pthread_t thread, void **retval);\n          ```\n\n        * 函数说明：\n\n          * 该函数会等待由thread参数标志的线程终止。如果这个线程已经终止了，那么该函数立即返回。由thread参数标志的线程必须是可连接的。\n          * 如果retval参数不为空，那么该函数会拷贝目标线程的目标线程的退出状态（目标线程提供返回状态值给pthread_exit();）到该参数中。如果目标线程已经被取消了，那么该参数会存储PTHREAD_CANCELED。\n\n     3. `pthread_detach()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          int pthread_detach(pthread_t thread);\n          ```\n\n        * 函数说明：\n\n          该函数会把由thread参数指向的线程标记为分离。一个被标记分离的线程终止后，该线程的资源会被系统自动收回，不需要其他线程进程其他的操作。尝试标记已经分离的线程是不明操作，会导致未知错误。\n\n     4. `pthread_self()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          pthread_t pthread_self(void);\n          ```\n\n        * 函数说明：\n\n          * 该函数会返回调用者的PID，该值与调用`thread_create()`函数返回的thread值相同。\n\n     5. `pthread_equal`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          int pthread_equal(pthread_t t1, pthread_t t2);\n          ```\n\n        * 函数说明：\n\n          * 该函数比较两个线程的标记t1和t2是否指向同一个线程。\n          * 如果两个标记指向同一个线程会返回一个非零数，反之返回０。\n\n     6. `pthread_exit()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          void pthread_exit(void *retval);\n          ```\n\n        * 函数说明：\n\n        * 该函数会终止调用该函数的线程，并通过参数retval返回一个值，该值可用于同一进程中的其他线程调用`pthread_join()`。\n\n     7. 线程同步机制：\n\n        1. 互斥：\n\n           1. `pthread_mutex_init()`、`pthread_mutex_destroy()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);\n                int pthread_mutex_destroy(pthread_mutex_t *mutex);\n                ```\n\n              * 函数说明：\n\n                * `pthread_mutex_destroy()`:\n                  * 该函数销毁参数mutex引用的的互斥对象，实际上，该互斥对象会变成未初始化的状态。\n                  * 一个被销毁的互斥锁可以使用`pthread_mutex_init()`重新初始化。在互斥锁被销毁后引用该互斥锁会导致未定的引用的错误。\n                  * 销毁一个未上锁的初始化互斥对象是安全的。当尝试销毁一个通过其他线程使用的锁定的互斥锁或一个已经被禁用的互斥锁会导致未定义行为的错误。\n                * `pthread_mutex_init()`：\n                  * 该函数会初始化一个被参数mutex引用的互斥锁，该互斥锁的属性在参数attr中规定。\n\n           2. `pthread_mutex_lock()`、`pthread_mutex_trylock()`和`pthread_mutex_unlock`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_mutex_lock(pthread_mutex_t *mutex);\n                int pthread_mutex_trylock(pthread_mutex_t *mutex);\n                int pthread_mutex_unlock(pthread_mutex_t *mutex);\n                ```\n\n              * 函数说明：\n\n                * `pthread_mutex_lock()`\n                  * 该函数会把参数mutex引用的互斥锁上锁返回０或者EOWNERDEAD，如果该互斥锁已经被其他线程上锁了，那么该线程会阻塞，直到该互斥锁可用。\n                * `pthread_mutex_trylock()`\n                  * pthread_mutex_trylock()函数等效于pthread_mutex_lock()，除非mutex引用的互斥对象当前被锁定（由任何线程，包括当前线程），则调用应立即返回。\n                * `pthread_mutex_unlock()`\n                  * pthread_mutex_unlock()函数将释放互斥锁引用的互斥锁对象。 释放互斥锁的方式取决于互斥锁的类型属性。\n\n        2. 读写锁：\n\n           1. ``pthread_rwlock_init()`、`pthread_rwlock_destory()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                \n                int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);\n                int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr);\n                \n                pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;\n                ```\n\n              * 函数说明：\n\n                * ``pthread_rwlock_init()`函数会分配参数rwkock参数引用的读写所所需的所有资源，并将读写锁初始化为具有参数attr指定的属性，并置为解锁状态，如果attr为NULL，则应使用默认的读写锁属性; 效果与传递默认读写锁属性对象的地址相同。\n                * `pthread_rwlock_destory()`函数将销毁rwlock引用的读写锁对象，并释放锁使用的所有资源。\n\n                \n\n           2. `pthread_rwlock_rdlock()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\n                int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\n                ```\n\n              * 函数说明：\n\n                两个函数函数都会对由rwlock引用的读写锁解开读锁。但是对于`pthread_rwlock_rdlock()`函数如果写入权限没有上锁并且互斥锁上没有写入权限被阻塞，则调用线程获取读锁定。调用该函数的线程读权限会被上锁。try函数遇到这种情况会返回调用失败两个函数都是成功返回０。\n\n           3. `pthread_rwlock_wrlock()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\n                int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n                ```\n\n              * 函数说明：\n\n                两个函数同样都会为调用者加写权限锁，但是try函数回去尝试，也就是说如果任何线程当前持有rwlock（用于读或写），函数将调用失败。但是另一个函数遇到这种情况会阻塞。函数执行成功返回０。\n\n           4. `pthread_rwlock_unlock()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);\n                ```\n\n              * 函数说明：\n\n                该函数将释放由rwlock引用的读写锁对象上的锁。 如果读写锁定rwlock未被调用线程保持，则结果是不确定的。\n\n        3. 条件变量：\n\n           1. `thread_cond_init()`、`thread_cond_destory()`\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                \n                int pthread_cond_destroy(pthread_cond_t *cond);\n                int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);\n                \n                pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n                ```\n\n              * 函数说明：\n\n                `pthread_cond_destroy()`函数将销毁由cond指定的给定条件变量; 实际上，对象会处于未初始化状态。可以使用`pthread_cond_init()`重新初始化已销毁的条件变量对象; 在对象被销毁之后引用该对象的结果是未定义的。`pthread_cond_init()`函数应使用attr引用的属性初始化cond引用的条件变量。\n\n           2. `thread_cond_wait()`、`thread_cond_timedwait()`：\n\n              - 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                \n                int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);\n                int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);\n                ```\n\n              - 函数说明：\n\n                两个函数都会阻塞条件变量。 应用程序应确保在调用线程锁定互斥锁的情况下调用这些函数; 否则，会产生错误或未定义的行为（对于其他互斥锁）。\n\n           3. `thread_cond_signal()`、`thread_cond_broadcast()`：\n\n              - 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                \n                int pthread_cond_broadcast(pthread_cond_t *cond);\n                int pthread_cond_signal(pthread_cond_t *cond);\n                ```\n\n              - 函数说明：\n\n                `pthread_cond_broadcast()`函数将取消阻止当前在指定条件变量cond上阻塞的所有线程。`pthread_cond_signal()`函数应解除阻塞在指定条件变量cond上阻塞的至少一个线程（如果在cond上阻塞了任何线程）。\n\n   * 共享内存相关：\n\n     1. `shmget()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <sys/ipc.h>\n          #include <sys/shm.h>\n          int shmget(key_t key, size_t size, int shmflg);\n          ```\n\n        * 函数说明：\n\n          * 该函数返回与参数key相关联的共享内存片段的标识符（identifier）。\n\n           * 该函数可以用于获取先前创建的共享内存的idenfifier（当shmflg为0并且key值不是IPC_PRIVATE< 预定义宏，见附录3 >的时候）\n           * 该函数还可以用于创建一个新共享内存，新的共享内存大小为size参数向上取整到PAGE_SIZE(预定义宏，见附录3)。使用该函数创建新的共享内存需满足如下条件：\n           * 1. key没有与它相对应的共享内存(无论参数key的值是不是IPC_PRIVATE（预定义宏，见附录3）)\n           * 2. shmflg参数指定了IPC_CREAT（预定义宏，见附录3）\n           * 如果参数shmflg指定了IPC_CREAT和IPC_EXECL并且key 已经存在与其相关联的共享内存，那么shmget函数创建新的共享内存失败，并且erron会被设置为EEXIST。(这有点像O_CREAT | O_EXCL 组合对于open()函数带来的影响)\n           * shmflg参数的取值如下：\n           * IPC_CREAT IPC_EXCL、SHM_HUGETLB、SHM_HUGE2MB(SHM_HUGE_1GB)、SHM_NORESERVE（详情见附录3）\n\n     2. `shmat()`、`shmdt()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <sys/types.h>\n          #include <sys/shm.h>\n          void *shmat(int shmid, const void *shmaddr, int shmflg);\n          int shmdt(const void *shmaddr);\n          ```\n\n        * 函数说明：\n\n          * shmat();\n           * 该函数把通过shmid标志的共享内存段链接到调用该函数的进程所在的地址空间中。\n           * 这个被链接的地址空间由shmaddr参数的如下定义所规定：\n              1. 如果shmaddr参数为空，系统会选择一个合适的（未使用的）对齐页地址去链接共享内存。\n              2. 如果shmaddr参数不为空并且shmflg参数指定了SHMLBA(见附录3)，会链接到shmaddr参数向下取整到离SHMLBA倍数最近值的地址。\n              3. 除此之外，一定会链接到shmaddr 附近的对齐页地址。\n           * 除了SHM_RND以外，shmflg位掩码参数还可能使用到一下规定的标志：\n           * SHM_EXEC、SHM_RDONLY、SHM_REMAP（详细说明见附录3）\n           * shmdt();\n           * 与上面的函数相反，该函数通过shmid表示的共享内存段从调用该用书的进程所在的地址空间中断开。\n           * 这个被断开的共享内存段必须是目前链接的，并且shmaddr参数的值为调用shmat()函数的返回值。\n           * 如果shmdt()调用成功，系统会更新与共享内存相关联的shmid_ds结构体，该结构体成员如下：\n           * shm_ttime : 被设置为当前时间。\n           * shm_lpid : 被设置为被调用的进程的进程ID。\n           * shm_nattch ：这个值逐一递减，如果这个值减为0并且这个共享内存段被标记为删除，那么这个共享内存段就被删除了。\n\n     3. `shmctl()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <sys/ipc.h>\n          #include <sys/shm.h>\n          int shmctl(int shmid, int cmd, struct shmid_ds *buf);\n          ```\n\n           * 该函数执行由cmd参数指定的操作，cmd参数存储在由shmid参数存储的识别码指向的共享内存段。\n\n           * buf参数是一个shmid_ds结构体指针，shmid_ds结构体在头文件<sys/shm.h>中定义，如下所示：\n\n             ```c\n             struct shmid_ds {\n                 struct ipc_perm shm_perm;\t/* 所有权和权限 */\n                 size_t shm_segsz;\t\t\t/* 段大小（单位：字节） */\n                 time_t shm_atime;\t\t\t/* 最后的链接时间 */\n                 time_t shm_dtime;\t\t\t/* 最后的断开链接时间 */\n                 time_t shm_ctime;\t\t\t/* 最后的更改时间 */\n                 pid_t  shm_cpid;\t\t\t/* 创建者的PID */\n                 pid_t  shm_lpid;\t\t\t/* 最后的shmat()函数或shmdt()函数的pid */\n                 ...\n             };\n             ipc_perm结构体的定义如下（其中udi、gid和mode可设置为IPC_SET）：\n             struct ipc_perm {\n             \tkey_t\t\t\t__key;\t\t/* 提供给shmget()函数的键值 */\n             \tuid_t\t\t\tuid;\t\t/* 有效的拥有者的UID */\n             \tgid_t\t\t\tgid;\t\t/* 有效的拥有者的GID */\n             \tuid_t\t\t\tcuid;\t\t/* 有效的创建者UID */\n             \tgid_t \t\t\tcgid;\t\t/* 有效的创建者GID */\n             \tunsigned short\tmode;\t\t/* 权限 + SHM_DEST 和 SHM_LOCKED 标记 */\n             \tunsigned short\t__seq;\t\t/* 序列号 */\n             };\n             ```\n           * cmd参数的有效值如下：\n\n             IPC_STAT、IPC_SET IPC_RMID、IPC_INFO、SHM_INFO、SHM_STAT、SHM_LOCK、SHM_UNLOCK 。\n\n \n\n---\n* 附录1（摘自网络）：\n\n  | 后缀 | 参数                                                         |\n  | ---- | ------------------------------------------------------------ |\n  | l    | 接收以逗号为分隔的参数列表，以NULL为结束符                   |\n  | v    | 接收以NULL为结束的字符串数组                                 |\n  | p    | 接收以NULL为结束的字符串数组指针，并可以利用DOS的PATH变量查找子程序文件 |\n  | e    | 传递环境变量。                                               |\n\n* 附录2（摘自网络）：\n\n  1. 不在函数内部使用静态或全局数据。\n  2. 不返回静态或全局数据，所有数据都由函数的调用者提供。\n  3. 使用本地数据，或通过拷贝全局数据到本地来保护全局数据。\n  4. 不调用不可重入性函数。\n\n* 附录三（翻译自man手册）：\n\n  | 宏名称                  | 意义                                                         |\n  | ----------------------- | ------------------------------------------------------------ |\n  | IPC_CREAT               | 创建一个新的段，如果这个标志没有被使用，shmget()函数将会寻找与这个段相对应的key参数值，并且检查使用者是否有读取这个段的权限。 |\n  | IPC_EXCL                | 该标志与IPC_BREAT一起被用作确认本次创建共享内存的调用成功与否。 |\n  | IPC_PRIVATE             | 它不是一个标志字段，而是一个key_t类型的值，如果函数调用的时候key参数中存储这个特殊的值，系统调用会忽略除了shmflg中最不重要的9位意外的所有并且创建一个新的共享内存。 |\n  | IPC_STAT                | 从内核中拷贝shmid中由buf指向的shmid_ds结构相关的数据结构信息。对于共享内存段调用者必须拥有可读权限。 |\n  | IPC_SET                 | 往参数buf指针指向的shmid_ds结构体的某些成员写入与该共享内存段相关联的内核数据结构，并且更新该结构体中的shm_ctime成员。以下成员可能会被改变：shm_perm.uid、shm_perm.gid和（最不重要的九位）shm_perm.mode。调用进程的有效UID必须与拥有者（shm_perm.uid）或共享内存的创建者（shm_per.cuid）相匹配，或者与一定是拥有特权的调用者相匹配。 |\n  | IPC_RMID                | 标记被销毁的共享内存段，实际上，这个共享内存段实在进程销毁的时候被销毁。（当shmid_ds相关构成员shm_nattch为空的时候）。调用者必须是共享内存的拥有者或者创建者，或者拥有特权。buf参数被忽略。 |\n  | SHM_NORESREVE           | （从linux内核2.6.15以后）这个标志与mmap()函数的MAP_NORESERVE 标志具有同样的目的。不保留交换空间对于共享内存段，当交换空间被保留了，他会保证共享内存是可用的。当交换空间没有被保留，并且物理内存不可用，那么可能会在写入时获取SIGSEGV。也可以查阅`/proc/sys/vm/overcommit`文件。 |\n  | SHM_REMAP               | （LInux特有）这个标志指定了在共享内存段中从shmaddr参数开始到段最后的范围内的段映射应该被替换成现有的映射。（一般情况下，一个EINVAL错误可能是由于一个映射在地址范围内已经存在）在这个案例中，shmaddr参数必须不为空。 |\n  | SHM_RDONLY              | 以只读的方式链接共享内存段。进程对共享内存段必须有读取权限。如果标志没有被指定，那么共享内存段会被以可读可写方式链接，并且进程对于该共享内存段必须拥有可读和可写权限。但这不意味着对共享内存段有只写权限。 |\n  | SHM_EXEC                | （Linux特有，从linux2.6.9以后）允许执行共享内存段中的内容。调用者对于共享内存段必须拥有可执行权限。 |\n  | SHM_HUGETLB             | （从linux内核2.6版以后）为共享内存段分配巨大空间，详情见linux内核源码文件中`Documentation/vm/hugetlbpage.txt`获取更多信息。 |\n  | SHM_HUGE2MB,SHM_HUGE1GB | （从linux内核3.8之后）与SHM_HUGETLB一起被用作选择替代hugetlb大页面的大小（分别是2MB和1GB），并且支持超过hugetlb大页面的大小。 |\n\n* 参考资料：\n\n  > 参考网站：[多进程编程总结](https://blog.csdn.net/hello_bravo_/article/details/52497401)、[C语言多进程编程](https://www.xuebuyuan.com/943688.html)、[多线程和多进程的区别（小结）](https://www.cnblogs.com/alanfeng/p/5055141.html)、[百度百科：程序并发执行](https://baike.baidu.com/item/程序并发执行/7387706)、[linux下c语言编程exec函数使用](https://blog.csdn.net/aile770339804/article/details/7443921)\n  >\n  >  参考书籍：[C语言核心技术](http://product.dangdang.com/25154067.html) 、man手册\n","source":"_posts/进程、线程及共享内存学习笔记.md","raw":"---\ntitle: 进程、线程及共享内存学习笔记\ndate: 2019-09-02 16:40:51\ncover: title.jpg\ntags: note\n---\n\n## 进程、线程及共享内存学习笔记\n> 系统环境：deepin Linux，语言环境：Linux C\n> 欢迎大家转载，转载请注明出处，谢谢！\n\n1. 理论基础：\n\n   * 进程：计算机上每个执行的活动，运行一个可执行程序是一个进程，打开一个软件是一个进程，打开一个终端是一个进程等等。\n   * 多进程：为了充分利用计算机资源产生了多进程的执行方式。通俗来讲就是在同一时间做多个事情，从而可以充分利用计算机资源还可以提高程序的执行效率。在创建一个新的子进程后，子进程会会获得计算机分配的资源，并拷贝父进程的数据。\n   * 子进程与父进程：我们编写的一段程序运行时就是一个进程，当我们在这段代码中调用特定函数新创建一个进程时，新创建的进程就是当前进程的子进程，而对于新创建的进程来说，当前进程就是它的父进程，子进程通过拷贝等手段继承父进程在创建子进程之前的数据、属性等。\n   * 多线程：上面说到进程是计算机上执行的每个活动。在实际编程中，一个进程中会有很多任务需要做。从而引发思考：一个进程中的多个任务是否也可以并发的执行？因为有些任务之间是没有联系的，也就是说有些任务完全可以同时进行而没有依赖问题。答案就是线程。与多进程相同的是，多线程也是为了让计算机资源得到充分利用并且程序的执行效率也会得到提高，与多进程不同的是，多线程并没有拷贝这种需求，它实际上是把一个进程分成多个片段。\n   * 重入性：尽管多线程系统开销少，但是也难免有缺陷，那就是重入性问题，使用多线程编程需要保证被多线程多次执行的函数的可重入性，所谓重入性就是函数被多个线程多次调用皆能正常执行。见附录2，有几个保证函数可重入性的条件。\n   * 线程安全：使用多线程编程除了需要保证函数的可重入性还需要保证线程安全，另外，可重入的函数一定是 线程安全的，但是反之不成立。\n   * 共享内存：根据字面意思就很好理解，通过把不同的进程中的逻辑内存映射到同一块物理内存中，进而允许两个进程共享同一块逻辑内存空间。它是进程间通信的一种方式。共享内存本身并没有提供同步机制。\n\n2. 相关函数：\n\n   * 多进程相关：\n\n     1. `fork()`：\n\n        * 原型：\n\n          ```c\n          #include <sys/types.h>\n          #include <unistd.h>\n          \n          pid_t fork(void);\n          ```\n\n        * 说明：\n\n          通过复制调用者来创建新进程。这个新的进程简称为子进程。调用该函数的进程称为父进程。\n\n          子进程和父进程运行在不同的内存空间中。在调用该函数的时候，两个进程内存空间都拥有相同的内容。其中一个进程执行的内存写入，文件映射和解除映射操作不会影响到另一个进程。该函数的返回值在父子进程中不同，在父进程中返回子进程PID，在子进程中返回0。\n\n     2. `wait()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <sys/types.h>\n          #include <sys/wait.h>\n          \n          pid_t wait(int *stat_loc);\n          ```\n\n        * 函数说明：\n\n          当调用这个函数的时候，当前进程会阻塞等待，该进程的某个子进程运行结束为止。\n          该结束的子进程的返回状态被存储在wait()函数的参数stat_loc变量中。\n\n     3. `system();`\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <stdlib.h>\n          #include <stdio.h>\n          int system(char *command);\n          ```\n\n        * 函数说明：\n\n          创建新的进程，执行制定命令。\n\n     4. exec函数族：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <unistd.h>\n          int execl(cONst char *path, const char *arg, ...);\n          int execlp(const char *file, const char *arg, ...);\n          int execle(const char *path, const char *arg, ..., char *const envp[]);\n          int execv(const char *path, char *const argv[]);\n          int execvp(const char *file, char *const argv[]);\n          int execve(const char *filename, char *const argv[], char *const envp[]);\n          ```\n\n        * 函数说明：\n\n          exec 函数族\n          execve 函数是该族的基础函数，其他函数是由该函数封装而来\n          exec 族被用启动新的指定路径下的程序来替换当前的程序。\n          函数名称后面的后缀不同参数不尽相同见下面附录1。\n\n     5. `exit()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <stdlib.h>\n          void exit(int status);\n          ```\n\n        * 函数说明：\n\n          终止进程并返回状态码。\n\n   * 多线程相关：\n\n     1. `pthread_create()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);\n          ```\n\n        * 函数说明：\n\n          * 作用：创建线程\n          * 该函数开始一个新的线程在调用该函数的进程中。新开始的线程通过调用`start_routine()`函数指针指向的函数来执行，arg参数是该函数指针指向的函数唯一的参数。\n          * 该线程可以通过一下方式中的一个终止：\n            * 调用`pthread_exit()`函数，并确定退出状态值，该值可用于该进程中的调用`phread_join()`的其他线程。\n            * 该线程执行的函数退出，这相当于调用`phread_exit()`并带有返回值。\n            * 被取消（见`pthread_cancel()`）\n            * 调用`exit()`函数，或者在主函数中执行`return`。这会导致该进程中所有线程终止。\n          * attr参数指向一个pthread_attr_t类型的结构体，这个参数被用来在线程创建之初确定该线程的属性。\n          * 如果调用该函数成功创建了一个线程，那么该线程的ID会存储在thread参数中。这个标志会在其他的函数中用到。\n\n     2. `pthread_join()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          int pthread_join(pthread_t thread, void **retval);\n          ```\n\n        * 函数说明：\n\n          * 该函数会等待由thread参数标志的线程终止。如果这个线程已经终止了，那么该函数立即返回。由thread参数标志的线程必须是可连接的。\n          * 如果retval参数不为空，那么该函数会拷贝目标线程的目标线程的退出状态（目标线程提供返回状态值给pthread_exit();）到该参数中。如果目标线程已经被取消了，那么该参数会存储PTHREAD_CANCELED。\n\n     3. `pthread_detach()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          int pthread_detach(pthread_t thread);\n          ```\n\n        * 函数说明：\n\n          该函数会把由thread参数指向的线程标记为分离。一个被标记分离的线程终止后，该线程的资源会被系统自动收回，不需要其他线程进程其他的操作。尝试标记已经分离的线程是不明操作，会导致未知错误。\n\n     4. `pthread_self()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          pthread_t pthread_self(void);\n          ```\n\n        * 函数说明：\n\n          * 该函数会返回调用者的PID，该值与调用`thread_create()`函数返回的thread值相同。\n\n     5. `pthread_equal`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          int pthread_equal(pthread_t t1, pthread_t t2);\n          ```\n\n        * 函数说明：\n\n          * 该函数比较两个线程的标记t1和t2是否指向同一个线程。\n          * 如果两个标记指向同一个线程会返回一个非零数，反之返回０。\n\n     6. `pthread_exit()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <pthread.h>\n          void pthread_exit(void *retval);\n          ```\n\n        * 函数说明：\n\n        * 该函数会终止调用该函数的线程，并通过参数retval返回一个值，该值可用于同一进程中的其他线程调用`pthread_join()`。\n\n     7. 线程同步机制：\n\n        1. 互斥：\n\n           1. `pthread_mutex_init()`、`pthread_mutex_destroy()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);\n                int pthread_mutex_destroy(pthread_mutex_t *mutex);\n                ```\n\n              * 函数说明：\n\n                * `pthread_mutex_destroy()`:\n                  * 该函数销毁参数mutex引用的的互斥对象，实际上，该互斥对象会变成未初始化的状态。\n                  * 一个被销毁的互斥锁可以使用`pthread_mutex_init()`重新初始化。在互斥锁被销毁后引用该互斥锁会导致未定的引用的错误。\n                  * 销毁一个未上锁的初始化互斥对象是安全的。当尝试销毁一个通过其他线程使用的锁定的互斥锁或一个已经被禁用的互斥锁会导致未定义行为的错误。\n                * `pthread_mutex_init()`：\n                  * 该函数会初始化一个被参数mutex引用的互斥锁，该互斥锁的属性在参数attr中规定。\n\n           2. `pthread_mutex_lock()`、`pthread_mutex_trylock()`和`pthread_mutex_unlock`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_mutex_lock(pthread_mutex_t *mutex);\n                int pthread_mutex_trylock(pthread_mutex_t *mutex);\n                int pthread_mutex_unlock(pthread_mutex_t *mutex);\n                ```\n\n              * 函数说明：\n\n                * `pthread_mutex_lock()`\n                  * 该函数会把参数mutex引用的互斥锁上锁返回０或者EOWNERDEAD，如果该互斥锁已经被其他线程上锁了，那么该线程会阻塞，直到该互斥锁可用。\n                * `pthread_mutex_trylock()`\n                  * pthread_mutex_trylock()函数等效于pthread_mutex_lock()，除非mutex引用的互斥对象当前被锁定（由任何线程，包括当前线程），则调用应立即返回。\n                * `pthread_mutex_unlock()`\n                  * pthread_mutex_unlock()函数将释放互斥锁引用的互斥锁对象。 释放互斥锁的方式取决于互斥锁的类型属性。\n\n        2. 读写锁：\n\n           1. ``pthread_rwlock_init()`、`pthread_rwlock_destory()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                \n                int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);\n                int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr);\n                \n                pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;\n                ```\n\n              * 函数说明：\n\n                * ``pthread_rwlock_init()`函数会分配参数rwkock参数引用的读写所所需的所有资源，并将读写锁初始化为具有参数attr指定的属性，并置为解锁状态，如果attr为NULL，则应使用默认的读写锁属性; 效果与传递默认读写锁属性对象的地址相同。\n                * `pthread_rwlock_destory()`函数将销毁rwlock引用的读写锁对象，并释放锁使用的所有资源。\n\n                \n\n           2. `pthread_rwlock_rdlock()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\n                int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\n                ```\n\n              * 函数说明：\n\n                两个函数函数都会对由rwlock引用的读写锁解开读锁。但是对于`pthread_rwlock_rdlock()`函数如果写入权限没有上锁并且互斥锁上没有写入权限被阻塞，则调用线程获取读锁定。调用该函数的线程读权限会被上锁。try函数遇到这种情况会返回调用失败两个函数都是成功返回０。\n\n           3. `pthread_rwlock_wrlock()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\n                int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n                ```\n\n              * 函数说明：\n\n                两个函数同样都会为调用者加写权限锁，但是try函数回去尝试，也就是说如果任何线程当前持有rwlock（用于读或写），函数将调用失败。但是另一个函数遇到这种情况会阻塞。函数执行成功返回０。\n\n           4. `pthread_rwlock_unlock()`：\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);\n                ```\n\n              * 函数说明：\n\n                该函数将释放由rwlock引用的读写锁对象上的锁。 如果读写锁定rwlock未被调用线程保持，则结果是不确定的。\n\n        3. 条件变量：\n\n           1. `thread_cond_init()`、`thread_cond_destory()`\n\n              * 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                \n                int pthread_cond_destroy(pthread_cond_t *cond);\n                int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);\n                \n                pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n                ```\n\n              * 函数说明：\n\n                `pthread_cond_destroy()`函数将销毁由cond指定的给定条件变量; 实际上，对象会处于未初始化状态。可以使用`pthread_cond_init()`重新初始化已销毁的条件变量对象; 在对象被销毁之后引用该对象的结果是未定义的。`pthread_cond_init()`函数应使用attr引用的属性初始化cond引用的条件变量。\n\n           2. `thread_cond_wait()`、`thread_cond_timedwait()`：\n\n              - 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                \n                int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);\n                int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);\n                ```\n\n              - 函数说明：\n\n                两个函数都会阻塞条件变量。 应用程序应确保在调用线程锁定互斥锁的情况下调用这些函数; 否则，会产生错误或未定义的行为（对于其他互斥锁）。\n\n           3. `thread_cond_signal()`、`thread_cond_broadcast()`：\n\n              - 函数原型及头文件：\n\n                ```c\n                #include <pthread.h>\n                \n                int pthread_cond_broadcast(pthread_cond_t *cond);\n                int pthread_cond_signal(pthread_cond_t *cond);\n                ```\n\n              - 函数说明：\n\n                `pthread_cond_broadcast()`函数将取消阻止当前在指定条件变量cond上阻塞的所有线程。`pthread_cond_signal()`函数应解除阻塞在指定条件变量cond上阻塞的至少一个线程（如果在cond上阻塞了任何线程）。\n\n   * 共享内存相关：\n\n     1. `shmget()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <sys/ipc.h>\n          #include <sys/shm.h>\n          int shmget(key_t key, size_t size, int shmflg);\n          ```\n\n        * 函数说明：\n\n          * 该函数返回与参数key相关联的共享内存片段的标识符（identifier）。\n\n           * 该函数可以用于获取先前创建的共享内存的idenfifier（当shmflg为0并且key值不是IPC_PRIVATE< 预定义宏，见附录3 >的时候）\n           * 该函数还可以用于创建一个新共享内存，新的共享内存大小为size参数向上取整到PAGE_SIZE(预定义宏，见附录3)。使用该函数创建新的共享内存需满足如下条件：\n           * 1. key没有与它相对应的共享内存(无论参数key的值是不是IPC_PRIVATE（预定义宏，见附录3）)\n           * 2. shmflg参数指定了IPC_CREAT（预定义宏，见附录3）\n           * 如果参数shmflg指定了IPC_CREAT和IPC_EXECL并且key 已经存在与其相关联的共享内存，那么shmget函数创建新的共享内存失败，并且erron会被设置为EEXIST。(这有点像O_CREAT | O_EXCL 组合对于open()函数带来的影响)\n           * shmflg参数的取值如下：\n           * IPC_CREAT IPC_EXCL、SHM_HUGETLB、SHM_HUGE2MB(SHM_HUGE_1GB)、SHM_NORESERVE（详情见附录3）\n\n     2. `shmat()`、`shmdt()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <sys/types.h>\n          #include <sys/shm.h>\n          void *shmat(int shmid, const void *shmaddr, int shmflg);\n          int shmdt(const void *shmaddr);\n          ```\n\n        * 函数说明：\n\n          * shmat();\n           * 该函数把通过shmid标志的共享内存段链接到调用该函数的进程所在的地址空间中。\n           * 这个被链接的地址空间由shmaddr参数的如下定义所规定：\n              1. 如果shmaddr参数为空，系统会选择一个合适的（未使用的）对齐页地址去链接共享内存。\n              2. 如果shmaddr参数不为空并且shmflg参数指定了SHMLBA(见附录3)，会链接到shmaddr参数向下取整到离SHMLBA倍数最近值的地址。\n              3. 除此之外，一定会链接到shmaddr 附近的对齐页地址。\n           * 除了SHM_RND以外，shmflg位掩码参数还可能使用到一下规定的标志：\n           * SHM_EXEC、SHM_RDONLY、SHM_REMAP（详细说明见附录3）\n           * shmdt();\n           * 与上面的函数相反，该函数通过shmid表示的共享内存段从调用该用书的进程所在的地址空间中断开。\n           * 这个被断开的共享内存段必须是目前链接的，并且shmaddr参数的值为调用shmat()函数的返回值。\n           * 如果shmdt()调用成功，系统会更新与共享内存相关联的shmid_ds结构体，该结构体成员如下：\n           * shm_ttime : 被设置为当前时间。\n           * shm_lpid : 被设置为被调用的进程的进程ID。\n           * shm_nattch ：这个值逐一递减，如果这个值减为0并且这个共享内存段被标记为删除，那么这个共享内存段就被删除了。\n\n     3. `shmctl()`：\n\n        * 函数原型及头文件：\n\n          ```c\n          #include <sys/ipc.h>\n          #include <sys/shm.h>\n          int shmctl(int shmid, int cmd, struct shmid_ds *buf);\n          ```\n\n           * 该函数执行由cmd参数指定的操作，cmd参数存储在由shmid参数存储的识别码指向的共享内存段。\n\n           * buf参数是一个shmid_ds结构体指针，shmid_ds结构体在头文件<sys/shm.h>中定义，如下所示：\n\n             ```c\n             struct shmid_ds {\n                 struct ipc_perm shm_perm;\t/* 所有权和权限 */\n                 size_t shm_segsz;\t\t\t/* 段大小（单位：字节） */\n                 time_t shm_atime;\t\t\t/* 最后的链接时间 */\n                 time_t shm_dtime;\t\t\t/* 最后的断开链接时间 */\n                 time_t shm_ctime;\t\t\t/* 最后的更改时间 */\n                 pid_t  shm_cpid;\t\t\t/* 创建者的PID */\n                 pid_t  shm_lpid;\t\t\t/* 最后的shmat()函数或shmdt()函数的pid */\n                 ...\n             };\n             ipc_perm结构体的定义如下（其中udi、gid和mode可设置为IPC_SET）：\n             struct ipc_perm {\n             \tkey_t\t\t\t__key;\t\t/* 提供给shmget()函数的键值 */\n             \tuid_t\t\t\tuid;\t\t/* 有效的拥有者的UID */\n             \tgid_t\t\t\tgid;\t\t/* 有效的拥有者的GID */\n             \tuid_t\t\t\tcuid;\t\t/* 有效的创建者UID */\n             \tgid_t \t\t\tcgid;\t\t/* 有效的创建者GID */\n             \tunsigned short\tmode;\t\t/* 权限 + SHM_DEST 和 SHM_LOCKED 标记 */\n             \tunsigned short\t__seq;\t\t/* 序列号 */\n             };\n             ```\n           * cmd参数的有效值如下：\n\n             IPC_STAT、IPC_SET IPC_RMID、IPC_INFO、SHM_INFO、SHM_STAT、SHM_LOCK、SHM_UNLOCK 。\n\n \n\n---\n* 附录1（摘自网络）：\n\n  | 后缀 | 参数                                                         |\n  | ---- | ------------------------------------------------------------ |\n  | l    | 接收以逗号为分隔的参数列表，以NULL为结束符                   |\n  | v    | 接收以NULL为结束的字符串数组                                 |\n  | p    | 接收以NULL为结束的字符串数组指针，并可以利用DOS的PATH变量查找子程序文件 |\n  | e    | 传递环境变量。                                               |\n\n* 附录2（摘自网络）：\n\n  1. 不在函数内部使用静态或全局数据。\n  2. 不返回静态或全局数据，所有数据都由函数的调用者提供。\n  3. 使用本地数据，或通过拷贝全局数据到本地来保护全局数据。\n  4. 不调用不可重入性函数。\n\n* 附录三（翻译自man手册）：\n\n  | 宏名称                  | 意义                                                         |\n  | ----------------------- | ------------------------------------------------------------ |\n  | IPC_CREAT               | 创建一个新的段，如果这个标志没有被使用，shmget()函数将会寻找与这个段相对应的key参数值，并且检查使用者是否有读取这个段的权限。 |\n  | IPC_EXCL                | 该标志与IPC_BREAT一起被用作确认本次创建共享内存的调用成功与否。 |\n  | IPC_PRIVATE             | 它不是一个标志字段，而是一个key_t类型的值，如果函数调用的时候key参数中存储这个特殊的值，系统调用会忽略除了shmflg中最不重要的9位意外的所有并且创建一个新的共享内存。 |\n  | IPC_STAT                | 从内核中拷贝shmid中由buf指向的shmid_ds结构相关的数据结构信息。对于共享内存段调用者必须拥有可读权限。 |\n  | IPC_SET                 | 往参数buf指针指向的shmid_ds结构体的某些成员写入与该共享内存段相关联的内核数据结构，并且更新该结构体中的shm_ctime成员。以下成员可能会被改变：shm_perm.uid、shm_perm.gid和（最不重要的九位）shm_perm.mode。调用进程的有效UID必须与拥有者（shm_perm.uid）或共享内存的创建者（shm_per.cuid）相匹配，或者与一定是拥有特权的调用者相匹配。 |\n  | IPC_RMID                | 标记被销毁的共享内存段，实际上，这个共享内存段实在进程销毁的时候被销毁。（当shmid_ds相关构成员shm_nattch为空的时候）。调用者必须是共享内存的拥有者或者创建者，或者拥有特权。buf参数被忽略。 |\n  | SHM_NORESREVE           | （从linux内核2.6.15以后）这个标志与mmap()函数的MAP_NORESERVE 标志具有同样的目的。不保留交换空间对于共享内存段，当交换空间被保留了，他会保证共享内存是可用的。当交换空间没有被保留，并且物理内存不可用，那么可能会在写入时获取SIGSEGV。也可以查阅`/proc/sys/vm/overcommit`文件。 |\n  | SHM_REMAP               | （LInux特有）这个标志指定了在共享内存段中从shmaddr参数开始到段最后的范围内的段映射应该被替换成现有的映射。（一般情况下，一个EINVAL错误可能是由于一个映射在地址范围内已经存在）在这个案例中，shmaddr参数必须不为空。 |\n  | SHM_RDONLY              | 以只读的方式链接共享内存段。进程对共享内存段必须有读取权限。如果标志没有被指定，那么共享内存段会被以可读可写方式链接，并且进程对于该共享内存段必须拥有可读和可写权限。但这不意味着对共享内存段有只写权限。 |\n  | SHM_EXEC                | （Linux特有，从linux2.6.9以后）允许执行共享内存段中的内容。调用者对于共享内存段必须拥有可执行权限。 |\n  | SHM_HUGETLB             | （从linux内核2.6版以后）为共享内存段分配巨大空间，详情见linux内核源码文件中`Documentation/vm/hugetlbpage.txt`获取更多信息。 |\n  | SHM_HUGE2MB,SHM_HUGE1GB | （从linux内核3.8之后）与SHM_HUGETLB一起被用作选择替代hugetlb大页面的大小（分别是2MB和1GB），并且支持超过hugetlb大页面的大小。 |\n\n* 参考资料：\n\n  > 参考网站：[多进程编程总结](https://blog.csdn.net/hello_bravo_/article/details/52497401)、[C语言多进程编程](https://www.xuebuyuan.com/943688.html)、[多线程和多进程的区别（小结）](https://www.cnblogs.com/alanfeng/p/5055141.html)、[百度百科：程序并发执行](https://baike.baidu.com/item/程序并发执行/7387706)、[linux下c语言编程exec函数使用](https://blog.csdn.net/aile770339804/article/details/7443921)\n  >\n  >  参考书籍：[C语言核心技术](http://product.dangdang.com/25154067.html) 、man手册\n","slug":"进程、线程及共享内存学习笔记","published":1,"updated":"2020-04-08T03:47:38.804Z","_id":"ck8qr69dr001c5d3a5465dxx0","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"进程-线程及共享内存学习笔记\"><a class=\"markdownIt-Anchor\" href=\"#进程-线程及共享内存学习笔记\"></a> 进程、线程及共享内存学习笔记</h2>\n<blockquote>\n<p>系统环境：deepin Linux，语言环境：Linux C<br>\n欢迎大家转载，转载请注明出处，谢谢！</p>\n</blockquote>\n<ol>\n<li>\n<p>理论基础：</p>\n<ul>\n<li>进程：计算机上每个执行的活动，运行一个可执行程序是一个进程，打开一个软件是一个进程，打开一个终端是一个进程等等。</li>\n<li>多进程：为了充分利用计算机资源产生了多进程的执行方式。通俗来讲就是在同一时间做多个事情，从而可以充分利用计算机资源还可以提高程序的执行效率。在创建一个新的子进程后，子进程会会获得计算机分配的资源，并拷贝父进程的数据。</li>\n<li>子进程与父进程：我们编写的一段程序运行时就是一个进程，当我们在这段代码中调用特定函数新创建一个进程时，新创建的进程就是当前进程的子进程，而对于新创建的进程来说，当前进程就是它的父进程，子进程通过拷贝等手段继承父进程在创建子进程之前的数据、属性等。</li>\n<li>多线程：上面说到进程是计算机上执行的每个活动。在实际编程中，一个进程中会有很多任务需要做。从而引发思考：一个进程中的多个任务是否也可以并发的执行？因为有些任务之间是没有联系的，也就是说有些任务完全可以同时进行而没有依赖问题。答案就是线程。与多进程相同的是，多线程也是为了让计算机资源得到充分利用并且程序的执行效率也会得到提高，与多进程不同的是，多线程并没有拷贝这种需求，它实际上是把一个进程分成多个片段。</li>\n<li>重入性：尽管多线程系统开销少，但是也难免有缺陷，那就是重入性问题，使用多线程编程需要保证被多线程多次执行的函数的可重入性，所谓重入性就是函数被多个线程多次调用皆能正常执行。见附录2，有几个保证函数可重入性的条件。</li>\n<li>线程安全：使用多线程编程除了需要保证函数的可重入性还需要保证线程安全，另外，可重入的函数一定是 线程安全的，但是反之不成立。</li>\n<li>共享内存：根据字面意思就很好理解，通过把不同的进程中的逻辑内存映射到同一块物理内存中，进而允许两个进程共享同一块逻辑内存空间。它是进程间通信的一种方式。共享内存本身并没有提供同步机制。</li>\n</ul>\n</li>\n<li>\n<p>相关函数：</p>\n<ul>\n<li>\n<p>多进程相关：</p>\n<ol>\n<li>\n<p><code>fork()</code>：</p>\n<ul>\n<li>\n<p>原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> fork(<span class=\"keyword\">void</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>说明：</p>\n<p>通过复制调用者来创建新进程。这个新的进程简称为子进程。调用该函数的进程称为父进程。</p>\n<p>子进程和父进程运行在不同的内存空间中。在调用该函数的时候，两个进程内存空间都拥有相同的内容。其中一个进程执行的内存写入，文件映射和解除映射操作不会影响到另一个进程。该函数的返回值在父子进程中不同，在父进程中返回子进程PID，在子进程中返回0。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>wait()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> wait(<span class=\"keyword\">int</span> *stat_loc);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>当调用这个函数的时候，当前进程会阻塞等待，该进程的某个子进程运行结束为止。<br>\n该结束的子进程的返回状态被存储在wait()函数的参数stat_loc变量中。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>system();</code></p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">system</span><span class=\"params\">(<span class=\"keyword\">char</span> *command)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>创建新的进程，执行制定命令。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>exec函数族：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execl</span><span class=\"params\">(cONst <span class=\"keyword\">char</span> *path, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *arg, ...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execlp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *file, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *arg, ...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execle</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *arg, ..., <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> envp[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execv</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execvp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *file, <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execve</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *filename, <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> argv[], <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>exec 函数族<br>\nexecve 函数是该族的基础函数，其他函数是由该函数封装而来<br>\nexec 族被用启动新的指定路径下的程序来替换当前的程序。<br>\n函数名称后面的后缀不同参数不尽相同见下面附录1。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>exit()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">exit</span><span class=\"params\">(<span class=\"keyword\">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>终止进程并返回状态码。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>多线程相关：</p>\n<ol>\n<li>\n<p><code>pthread_create()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_create</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> *thread, <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_attr_t</span> *attr,<span class=\"keyword\">void</span> *(*start_routine) (<span class=\"keyword\">void</span> *), <span class=\"keyword\">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li>作用：创建线程</li>\n<li>该函数开始一个新的线程在调用该函数的进程中。新开始的线程通过调用<code>start_routine()</code>函数指针指向的函数来执行，arg参数是该函数指针指向的函数唯一的参数。</li>\n<li>该线程可以通过一下方式中的一个终止：\n<ul>\n<li>调用<code>pthread_exit()</code>函数，并确定退出状态值，该值可用于该进程中的调用<code>phread_join()</code>的其他线程。</li>\n<li>该线程执行的函数退出，这相当于调用<code>phread_exit()</code>并带有返回值。</li>\n<li>被取消（见<code>pthread_cancel()</code>）</li>\n<li>调用<code>exit()</code>函数，或者在主函数中执行<code>return</code>。这会导致该进程中所有线程终止。</li>\n</ul>\n</li>\n<li>attr参数指向一个pthread_attr_t类型的结构体，这个参数被用来在线程创建之初确定该线程的属性。</li>\n<li>如果调用该函数成功创建了一个线程，那么该线程的ID会存储在thread参数中。这个标志会在其他的函数中用到。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_join()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_join</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread, <span class=\"keyword\">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li>该函数会等待由thread参数标志的线程终止。如果这个线程已经终止了，那么该函数立即返回。由thread参数标志的线程必须是可连接的。</li>\n<li>如果retval参数不为空，那么该函数会拷贝目标线程的目标线程的退出状态（目标线程提供返回状态值给pthread_exit();）到该参数中。如果目标线程已经被取消了，那么该参数会存储PTHREAD_CANCELED。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_detach()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_detach</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>该函数会把由thread参数指向的线程标记为分离。一个被标记分离的线程终止后，该线程的资源会被系统自动收回，不需要其他线程进程其他的操作。尝试标记已经分离的线程是不明操作，会导致未知错误。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_self()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">pthread_t</span> pthread_self(<span class=\"keyword\">void</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li>该函数会返回调用者的PID，该值与调用<code>thread_create()</code>函数返回的thread值相同。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_equal</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_equal</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> t1, <span class=\"keyword\">pthread_t</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li>该函数比较两个线程的标记t1和t2是否指向同一个线程。</li>\n<li>如果两个标记指向同一个线程会返回一个非零数，反之返回０。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_exit()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_exit</span><span class=\"params\">(<span class=\"keyword\">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n</li>\n<li>\n<p>该函数会终止调用该函数的线程，并通过参数retval返回一个值，该值可用于同一进程中的其他线程调用<code>pthread_join()</code>。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>线程同步机制：</p>\n<ol>\n<li>\n<p>互斥：</p>\n<ol>\n<li>\n<p><code>pthread_mutex_init()</code>、<code>pthread_mutex_destroy()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_init</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *<span class=\"keyword\">restrict</span> mutex,<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *<span class=\"keyword\">restrict</span> attr)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li><code>pthread_mutex_destroy()</code>:\n<ul>\n<li>该函数销毁参数mutex引用的的互斥对象，实际上，该互斥对象会变成未初始化的状态。</li>\n<li>一个被销毁的互斥锁可以使用<code>pthread_mutex_init()</code>重新初始化。在互斥锁被销毁后引用该互斥锁会导致未定的引用的错误。</li>\n<li>销毁一个未上锁的初始化互斥对象是安全的。当尝试销毁一个通过其他线程使用的锁定的互斥锁或一个已经被禁用的互斥锁会导致未定义行为的错误。</li>\n</ul>\n</li>\n<li><code>pthread_mutex_init()</code>：\n<ul>\n<li>该函数会初始化一个被参数mutex引用的互斥锁，该互斥锁的属性在参数attr中规定。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_mutex_lock()</code>、<code>pthread_mutex_trylock()</code>和<code>pthread_mutex_unlock</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_lock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_trylock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_unlock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li><code>pthread_mutex_lock()</code>\n<ul>\n<li>该函数会把参数mutex引用的互斥锁上锁返回０或者EOWNERDEAD，如果该互斥锁已经被其他线程上锁了，那么该线程会阻塞，直到该互斥锁可用。</li>\n</ul>\n</li>\n<li><code>pthread_mutex_trylock()</code>\n<ul>\n<li>pthread_mutex_trylock()函数等效于pthread_mutex_lock()，除非mutex引用的互斥对象当前被锁定（由任何线程，包括当前线程），则调用应立即返回。</li>\n</ul>\n</li>\n<li><code>pthread_mutex_unlock()</code>\n<ul>\n<li>pthread_mutex_unlock()函数将释放互斥锁引用的互斥锁对象。 释放互斥锁的方式取决于互斥锁的类型属性。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>读写锁：</p>\n<ol>\n<li>\n<p>``pthread_rwlock_init()<code>、</code>pthread_rwlock_destory()`：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_init</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *<span class=\"keyword\">restrict</span> rwlock,<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_rwlockattr_t</span> *<span class=\"keyword\">restrict</span> attr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pthread_rwlock_t</span> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li>``pthread_rwlock_init()`函数会分配参数rwkock参数引用的读写所所需的所有资源，并将读写锁初始化为具有参数attr指定的属性，并置为解锁状态，如果attr为NULL，则应使用默认的读写锁属性; 效果与传递默认读写锁属性对象的地址相同。</li>\n<li><code>pthread_rwlock_destory()</code>函数将销毁rwlock引用的读写锁对象，并释放锁使用的所有资源。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_rwlock_rdlock()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_tryrdlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_rdlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>两个函数函数都会对由rwlock引用的读写锁解开读锁。但是对于<code>pthread_rwlock_rdlock()</code>函数如果写入权限没有上锁并且互斥锁上没有写入权限被阻塞，则调用线程获取读锁定。调用该函数的线程读权限会被上锁。try函数遇到这种情况会返回调用失败两个函数都是成功返回０。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_rwlock_wrlock()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_trywrlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_wrlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>两个函数同样都会为调用者加写权限锁，但是try函数回去尝试，也就是说如果任何线程当前持有rwlock（用于读或写），函数将调用失败。但是另一个函数遇到这种情况会阻塞。函数执行成功返回０。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_rwlock_unlock()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_unlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>该函数将释放由rwlock引用的读写锁对象上的锁。 如果读写锁定rwlock未被调用线程保持，则结果是不确定的。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>条件变量：</p>\n<ol>\n<li>\n<p><code>thread_cond_init()</code>、<code>thread_cond_destory()</code></p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_init</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *<span class=\"keyword\">restrict</span> cond,<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_condattr_t</span> *<span class=\"keyword\">restrict</span> attr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p><code>pthread_cond_destroy()</code>函数将销毁由cond指定的给定条件变量; 实际上，对象会处于未初始化状态。可以使用<code>pthread_cond_init()</code>重新初始化已销毁的条件变量对象; 在对象被销毁之后引用该对象的结果是未定义的。<code>pthread_cond_init()</code>函数应使用attr引用的属性初始化cond引用的条件变量。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>thread_cond_wait()</code>、<code>thread_cond_timedwait()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_timedwait</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *<span class=\"keyword\">restrict</span> cond, <span class=\"keyword\">pthread_mutex_t</span> *<span class=\"keyword\">restrict</span> mutex, <span class=\"keyword\">const</span> struct timespec *<span class=\"keyword\">restrict</span> abstime)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_wait</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *<span class=\"keyword\">restrict</span> cond, <span class=\"keyword\">pthread_mutex_t</span> *<span class=\"keyword\">restrict</span> mutex)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>两个函数都会阻塞条件变量。 应用程序应确保在调用线程锁定互斥锁的情况下调用这些函数; 否则，会产生错误或未定义的行为（对于其他互斥锁）。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>thread_cond_signal()</code>、<code>thread_cond_broadcast()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_broadcast</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_signal</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p><code>pthread_cond_broadcast()</code>函数将取消阻止当前在指定条件变量cond上阻塞的所有线程。<code>pthread_cond_signal()</code>函数应解除阻塞在指定条件变量cond上阻塞的至少一个线程（如果在cond上阻塞了任何线程）。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>共享内存相关：</p>\n<ol>\n<li>\n<p><code>shmget()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/ipc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/shm.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li>\n<p>该函数返回与参数key相关联的共享内存片段的标识符（identifier）。</p>\n</li>\n<li>\n<p>该函数可以用于获取先前创建的共享内存的idenfifier（当shmflg为0并且key值不是IPC_PRIVATE&lt; 预定义宏，见附录3 &gt;的时候）</p>\n</li>\n<li>\n<p>该函数还可以用于创建一个新共享内存，新的共享内存大小为size参数向上取整到PAGE_SIZE(预定义宏，见附录3)。使用该函数创建新的共享内存需满足如下条件：</p>\n</li>\n<li>\n<ol>\n<li>key没有与它相对应的共享内存(无论参数key的值是不是IPC_PRIVATE（预定义宏，见附录3）)</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>shmflg参数指定了IPC_CREAT（预定义宏，见附录3）</li>\n</ol>\n</li>\n<li>\n<p>如果参数shmflg指定了IPC_CREAT和IPC_EXECL并且key 已经存在与其相关联的共享内存，那么shmget函数创建新的共享内存失败，并且erron会被设置为EEXIST。(这有点像O_CREAT | O_EXCL 组合对于open()函数带来的影响)</p>\n</li>\n<li>\n<p>shmflg参数的取值如下：</p>\n</li>\n<li>\n<p>IPC_CREAT IPC_EXCL、SHM_HUGETLB、SHM_HUGE2MB(SHM_HUGE_1GB)、SHM_NORESERVE（详情见附录3）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>shmat()</code>、<code>shmdt()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/shm.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">shmat</span><span class=\"params\">(<span class=\"keyword\">int</span> shmid, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *shmaddr, <span class=\"keyword\">int</span> shmflg)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmdt</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li>shmat();</li>\n<li>该函数把通过shmid标志的共享内存段链接到调用该函数的进程所在的地址空间中。</li>\n<li>这个被链接的地址空间由shmaddr参数的如下定义所规定：\n<ol>\n<li>如果shmaddr参数为空，系统会选择一个合适的（未使用的）对齐页地址去链接共享内存。</li>\n<li>如果shmaddr参数不为空并且shmflg参数指定了SHMLBA(见附录3)，会链接到shmaddr参数向下取整到离SHMLBA倍数最近值的地址。</li>\n<li>除此之外，一定会链接到shmaddr 附近的对齐页地址。</li>\n</ol>\n</li>\n<li>除了SHM_RND以外，shmflg位掩码参数还可能使用到一下规定的标志：</li>\n<li>SHM_EXEC、SHM_RDONLY、SHM_REMAP（详细说明见附录3）</li>\n<li>shmdt();</li>\n<li>与上面的函数相反，该函数通过shmid表示的共享内存段从调用该用书的进程所在的地址空间中断开。</li>\n<li>这个被断开的共享内存段必须是目前链接的，并且shmaddr参数的值为调用shmat()函数的返回值。</li>\n<li>如果shmdt()调用成功，系统会更新与共享内存相关联的shmid_ds结构体，该结构体成员如下：</li>\n<li>shm_ttime : 被设置为当前时间。</li>\n<li>shm_lpid : 被设置为被调用的进程的进程ID。</li>\n<li>shm_nattch ：这个值逐一递减，如果这个值减为0并且这个共享内存段被标记为删除，那么这个共享内存段就被删除了。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>shmctl()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/ipc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/shm.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmctl</span><span class=\"params\">(<span class=\"keyword\">int</span> shmid, <span class=\"keyword\">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>该函数执行由cmd参数指定的操作，cmd参数存储在由shmid参数存储的识别码指向的共享内存段。</p>\n</li>\n<li>\n<p>buf参数是一个shmid_ds结构体指针，shmid_ds结构体在头文件&lt;sys/shm.h&gt;中定义，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">shmid_ds</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">shm_perm</span>;</span>\t<span class=\"comment\">/* 所有权和权限 */</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> shm_segsz;\t\t\t<span class=\"comment\">/* 段大小（单位：字节） */</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span> shm_atime;\t\t\t<span class=\"comment\">/* 最后的链接时间 */</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span> shm_dtime;\t\t\t<span class=\"comment\">/* 最后的断开链接时间 */</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span> shm_ctime;\t\t\t<span class=\"comment\">/* 最后的更改时间 */</span></span><br><span class=\"line\">    <span class=\"keyword\">pid_t</span>  shm_cpid;\t\t\t<span class=\"comment\">/* 创建者的PID */</span></span><br><span class=\"line\">    <span class=\"keyword\">pid_t</span>  shm_lpid;\t\t\t<span class=\"comment\">/* 最后的shmat()函数或shmdt()函数的pid */</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">ipc_perm结构体的定义如下（其中udi、gid和mode可设置为IPC_SET）：</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">key_t</span>\t\t\t__key;\t\t<span class=\"comment\">/* 提供给shmget()函数的键值 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">uid_t</span>\t\t\tuid;\t\t<span class=\"comment\">/* 有效的拥有者的UID */</span></span><br><span class=\"line\">\t<span class=\"keyword\">gid_t</span>\t\t\tgid;\t\t<span class=\"comment\">/* 有效的拥有者的GID */</span></span><br><span class=\"line\">\t<span class=\"keyword\">uid_t</span>\t\t\tcuid;\t\t<span class=\"comment\">/* 有效的创建者UID */</span></span><br><span class=\"line\">\t<span class=\"keyword\">gid_t</span> \t\t\tcgid;\t\t<span class=\"comment\">/* 有效的创建者GID */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span>\tmode;\t\t<span class=\"comment\">/* 权限 + SHM_DEST 和 SHM_LOCKED 标记 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span>\t__seq;\t\t<span class=\"comment\">/* 序列号 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>cmd参数的有效值如下：</p>\n<p>IPC_STAT、IPC_SET IPC_RMID、IPC_INFO、SHM_INFO、SHM_STAT、SHM_LOCK、SHM_UNLOCK 。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<ul>\n<li>\n<p>附录1（摘自网络）：</p>\n<table>\n<thead>\n<tr>\n<th>后缀</th>\n<th>参数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>l</td>\n<td>接收以逗号为分隔的参数列表，以NULL为结束符</td>\n</tr>\n<tr>\n<td>v</td>\n<td>接收以NULL为结束的字符串数组</td>\n</tr>\n<tr>\n<td>p</td>\n<td>接收以NULL为结束的字符串数组指针，并可以利用DOS的PATH变量查找子程序文件</td>\n</tr>\n<tr>\n<td>e</td>\n<td>传递环境变量。</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>附录2（摘自网络）：</p>\n<ol>\n<li>不在函数内部使用静态或全局数据。</li>\n<li>不返回静态或全局数据，所有数据都由函数的调用者提供。</li>\n<li>使用本地数据，或通过拷贝全局数据到本地来保护全局数据。</li>\n<li>不调用不可重入性函数。</li>\n</ol>\n</li>\n<li>\n<p>附录三（翻译自man手册）：</p>\n<table>\n<thead>\n<tr>\n<th>宏名称</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IPC_CREAT</td>\n<td>创建一个新的段，如果这个标志没有被使用，shmget()函数将会寻找与这个段相对应的key参数值，并且检查使用者是否有读取这个段的权限。</td>\n</tr>\n<tr>\n<td>IPC_EXCL</td>\n<td>该标志与IPC_BREAT一起被用作确认本次创建共享内存的调用成功与否。</td>\n</tr>\n<tr>\n<td>IPC_PRIVATE</td>\n<td>它不是一个标志字段，而是一个key_t类型的值，如果函数调用的时候key参数中存储这个特殊的值，系统调用会忽略除了shmflg中最不重要的9位意外的所有并且创建一个新的共享内存。</td>\n</tr>\n<tr>\n<td>IPC_STAT</td>\n<td>从内核中拷贝shmid中由buf指向的shmid_ds结构相关的数据结构信息。对于共享内存段调用者必须拥有可读权限。</td>\n</tr>\n<tr>\n<td>IPC_SET</td>\n<td>往参数buf指针指向的shmid_ds结构体的某些成员写入与该共享内存段相关联的内核数据结构，并且更新该结构体中的shm_ctime成员。以下成员可能会被改变：shm_perm.uid、shm_perm.gid和（最不重要的九位）shm_perm.mode。调用进程的有效UID必须与拥有者（shm_perm.uid）或共享内存的创建者（shm_per.cuid）相匹配，或者与一定是拥有特权的调用者相匹配。</td>\n</tr>\n<tr>\n<td>IPC_RMID</td>\n<td>标记被销毁的共享内存段，实际上，这个共享内存段实在进程销毁的时候被销毁。（当shmid_ds相关构成员shm_nattch为空的时候）。调用者必须是共享内存的拥有者或者创建者，或者拥有特权。buf参数被忽略。</td>\n</tr>\n<tr>\n<td>SHM_NORESREVE</td>\n<td>（从linux内核2.6.15以后）这个标志与mmap()函数的MAP_NORESERVE 标志具有同样的目的。不保留交换空间对于共享内存段，当交换空间被保留了，他会保证共享内存是可用的。当交换空间没有被保留，并且物理内存不可用，那么可能会在写入时获取SIGSEGV。也可以查阅<code>/proc/sys/vm/overcommit</code>文件。</td>\n</tr>\n<tr>\n<td>SHM_REMAP</td>\n<td>（LInux特有）这个标志指定了在共享内存段中从shmaddr参数开始到段最后的范围内的段映射应该被替换成现有的映射。（一般情况下，一个EINVAL错误可能是由于一个映射在地址范围内已经存在）在这个案例中，shmaddr参数必须不为空。</td>\n</tr>\n<tr>\n<td>SHM_RDONLY</td>\n<td>以只读的方式链接共享内存段。进程对共享内存段必须有读取权限。如果标志没有被指定，那么共享内存段会被以可读可写方式链接，并且进程对于该共享内存段必须拥有可读和可写权限。但这不意味着对共享内存段有只写权限。</td>\n</tr>\n<tr>\n<td>SHM_EXEC</td>\n<td>（Linux特有，从linux2.6.9以后）允许执行共享内存段中的内容。调用者对于共享内存段必须拥有可执行权限。</td>\n</tr>\n<tr>\n<td>SHM_HUGETLB</td>\n<td>（从linux内核2.6版以后）为共享内存段分配巨大空间，详情见linux内核源码文件中<code>Documentation/vm/hugetlbpage.txt</code>获取更多信息。</td>\n</tr>\n<tr>\n<td>SHM_HUGE2MB,SHM_HUGE1GB</td>\n<td>（从linux内核3.8之后）与SHM_HUGETLB一起被用作选择替代hugetlb大页面的大小（分别是2MB和1GB），并且支持超过hugetlb大页面的大小。</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>参考资料：</p>\n<blockquote>\n<p>参考网站：<a href=\"https://blog.csdn.net/hello_bravo_/article/details/52497401\" target=\"_blank\" rel=\"noopener\">多进程编程总结</a>、<a href=\"https://www.xuebuyuan.com/943688.html\" target=\"_blank\" rel=\"noopener\">C语言多进程编程</a>、<a href=\"https://www.cnblogs.com/alanfeng/p/5055141.html\" target=\"_blank\" rel=\"noopener\">多线程和多进程的区别（小结）</a>、<a href=\"https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C/7387706\" target=\"_blank\" rel=\"noopener\">百度百科：程序并发执行</a>、<a href=\"https://blog.csdn.net/aile770339804/article/details/7443921\" target=\"_blank\" rel=\"noopener\">linux下c语言编程exec函数使用</a></p>\n<p>参考书籍：<a href=\"http://product.dangdang.com/25154067.html\" target=\"_blank\" rel=\"noopener\">C语言核心技术</a> 、man手册</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"进程-线程及共享内存学习笔记\"><a class=\"markdownIt-Anchor\" href=\"#进程-线程及共享内存学习笔记\"></a> 进程、线程及共享内存学习笔记</h2>\n<blockquote>\n<p>系统环境：deepin Linux，语言环境：Linux C<br>\n欢迎大家转载，转载请注明出处，谢谢！</p>\n</blockquote>\n<ol>\n<li>\n<p>理论基础：</p>\n<ul>\n<li>进程：计算机上每个执行的活动，运行一个可执行程序是一个进程，打开一个软件是一个进程，打开一个终端是一个进程等等。</li>\n<li>多进程：为了充分利用计算机资源产生了多进程的执行方式。通俗来讲就是在同一时间做多个事情，从而可以充分利用计算机资源还可以提高程序的执行效率。在创建一个新的子进程后，子进程会会获得计算机分配的资源，并拷贝父进程的数据。</li>\n<li>子进程与父进程：我们编写的一段程序运行时就是一个进程，当我们在这段代码中调用特定函数新创建一个进程时，新创建的进程就是当前进程的子进程，而对于新创建的进程来说，当前进程就是它的父进程，子进程通过拷贝等手段继承父进程在创建子进程之前的数据、属性等。</li>\n<li>多线程：上面说到进程是计算机上执行的每个活动。在实际编程中，一个进程中会有很多任务需要做。从而引发思考：一个进程中的多个任务是否也可以并发的执行？因为有些任务之间是没有联系的，也就是说有些任务完全可以同时进行而没有依赖问题。答案就是线程。与多进程相同的是，多线程也是为了让计算机资源得到充分利用并且程序的执行效率也会得到提高，与多进程不同的是，多线程并没有拷贝这种需求，它实际上是把一个进程分成多个片段。</li>\n<li>重入性：尽管多线程系统开销少，但是也难免有缺陷，那就是重入性问题，使用多线程编程需要保证被多线程多次执行的函数的可重入性，所谓重入性就是函数被多个线程多次调用皆能正常执行。见附录2，有几个保证函数可重入性的条件。</li>\n<li>线程安全：使用多线程编程除了需要保证函数的可重入性还需要保证线程安全，另外，可重入的函数一定是 线程安全的，但是反之不成立。</li>\n<li>共享内存：根据字面意思就很好理解，通过把不同的进程中的逻辑内存映射到同一块物理内存中，进而允许两个进程共享同一块逻辑内存空间。它是进程间通信的一种方式。共享内存本身并没有提供同步机制。</li>\n</ul>\n</li>\n<li>\n<p>相关函数：</p>\n<ul>\n<li>\n<p>多进程相关：</p>\n<ol>\n<li>\n<p><code>fork()</code>：</p>\n<ul>\n<li>\n<p>原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> fork(<span class=\"keyword\">void</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>说明：</p>\n<p>通过复制调用者来创建新进程。这个新的进程简称为子进程。调用该函数的进程称为父进程。</p>\n<p>子进程和父进程运行在不同的内存空间中。在调用该函数的时候，两个进程内存空间都拥有相同的内容。其中一个进程执行的内存写入，文件映射和解除映射操作不会影响到另一个进程。该函数的返回值在父子进程中不同，在父进程中返回子进程PID，在子进程中返回0。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>wait()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> wait(<span class=\"keyword\">int</span> *stat_loc);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>当调用这个函数的时候，当前进程会阻塞等待，该进程的某个子进程运行结束为止。<br>\n该结束的子进程的返回状态被存储在wait()函数的参数stat_loc变量中。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>system();</code></p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">system</span><span class=\"params\">(<span class=\"keyword\">char</span> *command)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>创建新的进程，执行制定命令。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>exec函数族：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execl</span><span class=\"params\">(cONst <span class=\"keyword\">char</span> *path, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *arg, ...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execlp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *file, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *arg, ...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execle</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *arg, ..., <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> envp[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execv</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execvp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *file, <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execve</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *filename, <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> argv[], <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>exec 函数族<br>\nexecve 函数是该族的基础函数，其他函数是由该函数封装而来<br>\nexec 族被用启动新的指定路径下的程序来替换当前的程序。<br>\n函数名称后面的后缀不同参数不尽相同见下面附录1。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>exit()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">exit</span><span class=\"params\">(<span class=\"keyword\">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>终止进程并返回状态码。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>多线程相关：</p>\n<ol>\n<li>\n<p><code>pthread_create()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_create</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> *thread, <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_attr_t</span> *attr,<span class=\"keyword\">void</span> *(*start_routine) (<span class=\"keyword\">void</span> *), <span class=\"keyword\">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li>作用：创建线程</li>\n<li>该函数开始一个新的线程在调用该函数的进程中。新开始的线程通过调用<code>start_routine()</code>函数指针指向的函数来执行，arg参数是该函数指针指向的函数唯一的参数。</li>\n<li>该线程可以通过一下方式中的一个终止：\n<ul>\n<li>调用<code>pthread_exit()</code>函数，并确定退出状态值，该值可用于该进程中的调用<code>phread_join()</code>的其他线程。</li>\n<li>该线程执行的函数退出，这相当于调用<code>phread_exit()</code>并带有返回值。</li>\n<li>被取消（见<code>pthread_cancel()</code>）</li>\n<li>调用<code>exit()</code>函数，或者在主函数中执行<code>return</code>。这会导致该进程中所有线程终止。</li>\n</ul>\n</li>\n<li>attr参数指向一个pthread_attr_t类型的结构体，这个参数被用来在线程创建之初确定该线程的属性。</li>\n<li>如果调用该函数成功创建了一个线程，那么该线程的ID会存储在thread参数中。这个标志会在其他的函数中用到。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_join()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_join</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread, <span class=\"keyword\">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li>该函数会等待由thread参数标志的线程终止。如果这个线程已经终止了，那么该函数立即返回。由thread参数标志的线程必须是可连接的。</li>\n<li>如果retval参数不为空，那么该函数会拷贝目标线程的目标线程的退出状态（目标线程提供返回状态值给pthread_exit();）到该参数中。如果目标线程已经被取消了，那么该参数会存储PTHREAD_CANCELED。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_detach()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_detach</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>该函数会把由thread参数指向的线程标记为分离。一个被标记分离的线程终止后，该线程的资源会被系统自动收回，不需要其他线程进程其他的操作。尝试标记已经分离的线程是不明操作，会导致未知错误。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_self()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">pthread_t</span> pthread_self(<span class=\"keyword\">void</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li>该函数会返回调用者的PID，该值与调用<code>thread_create()</code>函数返回的thread值相同。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_equal</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_equal</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> t1, <span class=\"keyword\">pthread_t</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li>该函数比较两个线程的标记t1和t2是否指向同一个线程。</li>\n<li>如果两个标记指向同一个线程会返回一个非零数，反之返回０。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_exit()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_exit</span><span class=\"params\">(<span class=\"keyword\">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n</li>\n<li>\n<p>该函数会终止调用该函数的线程，并通过参数retval返回一个值，该值可用于同一进程中的其他线程调用<code>pthread_join()</code>。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>线程同步机制：</p>\n<ol>\n<li>\n<p>互斥：</p>\n<ol>\n<li>\n<p><code>pthread_mutex_init()</code>、<code>pthread_mutex_destroy()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_init</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *<span class=\"keyword\">restrict</span> mutex,<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *<span class=\"keyword\">restrict</span> attr)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li><code>pthread_mutex_destroy()</code>:\n<ul>\n<li>该函数销毁参数mutex引用的的互斥对象，实际上，该互斥对象会变成未初始化的状态。</li>\n<li>一个被销毁的互斥锁可以使用<code>pthread_mutex_init()</code>重新初始化。在互斥锁被销毁后引用该互斥锁会导致未定的引用的错误。</li>\n<li>销毁一个未上锁的初始化互斥对象是安全的。当尝试销毁一个通过其他线程使用的锁定的互斥锁或一个已经被禁用的互斥锁会导致未定义行为的错误。</li>\n</ul>\n</li>\n<li><code>pthread_mutex_init()</code>：\n<ul>\n<li>该函数会初始化一个被参数mutex引用的互斥锁，该互斥锁的属性在参数attr中规定。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_mutex_lock()</code>、<code>pthread_mutex_trylock()</code>和<code>pthread_mutex_unlock</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_lock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_trylock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_unlock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li><code>pthread_mutex_lock()</code>\n<ul>\n<li>该函数会把参数mutex引用的互斥锁上锁返回０或者EOWNERDEAD，如果该互斥锁已经被其他线程上锁了，那么该线程会阻塞，直到该互斥锁可用。</li>\n</ul>\n</li>\n<li><code>pthread_mutex_trylock()</code>\n<ul>\n<li>pthread_mutex_trylock()函数等效于pthread_mutex_lock()，除非mutex引用的互斥对象当前被锁定（由任何线程，包括当前线程），则调用应立即返回。</li>\n</ul>\n</li>\n<li><code>pthread_mutex_unlock()</code>\n<ul>\n<li>pthread_mutex_unlock()函数将释放互斥锁引用的互斥锁对象。 释放互斥锁的方式取决于互斥锁的类型属性。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>读写锁：</p>\n<ol>\n<li>\n<p>``pthread_rwlock_init()<code>、</code>pthread_rwlock_destory()`：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_init</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *<span class=\"keyword\">restrict</span> rwlock,<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_rwlockattr_t</span> *<span class=\"keyword\">restrict</span> attr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pthread_rwlock_t</span> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li>``pthread_rwlock_init()`函数会分配参数rwkock参数引用的读写所所需的所有资源，并将读写锁初始化为具有参数attr指定的属性，并置为解锁状态，如果attr为NULL，则应使用默认的读写锁属性; 效果与传递默认读写锁属性对象的地址相同。</li>\n<li><code>pthread_rwlock_destory()</code>函数将销毁rwlock引用的读写锁对象，并释放锁使用的所有资源。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_rwlock_rdlock()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_tryrdlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_rdlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>两个函数函数都会对由rwlock引用的读写锁解开读锁。但是对于<code>pthread_rwlock_rdlock()</code>函数如果写入权限没有上锁并且互斥锁上没有写入权限被阻塞，则调用线程获取读锁定。调用该函数的线程读权限会被上锁。try函数遇到这种情况会返回调用失败两个函数都是成功返回０。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_rwlock_wrlock()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_trywrlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_wrlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>两个函数同样都会为调用者加写权限锁，但是try函数回去尝试，也就是说如果任何线程当前持有rwlock（用于读或写），函数将调用失败。但是另一个函数遇到这种情况会阻塞。函数执行成功返回０。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pthread_rwlock_unlock()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_rwlock_unlock</span><span class=\"params\">(<span class=\"keyword\">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>该函数将释放由rwlock引用的读写锁对象上的锁。 如果读写锁定rwlock未被调用线程保持，则结果是不确定的。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>条件变量：</p>\n<ol>\n<li>\n<p><code>thread_cond_init()</code>、<code>thread_cond_destory()</code></p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_destroy</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_init</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *<span class=\"keyword\">restrict</span> cond,<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_condattr_t</span> *<span class=\"keyword\">restrict</span> attr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p><code>pthread_cond_destroy()</code>函数将销毁由cond指定的给定条件变量; 实际上，对象会处于未初始化状态。可以使用<code>pthread_cond_init()</code>重新初始化已销毁的条件变量对象; 在对象被销毁之后引用该对象的结果是未定义的。<code>pthread_cond_init()</code>函数应使用attr引用的属性初始化cond引用的条件变量。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>thread_cond_wait()</code>、<code>thread_cond_timedwait()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_timedwait</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *<span class=\"keyword\">restrict</span> cond, <span class=\"keyword\">pthread_mutex_t</span> *<span class=\"keyword\">restrict</span> mutex, <span class=\"keyword\">const</span> struct timespec *<span class=\"keyword\">restrict</span> abstime)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_wait</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *<span class=\"keyword\">restrict</span> cond, <span class=\"keyword\">pthread_mutex_t</span> *<span class=\"keyword\">restrict</span> mutex)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p>两个函数都会阻塞条件变量。 应用程序应确保在调用线程锁定互斥锁的情况下调用这些函数; 否则，会产生错误或未定义的行为（对于其他互斥锁）。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>thread_cond_signal()</code>、<code>thread_cond_broadcast()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_broadcast</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_signal</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<p><code>pthread_cond_broadcast()</code>函数将取消阻止当前在指定条件变量cond上阻塞的所有线程。<code>pthread_cond_signal()</code>函数应解除阻塞在指定条件变量cond上阻塞的至少一个线程（如果在cond上阻塞了任何线程）。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>共享内存相关：</p>\n<ol>\n<li>\n<p><code>shmget()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/ipc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/shm.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li>\n<p>该函数返回与参数key相关联的共享内存片段的标识符（identifier）。</p>\n</li>\n<li>\n<p>该函数可以用于获取先前创建的共享内存的idenfifier（当shmflg为0并且key值不是IPC_PRIVATE&lt; 预定义宏，见附录3 &gt;的时候）</p>\n</li>\n<li>\n<p>该函数还可以用于创建一个新共享内存，新的共享内存大小为size参数向上取整到PAGE_SIZE(预定义宏，见附录3)。使用该函数创建新的共享内存需满足如下条件：</p>\n</li>\n<li>\n<ol>\n<li>key没有与它相对应的共享内存(无论参数key的值是不是IPC_PRIVATE（预定义宏，见附录3）)</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>shmflg参数指定了IPC_CREAT（预定义宏，见附录3）</li>\n</ol>\n</li>\n<li>\n<p>如果参数shmflg指定了IPC_CREAT和IPC_EXECL并且key 已经存在与其相关联的共享内存，那么shmget函数创建新的共享内存失败，并且erron会被设置为EEXIST。(这有点像O_CREAT | O_EXCL 组合对于open()函数带来的影响)</p>\n</li>\n<li>\n<p>shmflg参数的取值如下：</p>\n</li>\n<li>\n<p>IPC_CREAT IPC_EXCL、SHM_HUGETLB、SHM_HUGE2MB(SHM_HUGE_1GB)、SHM_NORESERVE（详情见附录3）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>shmat()</code>、<code>shmdt()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/shm.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">shmat</span><span class=\"params\">(<span class=\"keyword\">int</span> shmid, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *shmaddr, <span class=\"keyword\">int</span> shmflg)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmdt</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数说明：</p>\n<ul>\n<li>shmat();</li>\n<li>该函数把通过shmid标志的共享内存段链接到调用该函数的进程所在的地址空间中。</li>\n<li>这个被链接的地址空间由shmaddr参数的如下定义所规定：\n<ol>\n<li>如果shmaddr参数为空，系统会选择一个合适的（未使用的）对齐页地址去链接共享内存。</li>\n<li>如果shmaddr参数不为空并且shmflg参数指定了SHMLBA(见附录3)，会链接到shmaddr参数向下取整到离SHMLBA倍数最近值的地址。</li>\n<li>除此之外，一定会链接到shmaddr 附近的对齐页地址。</li>\n</ol>\n</li>\n<li>除了SHM_RND以外，shmflg位掩码参数还可能使用到一下规定的标志：</li>\n<li>SHM_EXEC、SHM_RDONLY、SHM_REMAP（详细说明见附录3）</li>\n<li>shmdt();</li>\n<li>与上面的函数相反，该函数通过shmid表示的共享内存段从调用该用书的进程所在的地址空间中断开。</li>\n<li>这个被断开的共享内存段必须是目前链接的，并且shmaddr参数的值为调用shmat()函数的返回值。</li>\n<li>如果shmdt()调用成功，系统会更新与共享内存相关联的shmid_ds结构体，该结构体成员如下：</li>\n<li>shm_ttime : 被设置为当前时间。</li>\n<li>shm_lpid : 被设置为被调用的进程的进程ID。</li>\n<li>shm_nattch ：这个值逐一递减，如果这个值减为0并且这个共享内存段被标记为删除，那么这个共享内存段就被删除了。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>shmctl()</code>：</p>\n<ul>\n<li>\n<p>函数原型及头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/ipc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/shm.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmctl</span><span class=\"params\">(<span class=\"keyword\">int</span> shmid, <span class=\"keyword\">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>该函数执行由cmd参数指定的操作，cmd参数存储在由shmid参数存储的识别码指向的共享内存段。</p>\n</li>\n<li>\n<p>buf参数是一个shmid_ds结构体指针，shmid_ds结构体在头文件&lt;sys/shm.h&gt;中定义，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">shmid_ds</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">shm_perm</span>;</span>\t<span class=\"comment\">/* 所有权和权限 */</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> shm_segsz;\t\t\t<span class=\"comment\">/* 段大小（单位：字节） */</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span> shm_atime;\t\t\t<span class=\"comment\">/* 最后的链接时间 */</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span> shm_dtime;\t\t\t<span class=\"comment\">/* 最后的断开链接时间 */</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span> shm_ctime;\t\t\t<span class=\"comment\">/* 最后的更改时间 */</span></span><br><span class=\"line\">    <span class=\"keyword\">pid_t</span>  shm_cpid;\t\t\t<span class=\"comment\">/* 创建者的PID */</span></span><br><span class=\"line\">    <span class=\"keyword\">pid_t</span>  shm_lpid;\t\t\t<span class=\"comment\">/* 最后的shmat()函数或shmdt()函数的pid */</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">ipc_perm结构体的定义如下（其中udi、gid和mode可设置为IPC_SET）：</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">key_t</span>\t\t\t__key;\t\t<span class=\"comment\">/* 提供给shmget()函数的键值 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">uid_t</span>\t\t\tuid;\t\t<span class=\"comment\">/* 有效的拥有者的UID */</span></span><br><span class=\"line\">\t<span class=\"keyword\">gid_t</span>\t\t\tgid;\t\t<span class=\"comment\">/* 有效的拥有者的GID */</span></span><br><span class=\"line\">\t<span class=\"keyword\">uid_t</span>\t\t\tcuid;\t\t<span class=\"comment\">/* 有效的创建者UID */</span></span><br><span class=\"line\">\t<span class=\"keyword\">gid_t</span> \t\t\tcgid;\t\t<span class=\"comment\">/* 有效的创建者GID */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span>\tmode;\t\t<span class=\"comment\">/* 权限 + SHM_DEST 和 SHM_LOCKED 标记 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span>\t__seq;\t\t<span class=\"comment\">/* 序列号 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>cmd参数的有效值如下：</p>\n<p>IPC_STAT、IPC_SET IPC_RMID、IPC_INFO、SHM_INFO、SHM_STAT、SHM_LOCK、SHM_UNLOCK 。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<ul>\n<li>\n<p>附录1（摘自网络）：</p>\n<table>\n<thead>\n<tr>\n<th>后缀</th>\n<th>参数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>l</td>\n<td>接收以逗号为分隔的参数列表，以NULL为结束符</td>\n</tr>\n<tr>\n<td>v</td>\n<td>接收以NULL为结束的字符串数组</td>\n</tr>\n<tr>\n<td>p</td>\n<td>接收以NULL为结束的字符串数组指针，并可以利用DOS的PATH变量查找子程序文件</td>\n</tr>\n<tr>\n<td>e</td>\n<td>传递环境变量。</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>附录2（摘自网络）：</p>\n<ol>\n<li>不在函数内部使用静态或全局数据。</li>\n<li>不返回静态或全局数据，所有数据都由函数的调用者提供。</li>\n<li>使用本地数据，或通过拷贝全局数据到本地来保护全局数据。</li>\n<li>不调用不可重入性函数。</li>\n</ol>\n</li>\n<li>\n<p>附录三（翻译自man手册）：</p>\n<table>\n<thead>\n<tr>\n<th>宏名称</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IPC_CREAT</td>\n<td>创建一个新的段，如果这个标志没有被使用，shmget()函数将会寻找与这个段相对应的key参数值，并且检查使用者是否有读取这个段的权限。</td>\n</tr>\n<tr>\n<td>IPC_EXCL</td>\n<td>该标志与IPC_BREAT一起被用作确认本次创建共享内存的调用成功与否。</td>\n</tr>\n<tr>\n<td>IPC_PRIVATE</td>\n<td>它不是一个标志字段，而是一个key_t类型的值，如果函数调用的时候key参数中存储这个特殊的值，系统调用会忽略除了shmflg中最不重要的9位意外的所有并且创建一个新的共享内存。</td>\n</tr>\n<tr>\n<td>IPC_STAT</td>\n<td>从内核中拷贝shmid中由buf指向的shmid_ds结构相关的数据结构信息。对于共享内存段调用者必须拥有可读权限。</td>\n</tr>\n<tr>\n<td>IPC_SET</td>\n<td>往参数buf指针指向的shmid_ds结构体的某些成员写入与该共享内存段相关联的内核数据结构，并且更新该结构体中的shm_ctime成员。以下成员可能会被改变：shm_perm.uid、shm_perm.gid和（最不重要的九位）shm_perm.mode。调用进程的有效UID必须与拥有者（shm_perm.uid）或共享内存的创建者（shm_per.cuid）相匹配，或者与一定是拥有特权的调用者相匹配。</td>\n</tr>\n<tr>\n<td>IPC_RMID</td>\n<td>标记被销毁的共享内存段，实际上，这个共享内存段实在进程销毁的时候被销毁。（当shmid_ds相关构成员shm_nattch为空的时候）。调用者必须是共享内存的拥有者或者创建者，或者拥有特权。buf参数被忽略。</td>\n</tr>\n<tr>\n<td>SHM_NORESREVE</td>\n<td>（从linux内核2.6.15以后）这个标志与mmap()函数的MAP_NORESERVE 标志具有同样的目的。不保留交换空间对于共享内存段，当交换空间被保留了，他会保证共享内存是可用的。当交换空间没有被保留，并且物理内存不可用，那么可能会在写入时获取SIGSEGV。也可以查阅<code>/proc/sys/vm/overcommit</code>文件。</td>\n</tr>\n<tr>\n<td>SHM_REMAP</td>\n<td>（LInux特有）这个标志指定了在共享内存段中从shmaddr参数开始到段最后的范围内的段映射应该被替换成现有的映射。（一般情况下，一个EINVAL错误可能是由于一个映射在地址范围内已经存在）在这个案例中，shmaddr参数必须不为空。</td>\n</tr>\n<tr>\n<td>SHM_RDONLY</td>\n<td>以只读的方式链接共享内存段。进程对共享内存段必须有读取权限。如果标志没有被指定，那么共享内存段会被以可读可写方式链接，并且进程对于该共享内存段必须拥有可读和可写权限。但这不意味着对共享内存段有只写权限。</td>\n</tr>\n<tr>\n<td>SHM_EXEC</td>\n<td>（Linux特有，从linux2.6.9以后）允许执行共享内存段中的内容。调用者对于共享内存段必须拥有可执行权限。</td>\n</tr>\n<tr>\n<td>SHM_HUGETLB</td>\n<td>（从linux内核2.6版以后）为共享内存段分配巨大空间，详情见linux内核源码文件中<code>Documentation/vm/hugetlbpage.txt</code>获取更多信息。</td>\n</tr>\n<tr>\n<td>SHM_HUGE2MB,SHM_HUGE1GB</td>\n<td>（从linux内核3.8之后）与SHM_HUGETLB一起被用作选择替代hugetlb大页面的大小（分别是2MB和1GB），并且支持超过hugetlb大页面的大小。</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>参考资料：</p>\n<blockquote>\n<p>参考网站：<a href=\"https://blog.csdn.net/hello_bravo_/article/details/52497401\" target=\"_blank\" rel=\"noopener\">多进程编程总结</a>、<a href=\"https://www.xuebuyuan.com/943688.html\" target=\"_blank\" rel=\"noopener\">C语言多进程编程</a>、<a href=\"https://www.cnblogs.com/alanfeng/p/5055141.html\" target=\"_blank\" rel=\"noopener\">多线程和多进程的区别（小结）</a>、<a href=\"https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C/7387706\" target=\"_blank\" rel=\"noopener\">百度百科：程序并发执行</a>、<a href=\"https://blog.csdn.net/aile770339804/article/details/7443921\" target=\"_blank\" rel=\"noopener\">linux下c语言编程exec函数使用</a></p>\n<p>参考书籍：<a href=\"http://product.dangdang.com/25154067.html\" target=\"_blank\" rel=\"noopener\">C语言核心技术</a> 、man手册</p>\n</blockquote>\n</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/八大排序算法总结/1.希尔排序.webp","slug":"1.希尔排序.webp","post":"ck8qr69dp00195d3a1j9fbwao","modified":0,"renderable":0},{"_id":"source/_posts/BASH脚本实现素数线性筛/title.jpg","slug":"title.jpg","post":"ck8qr69cw00025d3ah6mys7i3","modified":0,"renderable":0},{"_id":"source/_posts/HDU-2072/title.jpg","slug":"title.jpg","post":"ck8qr69d5000a5d3ar8hvyt0c","modified":1,"renderable":0},{"_id":"source/_posts/HDU-1072/wallhaven-kwlwy6.jpg","slug":"wallhaven-kwlwy6.jpg","post":"ck8qr69d300075d3a5tzw7156","modified":1,"renderable":0},{"_id":"source/_posts/hexo低成本搭建静态网页博客/title.jpg","slug":"title.jpg","post":"ck8qr69dd000m5d3adydx0myt","modified":1,"renderable":0},{"_id":"source/_posts/CPU信息获取/title.jpg","slug":"title.jpg","post":"ck8qr69d400095d3ajohn3de9","modified":1,"renderable":0},{"_id":"source/_posts/Codeforces-787a/title.jpg","slug":"title.jpg","post":"ck8qr69d100055d3av8d6sr50","modified":1,"renderable":0},{"_id":"source/_posts/HDU-1222/title.jpg","slug":"title.jpg","post":"ck8qr69cy00035d3amv15fi4m","modified":1,"renderable":0},{"_id":"source/_posts/HDU-1276/title.jpg","slug":"title.jpg","post":"ck8qr69d200065d3aufvzldkm","modified":1,"renderable":0},{"_id":"source/_posts/Linux三剑客之awk的使用/title.jpg","slug":"title.jpg","post":"ck8qr69d9000f5d3abzf5hgma","modified":1,"renderable":0},{"_id":"source/_posts/POJ-1979/title.jpg","slug":"title.jpg","post":"ck8qr69da000h5d3avd58szod","modified":1,"renderable":0},{"_id":"source/_posts/MYSQL-笔记1/title.jpg","slug":"title.jpg","post":"ck8qr69d8000d5d3ar1n8iiy3","modified":1,"renderable":0},{"_id":"source/_posts/Linux常见配置文件/title.jpg","slug":"title.jpg","post":"ck8qr69de000p5d3a07s9nc10","modified":1,"renderable":0},{"_id":"source/_posts/deepin系统使用笔记/title.jpg","slug":"title.jpg","post":"ck8qr69de000o5d3a4w2l96lg","modified":1,"renderable":0},{"_id":"source/_posts/linux三剑客之grep的使用/title.jpg","slug":"title.jpg","post":"ck8qr69db000j5d3acz0ms85e","modified":1,"renderable":0},{"_id":"source/_posts/内存信息获取/title.jpg","slug":"title.jpg","post":"ck8qr69dg000s5d3affd9qkt0","modified":1,"renderable":0},{"_id":"source/_posts/方便的轻文本处理语言-markdown/wallhaven-g8mw63.png","slug":"wallhaven-g8mw63.png","post":"ck8qr69dk000z5d3a0ndwtz9t","modified":1,"renderable":0},{"_id":"source/_posts/服务器健康监控/title.jpg","slug":"title.jpg","post":"ck8qr69dj000x5d3amatbapx7","modified":1,"renderable":0},{"_id":"source/_posts/用户信息获取/title.jpg","slug":"title.jpg","post":"ck8qr69dh000u5d3anvecixx9","modified":1,"renderable":0},{"_id":"source/_posts/进程信息获取/title.jpg","slug":"title.jpg","post":"ck8qr69dm00145d3a0nu52dyo","modified":1,"renderable":0},{"_id":"source/_posts/进程、线程及共享内存学习笔记/title.jpg","slug":"title.jpg","post":"ck8qr69dr001c5d3a5465dxx0","modified":1,"renderable":0},{"_id":"source/_posts/八大排序算法总结/title.jpg","slug":"title.jpg","post":"ck8qr69dp00195d3a1j9fbwao","modified":1,"renderable":0},{"_id":"source/_posts/磁盘信息获取/title.jpg","slug":"title.jpg","post":"ck8qr69dl00125d3avzprafvf","modified":1,"renderable":0},{"_id":"source/_posts/磁盘信息获取/wallhaven-5wm328.jpg","slug":"wallhaven-5wm328.jpg","post":"ck8qr69dl00125d3avzprafvf","modified":1,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"ck8qr69d400095d3ajohn3de9","tag_id":"ck8qr69cz00045d3a2l0czdab","_id":"ck8qr69d8000c5d3aqdfxvohi"},{"post_id":"ck8qr69d400095d3ajohn3de9","tag_id":"ck8qr69d400085d3apjig2t86","_id":"ck8qr69d9000e5d3aungvh0y7"},{"post_id":"ck8qr69cw00025d3ah6mys7i3","tag_id":"ck8qr69cz00045d3a2l0czdab","_id":"ck8qr69db000i5d3a2cqjoh2b"},{"post_id":"ck8qr69cw00025d3ah6mys7i3","tag_id":"ck8qr69d400085d3apjig2t86","_id":"ck8qr69dc000k5d3azuu46eft"},{"post_id":"ck8qr69cw00025d3ah6mys7i3","tag_id":"ck8qr69d7000b5d3a92s87ihm","_id":"ck8qr69dd000n5d3a5bg06pqk"},{"post_id":"ck8qr69cy00035d3amv15fi4m","tag_id":"ck8qr69da000g5d3a3lg7eh54","_id":"ck8qr69dg000r5d3a3asgz7dl"},{"post_id":"ck8qr69cy00035d3amv15fi4m","tag_id":"ck8qr69dc000l5d3abjro5tab","_id":"ck8qr69dh000t5d3apewvan5s"},{"post_id":"ck8qr69dg000s5d3affd9qkt0","tag_id":"ck8qr69cz00045d3a2l0czdab","_id":"ck8qr69di000w5d3ajuasqje9"},{"post_id":"ck8qr69dg000s5d3affd9qkt0","tag_id":"ck8qr69d400085d3apjig2t86","_id":"ck8qr69dk000y5d3aondwelul"},{"post_id":"ck8qr69dh000u5d3anvecixx9","tag_id":"ck8qr69cz00045d3a2l0czdab","_id":"ck8qr69dl00115d3a4b90ourp"},{"post_id":"ck8qr69dh000u5d3anvecixx9","tag_id":"ck8qr69d400085d3apjig2t86","_id":"ck8qr69dm00135d3axeut7pcy"},{"post_id":"ck8qr69d100055d3av8d6sr50","tag_id":"ck8qr69da000g5d3a3lg7eh54","_id":"ck8qr69dn00165d3a2ebfl0nh"},{"post_id":"ck8qr69d100055d3av8d6sr50","tag_id":"ck8qr69di000v5d3amli7nfzw","_id":"ck8qr69dp00185d3armgfjlmb"},{"post_id":"ck8qr69dl00125d3avzprafvf","tag_id":"ck8qr69cz00045d3a2l0czdab","_id":"ck8qr69dr001b5d3axanxekhy"},{"post_id":"ck8qr69dl00125d3avzprafvf","tag_id":"ck8qr69d400085d3apjig2t86","_id":"ck8qr69ds001d5d3atydancs8"},{"post_id":"ck8qr69dm00145d3a0nu52dyo","tag_id":"ck8qr69cz00045d3a2l0czdab","_id":"ck8qr69ds001f5d3a065erxdj"},{"post_id":"ck8qr69dm00145d3a0nu52dyo","tag_id":"ck8qr69d400085d3apjig2t86","_id":"ck8qr69dt001g5d3a3s7cu8gh"},{"post_id":"ck8qr69do00175d3a94a9zth2","tag_id":"ck8qr69cz00045d3a2l0czdab","_id":"ck8qr69dt001i5d3a8bgb1g5x"},{"post_id":"ck8qr69do00175d3a94a9zth2","tag_id":"ck8qr69d400085d3apjig2t86","_id":"ck8qr69du001j5d3ah5tal835"},{"post_id":"ck8qr69d200065d3aufvzldkm","tag_id":"ck8qr69da000g5d3a3lg7eh54","_id":"ck8qr69du001l5d3aoel1p5ph"},{"post_id":"ck8qr69d200065d3aufvzldkm","tag_id":"ck8qr69dc000l5d3abjro5tab","_id":"ck8qr69dv001m5d3a7gbjgubg"},{"post_id":"ck8qr69d300075d3a5tzw7156","tag_id":"ck8qr69da000g5d3a3lg7eh54","_id":"ck8qr69dv001o5d3a9y6sc5ex"},{"post_id":"ck8qr69d300075d3a5tzw7156","tag_id":"ck8qr69dc000l5d3abjro5tab","_id":"ck8qr69dw001p5d3avrpnbw6j"},{"post_id":"ck8qr69d5000a5d3ar8hvyt0c","tag_id":"ck8qr69da000g5d3a3lg7eh54","_id":"ck8qr69dw001r5d3aydu8daqa"},{"post_id":"ck8qr69d5000a5d3ar8hvyt0c","tag_id":"ck8qr69dc000l5d3abjro5tab","_id":"ck8qr69dy001s5d3a4x5gka6u"},{"post_id":"ck8qr69d8000d5d3ar1n8iiy3","tag_id":"ck8qr69dv001n5d3ab35uh0yn","_id":"ck8qr69dz001u5d3ac99mnx30"},{"post_id":"ck8qr69d9000f5d3abzf5hgma","tag_id":"ck8qr69dv001n5d3ab35uh0yn","_id":"ck8qr69dz001v5d3amxp2syjk"},{"post_id":"ck8qr69da000h5d3avd58szod","tag_id":"ck8qr69da000g5d3a3lg7eh54","_id":"ck8qr69e0001x5d3a71yiopro"},{"post_id":"ck8qr69da000h5d3avd58szod","tag_id":"ck8qr69dy001t5d3aq4544klu","_id":"ck8qr69e0001y5d3ad2af3vin"},{"post_id":"ck8qr69db000j5d3acz0ms85e","tag_id":"ck8qr69dv001n5d3ab35uh0yn","_id":"ck8qr69e100205d3a1iag9l1n"},{"post_id":"ck8qr69dd000m5d3adydx0myt","tag_id":"ck8qr69dv001n5d3ab35uh0yn","_id":"ck8qr69e200225d3alviqicjs"},{"post_id":"ck8qr69de000o5d3a4w2l96lg","tag_id":"ck8qr69dv001n5d3ab35uh0yn","_id":"ck8qr69e300245d3acw1w0fn6"},{"post_id":"ck8qr69de000p5d3a07s9nc10","tag_id":"ck8qr69dv001n5d3ab35uh0yn","_id":"ck8qr69e400275d3agz8fasvw"},{"post_id":"ck8qr69de000p5d3a07s9nc10","tag_id":"ck8qr69e300255d3ara4gx63y","_id":"ck8qr69e400285d3ac8jkxkwl"},{"post_id":"ck8qr69dj000x5d3amatbapx7","tag_id":"ck8qr69e400265d3aghf7ac2f","_id":"ck8qr69e4002b5d3acwhpg06u"},{"post_id":"ck8qr69dj000x5d3amatbapx7","tag_id":"ck8qr69d400085d3apjig2t86","_id":"ck8qr69e5002c5d3ainktryaj"},{"post_id":"ck8qr69dj000x5d3amatbapx7","tag_id":"ck8qr69e400295d3a58sah94l","_id":"ck8qr69e5002e5d3a6tdbbcsd"},{"post_id":"ck8qr69dk000z5d3a0ndwtz9t","tag_id":"ck8qr69e4002a5d3a22cmo2wb","_id":"ck8qr69e5002f5d3aatgxt0ib"},{"post_id":"ck8qr69dp00195d3a1j9fbwao","tag_id":"ck8qr69dv001n5d3ab35uh0yn","_id":"ck8qr69e6002i5d3ar6901o3a"},{"post_id":"ck8qr69dp00195d3a1j9fbwao","tag_id":"ck8qr69e5002g5d3agszdx9vl","_id":"ck8qr69e6002j5d3a9m751r4d"},{"post_id":"ck8qr69dr001c5d3a5465dxx0","tag_id":"ck8qr69dv001n5d3ab35uh0yn","_id":"ck8qr69e6002k5d3a1sq0pocj"}],"Tag":[{"name":"script","_id":"ck8qr69cz00045d3a2l0czdab"},{"name":"linux","_id":"ck8qr69d400085d3apjig2t86"},{"name":"algorithm","_id":"ck8qr69d7000b5d3a92s87ihm"},{"name":"题解","_id":"ck8qr69da000g5d3a3lg7eh54"},{"name":"HDU","_id":"ck8qr69dc000l5d3abjro5tab"},{"name":"codeforces","_id":"ck8qr69di000v5d3amli7nfzw"},{"name":"note","_id":"ck8qr69dv001n5d3ab35uh0yn"},{"name":"POJ","_id":"ck8qr69dy001t5d3aq4544klu"},{"name":"转载","_id":"ck8qr69e300255d3ara4gx63y"},{"name":"Project","_id":"ck8qr69e400265d3aghf7ac2f"},{"name":"C","_id":"ck8qr69e400295d3a58sah94l"},{"name":"tools","_id":"ck8qr69e4002a5d3a22cmo2wb"},{"name":"alogrithm","_id":"ck8qr69e5002g5d3agszdx9vl"}]}}